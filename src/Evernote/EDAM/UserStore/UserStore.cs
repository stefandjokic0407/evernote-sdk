/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.UserStore
{
  public partial class UserStore {
    /// <summary>
    /// Service:  UserStore
    /// <p>
    /// The UserStore service is primarily used by EDAM clients to establish
    /// authentication via username and password over a trusted connection (e.g.
    /// SSL).  A client's first call to this interface should be checkVersion() to
    /// ensure that the client's software is up to date.
    /// </p>
    /// All calls which require an authenticationToken may throw an
    /// EDAMUserException for the following reasons:
    ///  <ul>
    ///   <li> AUTH_EXPIRED "authenticationToken" - token has expired
    ///   <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    ///   <li> DATA_REQUIRED "authenticationToken" - token is empty
    ///   <li> INVALID_AUTH "authenticationToken" - token signature is invalid
    ///   <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
    ///     privileges
    /// </ul>
    /// </summary>
    public interface ISync {
      /// <summary>
      /// This should be the first call made by a client to the EDAM service.  It
      /// tells the service what protocol version is used by the client.  The
      /// service will then return true if the client is capable of talking to
      /// the service, and false if the client's protocol version is incompatible
      /// with the service, so the client must upgrade.  If a client receives a
      /// false value, it should report the incompatibility to the user and not
      /// continue with any more EDAM requests (UserStore or NoteStore).
      /// 
      /// @param clientName
      ///   This string provides some information about the client for
      ///   tracking/logging on the service.  It should provide information about
      ///   the client's software and platform. The structure should be:
      ///   application/version; platform/version; [ device/version ]
      ///   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
      /// 
      /// @param edamVersionMajor
      ///   This should be the major protocol version that was compiled by the
      ///   client.  This should be the current value of the EDAM_VERSION_MAJOR
      ///   constant for the client.
      /// 
      /// @param edamVersionMinor
      ///   This should be the major protocol version that was compiled by the
      ///   client.  This should be the current value of the EDAM_VERSION_MINOR
      ///   constant for the client.
      /// </summary>
      /// <param name="clientName"></param>
      /// <param name="edamVersionMajor"></param>
      /// <param name="edamVersionMinor"></param>
      bool checkVersion(string clientName, short edamVersionMajor, short edamVersionMinor);
      /// <summary>
      /// This provides bootstrap information to the client. Various bootstrap
      /// profiles and settings may be used by the client to configure itself.
      /// 
      /// @param locale
      ///   The client's current locale, expressed in language[_country]
      ///   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      ///   language and country codes.
      /// 
      /// @return
      ///   The bootstrap information suitable for this client.
      /// </summary>
      /// <param name="locale"></param>
      BootstrapInfo getBootstrapInfo(string locale);
      /// <summary>
      /// This is used to check a username and password in order to create a
      /// long-lived authentication token that can be used for further actions.
      /// 
      /// This function is not available to most third party applications,
      /// which typically authenticate using OAuth as
      /// described at
      /// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
      /// If you believe that your application requires permission to authenticate
      /// using username and password instead of OAuth, please contact Evernote
      /// developer support by visiting
      /// <a href="http://dev.evernote.com">dev.evernote.com</a>.
      /// 
      /// @param username
      ///   The username or registered email address of the account to
      ///   authenticate against.
      /// 
      /// @param password
      ///   The plaintext password to check against the account.  Since
      ///   this is not protected by the EDAM protocol, this information must be
      ///   provided over a protected transport (i.e. SSL).
      /// 
      /// @param consumerKey
      ///   The "consumer key" portion of the API key issued to the client application
      ///   by Evernote.
      /// 
      /// @param consumerSecret
      ///   The "consumer secret" portion of the API key issued to the client application
      ///   by Evernote.
      /// 
      /// @param deviceIdentifier
      ///   An optional string that uniquely identifies the device from which the
      ///   authentication is being performed. This string allows the service to return the
      ///   same authentication token when a given application requests authentication
      ///   repeatedly from the same device. This may happen when the user logs out of an
      ///   application and then logs back in, or when the application is uninstalled
      ///   and later reinstalled. If no reliable device identifier can be created,
      ///   this value should be omitted. If set, the device identifier must be between
      ///   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
      ///   EDAM_DEVICE_ID_REGEX.
      /// 
      /// @param deviceDescription
      ///   A description of the device from which the authentication is being performed.
      ///   This field is displayed to the user in a list of authorized applications to
      ///   allow them to distinguish between multiple tokens issued to the same client
      ///   application on different devices. For example, the Evernote iOS client on
      ///   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
      ///   "Bob's iPad". The device description must be between 1 and
      ///   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
      ///   expression EDAM_DEVICE_DESCRIPTION_REGEX.
      /// 
      /// @param supportsTwoFactor
      ///   Whether the calling application supports two-factor authentication. If this
      ///   parameter is false, this method will fail with the error code INVALID_AUTH and the
      ///   parameter "password" when called for a user who has enabled two-factor
      ///   authentication.
      /// 
      /// @return
      ///   <p>The result of the authentication. The level of detail provided in the returned
      ///   AuthenticationResult.User structure depends on the access level granted by
      ///   calling application's API key.</p>
      ///   <p>If the user has two-factor authentication enabled,
      ///   AuthenticationResult.secondFactorRequired will be set and
      ///   AuthenticationResult.authenticationToken will contain a short-lived token
      ///   that may only be used to complete the two-factor authentication process by calling
      ///   UserStore.completeTwoFactorAuthentication.</p>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "username" - username is empty
      ///   <li> DATA_REQUIRED "password" - password is empty
      ///   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      ///   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
      ///   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
      ///   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
      ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
      ///   <li> INVALID_AUTH "username" - username not found
      ///   <li> INVALID_AUTH "password" - password did not match
      ///   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      ///   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      ///   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
      ///   <li> PERMISSION_DENIED "User.active" - user account is closed
      ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
      ///     failed authentication too often
      ///   <li> AUTH_EXPIRED "password" - user password is expired
      /// </ul>
      /// </summary>
      /// <param name="username"></param>
      /// <param name="password"></param>
      /// <param name="consumerKey"></param>
      /// <param name="consumerSecret"></param>
      /// <param name="deviceIdentifier"></param>
      /// <param name="deviceDescription"></param>
      /// <param name="supportsTwoFactor"></param>
      AuthenticationResult authenticateLongSession(string username, string password, string consumerKey, string consumerSecret, string deviceIdentifier, string deviceDescription, bool supportsTwoFactor);
      /// <summary>
      /// Complete the authentication process when a second factor is required. This
      /// call is made after a successful call to authenticate or authenticateLongSession
      /// when the authenticating user has enabled two-factor authentication.
      /// 
      /// @param authenticationToken An authentication token returned by a previous
      ///   call to UserStore.authenticate or UserStore.authenticateLongSession that
      ///   could not be completed in a single call because a second factor was required.
      /// 
      /// @param oneTimeCode The one time code entered by the user. This value is delivered
      ///   out-of-band, typically via SMS or an authenticator application.
      /// 
      /// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
      /// 
      /// @param deviceDescription See the corresponding parameter in authenticateLongSession.
      /// 
      /// @return
      ///   The result of the authentication. The level of detail provided in the returned
      ///   AuthenticationResult.User structure depends on the access level granted by the
      ///   calling application's API key. If the initial authentication call was made to
      ///   authenticateLongSession, the AuthenticationResult will contain a long-lived
      ///   authentication token.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
      ///   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
      ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
      ///   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
      ///   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
      ///   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
      ///   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
      ///   <li> PERMISSION_DENIED "User.active" - user account is closed
      ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
      ///     failed authentication too often
      ///   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
      ///      two-factor authentication.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="oneTimeCode"></param>
      /// <param name="deviceIdentifier"></param>
      /// <param name="deviceDescription"></param>
      AuthenticationResult completeTwoFactorAuthentication(string authenticationToken, string oneTimeCode, string deviceIdentifier, string deviceDescription);
      /// <summary>
      /// Revoke an existing long lived authentication token. This can be used to
      /// revoke OAuth tokens or tokens created by calling authenticateLongSession,
      /// and allows a user to effectively log out of Evernote from the perspective
      /// of the application that holds the token. The authentication token that is
      /// passed is immediately revoked and may not be used to call any authenticated
      /// EDAM function.
      /// 
      /// @param authenticationToken the authentication token to revoke.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
      ///   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
      ///   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
      ///   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
      ///     is already revoked.
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      void revokeLongSession(string authenticationToken);
      /// <summary>
      /// This is used to take an existing authentication token that grants access
      /// to an individual user account (returned from 'authenticate',
      /// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
      /// authentication token that may be used to access business notebooks if the user
      /// is a member of an Evernote Business account.
      /// 
      /// The resulting authentication token may be used to make NoteStore API calls
      /// against the business using the NoteStore URL returned in the result.
      /// 
      /// @param authenticationToken
      ///   The authentication token for the user. This may not be a shared authentication
      ///   token (returned by NoteStore.authenticateToSharedNotebook or
      ///   NoteStore.authenticateToSharedNote) or a business authentication token.
      /// 
      /// @return
      ///   The result of the authentication, with the token granting access to the
      ///   business in the result's 'authenticationToken' field. The URL that must
      ///   be used to access the business account NoteStore will be returned in the
      ///   result's 'noteStoreUrl' field.  The 'User' field will
      ///   not be set in the result.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
      ///        is a shared or business authentication token. </li>
      ///   <li> PERMISSION_DENIED "Business" - the user identified by the provided
      ///        authentication token is not currently a member of a business. </li>
      ///   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
      ///        member of is not currently in an active status. </li>
      ///   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
      ///        sign-on before authenticating to the business.
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      AuthenticationResult authenticateToBusiness(string authenticationToken);
      /// <summary>
      /// Returns the User corresponding to the provided authentication token,
      /// or throws an exception if this token is not valid.
      /// The level of detail provided in the returned User structure depends on
      /// the access level granted by the token, so a web service client may receive
      /// fewer fields than an integrated desktop client.
      /// </summary>
      /// <param name="authenticationToken"></param>
      Evernote.EDAM.Type.User getUser(string authenticationToken);
      /// <summary>
      /// Asks the UserStore about the publicly available location information for
      /// a particular username.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "username" - username is empty
      /// </ul>
      /// </summary>
      /// <param name="username"></param>
      PublicUserInfo getPublicUserInfo(string username);
      /// <summary>
      /// <p>Returns the URLs that should be used when sending requests to the service on
      /// behalf of the account represented by the provided authenticationToken.</p>
      /// 
      /// <p>This method isn't needed by most clients, who can retreive the correct set of
      /// UserUrls from the AuthenticationResult returned from
      /// UserStore#authenticateLongSession(). This method is typically only needed to look up
      /// the correct URLs for an existing long-lived authentication token.</p>
      /// </summary>
      /// <param name="authenticationToken"></param>
      UserUrls getUserUrls(string authenticationToken);
      /// <summary>
      /// Invite a user to join an Evernote Business account.
      /// 
      /// Behavior will depend on the auth token. <ol>
      ///   <li>
      ///     auth token with privileges to manage Evernote Business membership.
      ///       "External Provisioning" - The user will receive an email inviting
      ///       them to join the business. They do not need to have an existing Evernote
      ///       account. If the user has already been invited, a new invitation email
      ///       will be sent.
      ///   </li>
      ///   <li>
      ///     business auth token issued to an admin user. Only for first-party clients:
      ///       "Approve Invitation" - If there has been a request to invite the email,
      ///       approve it. Invited user will receive email with a link to join business.
      ///       "Invite User" - If no invitation for the email exists, create an approved
      ///       invitation for the email. An email will be sent to the emailAddress with
      ///       a link to join the caller's business.
      ///   </li>
      ///   </li>
      ///     business auth token:
      ///       "Request Invitation" - If no invitation exists, create a request to
      ///       invite the user to the business. These requests do not count towards a
      ///       business' max active user limit.
      ///   </li>
      /// </ol>
      /// 
      /// @param authenticationToken
      ///   the authentication token with sufficient privileges to manage Evernote Business
      ///   membership or a business auth token.
      /// 
      /// @param emailAddress
      ///   the email address of the user to invite to join the Evernote Business account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
      ///   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
      ///   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
      ///     whose business email address matches the specified email address. </li>
      ///   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
      ///     user limit. </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="emailAddress"></param>
      void inviteToBusiness(string authenticationToken, string emailAddress);
      /// <summary>
      /// Remove a user from an Evernote Business account. Once removed, the user will no
      /// longer be able to access content within the Evernote Business account.
      /// 
      /// <p>The email address of the user to remove from the business must match the email
      /// address used to invite a user to join the business via UserStore.inviteToBusiness.
      /// This function will only remove users who were invited by external provisioning</p>
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business
      ///   membership.
      /// 
      /// @param emailAddress
      ///   The email address of the user to remove from the Evernote Business account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
      ///   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "email" - If there is no user with the specified email address in the
      ///     business or that user was not invited via external provisioning. </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="emailAddress"></param>
      void removeFromBusiness(string authenticationToken, string emailAddress);
      /// <summary>
      /// Update the email address used to uniquely identify an Evernote Business user.
      /// 
      /// This will update the identifier for a user who was previously invited using
      /// inviteToBusiness, ensuring that caller and the Evernote service maintain an
      /// agreed-upon identifier for a specific user.
      /// 
      /// For example, the following sequence of calls would invite a user to join
      /// a business, update their email address, and then remove the user
      /// from the business using the updated email address.
      /// 
      /// inviteToBusiness("foo@bar.com")
      /// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
      /// removeFromBusiness("baz@bar.com")
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business
      ///   membership.
      /// 
      /// @param oldEmailAddress
      ///   The existing email address used to uniquely identify the user.
      /// 
      /// @param newEmailAddress
      ///   The new email address used to uniquely identify the user.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
      ///   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
      ///   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
      ///   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
      ///   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
      ///   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
      ///     the provided new email address.</li>
      ///   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
      ///     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
      ///     updated.</li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
      ///     in the business.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="oldEmailAddress"></param>
      /// <param name="newEmailAddress"></param>
      void updateBusinessUserIdentifier(string authenticationToken, string oldEmailAddress, string newEmailAddress);
      /// <summary>
      /// Returns a list of active business users in a given business.
      /// 
      /// Clients are required to cache this information and re-fetch no more than once per day
      /// or when they encountered a user ID or username that was not known to them.
      /// 
      /// To avoid excessive look ups, clients should also track user IDs and usernames that belong
      /// to users who are not in the business, since they will not be included in the result.
      /// 
      /// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
      /// listBusinessUsers to find information about this user. If the user is not in the resulting
      /// list, the client should track that fact and not re-query the service the next time that it sees
      /// this user on a note.
      /// 
      /// @param authenticationToken
      ///   A business authentication token returned by authenticateToBusiness or with sufficient
      ///   privileges to manage Evernote Business membership.
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.UserProfile> listBusinessUsers(string authenticationToken);
      /// <summary>
      /// Returns a list of outstanding invitations to join an Evernote Business account.
      /// 
      /// Only outstanding invitations are returned by this function. Users who have accepted an
      /// invitation and joined a business are listed using listBusinessUsers.
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business membership.
      /// 
      /// @param includeRequestedInvitations
      ///   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
      ///   in the returned list. If false, only invitations with a status of
      ///   BusinessInvitationStatus.APPROVED will be included.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="includeRequestedInvitations"></param>
      List<Evernote.EDAM.Type.BusinessInvitation> listBusinessInvitations(string authenticationToken, bool includeRequestedInvitations);
      /// <summary>
      /// Retrieve the standard account limits for a given service level. This should only be
      /// called when necessary, e.g. to determine if a higher level is available should the
      /// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
      /// not expected to fluctuate frequently.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
      /// </ul>
      /// </summary>
      /// <param name="serviceLevel"></param>
      Evernote.EDAM.Type.AccountLimits getAccountLimits(Evernote.EDAM.Type.ServiceLevel serviceLevel);
    }

    /// <summary>
    /// Service:  UserStore
    /// <p>
    /// The UserStore service is primarily used by EDAM clients to establish
    /// authentication via username and password over a trusted connection (e.g.
    /// SSL).  A client's first call to this interface should be checkVersion() to
    /// ensure that the client's software is up to date.
    /// </p>
    /// All calls which require an authenticationToken may throw an
    /// EDAMUserException for the following reasons:
    ///  <ul>
    ///   <li> AUTH_EXPIRED "authenticationToken" - token has expired
    ///   <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    ///   <li> DATA_REQUIRED "authenticationToken" - token is empty
    ///   <li> INVALID_AUTH "authenticationToken" - token signature is invalid
    ///   <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
    ///     privileges
    /// </ul>
    /// </summary>
    public interface Iface : ISync {
      /// <summary>
      /// This should be the first call made by a client to the EDAM service.  It
      /// tells the service what protocol version is used by the client.  The
      /// service will then return true if the client is capable of talking to
      /// the service, and false if the client's protocol version is incompatible
      /// with the service, so the client must upgrade.  If a client receives a
      /// false value, it should report the incompatibility to the user and not
      /// continue with any more EDAM requests (UserStore or NoteStore).
      /// 
      /// @param clientName
      ///   This string provides some information about the client for
      ///   tracking/logging on the service.  It should provide information about
      ///   the client's software and platform. The structure should be:
      ///   application/version; platform/version; [ device/version ]
      ///   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
      /// 
      /// @param edamVersionMajor
      ///   This should be the major protocol version that was compiled by the
      ///   client.  This should be the current value of the EDAM_VERSION_MAJOR
      ///   constant for the client.
      /// 
      /// @param edamVersionMinor
      ///   This should be the major protocol version that was compiled by the
      ///   client.  This should be the current value of the EDAM_VERSION_MINOR
      ///   constant for the client.
      /// </summary>
      /// <param name="clientName"></param>
      /// <param name="edamVersionMajor"></param>
      /// <param name="edamVersionMinor"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_checkVersion(AsyncCallback callback, object state, string clientName, short edamVersionMajor, short edamVersionMinor);
      bool End_checkVersion(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// This provides bootstrap information to the client. Various bootstrap
      /// profiles and settings may be used by the client to configure itself.
      /// 
      /// @param locale
      ///   The client's current locale, expressed in language[_country]
      ///   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      ///   language and country codes.
      /// 
      /// @return
      ///   The bootstrap information suitable for this client.
      /// </summary>
      /// <param name="locale"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getBootstrapInfo(AsyncCallback callback, object state, string locale);
      BootstrapInfo End_getBootstrapInfo(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// This is used to check a username and password in order to create a
      /// long-lived authentication token that can be used for further actions.
      /// 
      /// This function is not available to most third party applications,
      /// which typically authenticate using OAuth as
      /// described at
      /// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
      /// If you believe that your application requires permission to authenticate
      /// using username and password instead of OAuth, please contact Evernote
      /// developer support by visiting
      /// <a href="http://dev.evernote.com">dev.evernote.com</a>.
      /// 
      /// @param username
      ///   The username or registered email address of the account to
      ///   authenticate against.
      /// 
      /// @param password
      ///   The plaintext password to check against the account.  Since
      ///   this is not protected by the EDAM protocol, this information must be
      ///   provided over a protected transport (i.e. SSL).
      /// 
      /// @param consumerKey
      ///   The "consumer key" portion of the API key issued to the client application
      ///   by Evernote.
      /// 
      /// @param consumerSecret
      ///   The "consumer secret" portion of the API key issued to the client application
      ///   by Evernote.
      /// 
      /// @param deviceIdentifier
      ///   An optional string that uniquely identifies the device from which the
      ///   authentication is being performed. This string allows the service to return the
      ///   same authentication token when a given application requests authentication
      ///   repeatedly from the same device. This may happen when the user logs out of an
      ///   application and then logs back in, or when the application is uninstalled
      ///   and later reinstalled. If no reliable device identifier can be created,
      ///   this value should be omitted. If set, the device identifier must be between
      ///   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
      ///   EDAM_DEVICE_ID_REGEX.
      /// 
      /// @param deviceDescription
      ///   A description of the device from which the authentication is being performed.
      ///   This field is displayed to the user in a list of authorized applications to
      ///   allow them to distinguish between multiple tokens issued to the same client
      ///   application on different devices. For example, the Evernote iOS client on
      ///   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
      ///   "Bob's iPad". The device description must be between 1 and
      ///   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
      ///   expression EDAM_DEVICE_DESCRIPTION_REGEX.
      /// 
      /// @param supportsTwoFactor
      ///   Whether the calling application supports two-factor authentication. If this
      ///   parameter is false, this method will fail with the error code INVALID_AUTH and the
      ///   parameter "password" when called for a user who has enabled two-factor
      ///   authentication.
      /// 
      /// @return
      ///   <p>The result of the authentication. The level of detail provided in the returned
      ///   AuthenticationResult.User structure depends on the access level granted by
      ///   calling application's API key.</p>
      ///   <p>If the user has two-factor authentication enabled,
      ///   AuthenticationResult.secondFactorRequired will be set and
      ///   AuthenticationResult.authenticationToken will contain a short-lived token
      ///   that may only be used to complete the two-factor authentication process by calling
      ///   UserStore.completeTwoFactorAuthentication.</p>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "username" - username is empty
      ///   <li> DATA_REQUIRED "password" - password is empty
      ///   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      ///   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
      ///   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
      ///   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
      ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
      ///   <li> INVALID_AUTH "username" - username not found
      ///   <li> INVALID_AUTH "password" - password did not match
      ///   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      ///   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      ///   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
      ///   <li> PERMISSION_DENIED "User.active" - user account is closed
      ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
      ///     failed authentication too often
      ///   <li> AUTH_EXPIRED "password" - user password is expired
      /// </ul>
      /// </summary>
      /// <param name="username"></param>
      /// <param name="password"></param>
      /// <param name="consumerKey"></param>
      /// <param name="consumerSecret"></param>
      /// <param name="deviceIdentifier"></param>
      /// <param name="deviceDescription"></param>
      /// <param name="supportsTwoFactor"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_authenticateLongSession(AsyncCallback callback, object state, string username, string password, string consumerKey, string consumerSecret, string deviceIdentifier, string deviceDescription, bool supportsTwoFactor);
      AuthenticationResult End_authenticateLongSession(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Complete the authentication process when a second factor is required. This
      /// call is made after a successful call to authenticate or authenticateLongSession
      /// when the authenticating user has enabled two-factor authentication.
      /// 
      /// @param authenticationToken An authentication token returned by a previous
      ///   call to UserStore.authenticate or UserStore.authenticateLongSession that
      ///   could not be completed in a single call because a second factor was required.
      /// 
      /// @param oneTimeCode The one time code entered by the user. This value is delivered
      ///   out-of-band, typically via SMS or an authenticator application.
      /// 
      /// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
      /// 
      /// @param deviceDescription See the corresponding parameter in authenticateLongSession.
      /// 
      /// @return
      ///   The result of the authentication. The level of detail provided in the returned
      ///   AuthenticationResult.User structure depends on the access level granted by the
      ///   calling application's API key. If the initial authentication call was made to
      ///   authenticateLongSession, the AuthenticationResult will contain a long-lived
      ///   authentication token.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
      ///   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
      ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
      ///   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
      ///   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
      ///   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
      ///   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
      ///   <li> PERMISSION_DENIED "User.active" - user account is closed
      ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
      ///     failed authentication too often
      ///   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
      ///      two-factor authentication.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="oneTimeCode"></param>
      /// <param name="deviceIdentifier"></param>
      /// <param name="deviceDescription"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_completeTwoFactorAuthentication(AsyncCallback callback, object state, string authenticationToken, string oneTimeCode, string deviceIdentifier, string deviceDescription);
      AuthenticationResult End_completeTwoFactorAuthentication(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Revoke an existing long lived authentication token. This can be used to
      /// revoke OAuth tokens or tokens created by calling authenticateLongSession,
      /// and allows a user to effectively log out of Evernote from the perspective
      /// of the application that holds the token. The authentication token that is
      /// passed is immediately revoked and may not be used to call any authenticated
      /// EDAM function.
      /// 
      /// @param authenticationToken the authentication token to revoke.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
      ///   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
      ///   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
      ///   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
      ///     is already revoked.
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_revokeLongSession(AsyncCallback callback, object state, string authenticationToken);
      void End_revokeLongSession(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// This is used to take an existing authentication token that grants access
      /// to an individual user account (returned from 'authenticate',
      /// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
      /// authentication token that may be used to access business notebooks if the user
      /// is a member of an Evernote Business account.
      /// 
      /// The resulting authentication token may be used to make NoteStore API calls
      /// against the business using the NoteStore URL returned in the result.
      /// 
      /// @param authenticationToken
      ///   The authentication token for the user. This may not be a shared authentication
      ///   token (returned by NoteStore.authenticateToSharedNotebook or
      ///   NoteStore.authenticateToSharedNote) or a business authentication token.
      /// 
      /// @return
      ///   The result of the authentication, with the token granting access to the
      ///   business in the result's 'authenticationToken' field. The URL that must
      ///   be used to access the business account NoteStore will be returned in the
      ///   result's 'noteStoreUrl' field.  The 'User' field will
      ///   not be set in the result.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
      ///        is a shared or business authentication token. </li>
      ///   <li> PERMISSION_DENIED "Business" - the user identified by the provided
      ///        authentication token is not currently a member of a business. </li>
      ///   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
      ///        member of is not currently in an active status. </li>
      ///   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
      ///        sign-on before authenticating to the business.
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_authenticateToBusiness(AsyncCallback callback, object state, string authenticationToken);
      AuthenticationResult End_authenticateToBusiness(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the User corresponding to the provided authentication token,
      /// or throws an exception if this token is not valid.
      /// The level of detail provided in the returned User structure depends on
      /// the access level granted by the token, so a web service client may receive
      /// fewer fields than an integrated desktop client.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getUser(AsyncCallback callback, object state, string authenticationToken);
      Evernote.EDAM.Type.User End_getUser(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the UserStore about the publicly available location information for
      /// a particular username.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "username" - username is empty
      /// </ul>
      /// </summary>
      /// <param name="username"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getPublicUserInfo(AsyncCallback callback, object state, string username);
      PublicUserInfo End_getPublicUserInfo(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// <p>Returns the URLs that should be used when sending requests to the service on
      /// behalf of the account represented by the provided authenticationToken.</p>
      /// 
      /// <p>This method isn't needed by most clients, who can retreive the correct set of
      /// UserUrls from the AuthenticationResult returned from
      /// UserStore#authenticateLongSession(). This method is typically only needed to look up
      /// the correct URLs for an existing long-lived authentication token.</p>
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getUserUrls(AsyncCallback callback, object state, string authenticationToken);
      UserUrls End_getUserUrls(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Invite a user to join an Evernote Business account.
      /// 
      /// Behavior will depend on the auth token. <ol>
      ///   <li>
      ///     auth token with privileges to manage Evernote Business membership.
      ///       "External Provisioning" - The user will receive an email inviting
      ///       them to join the business. They do not need to have an existing Evernote
      ///       account. If the user has already been invited, a new invitation email
      ///       will be sent.
      ///   </li>
      ///   <li>
      ///     business auth token issued to an admin user. Only for first-party clients:
      ///       "Approve Invitation" - If there has been a request to invite the email,
      ///       approve it. Invited user will receive email with a link to join business.
      ///       "Invite User" - If no invitation for the email exists, create an approved
      ///       invitation for the email. An email will be sent to the emailAddress with
      ///       a link to join the caller's business.
      ///   </li>
      ///   </li>
      ///     business auth token:
      ///       "Request Invitation" - If no invitation exists, create a request to
      ///       invite the user to the business. These requests do not count towards a
      ///       business' max active user limit.
      ///   </li>
      /// </ol>
      /// 
      /// @param authenticationToken
      ///   the authentication token with sufficient privileges to manage Evernote Business
      ///   membership or a business auth token.
      /// 
      /// @param emailAddress
      ///   the email address of the user to invite to join the Evernote Business account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
      ///   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
      ///   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
      ///     whose business email address matches the specified email address. </li>
      ///   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
      ///     user limit. </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="emailAddress"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_inviteToBusiness(AsyncCallback callback, object state, string authenticationToken, string emailAddress);
      void End_inviteToBusiness(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Remove a user from an Evernote Business account. Once removed, the user will no
      /// longer be able to access content within the Evernote Business account.
      /// 
      /// <p>The email address of the user to remove from the business must match the email
      /// address used to invite a user to join the business via UserStore.inviteToBusiness.
      /// This function will only remove users who were invited by external provisioning</p>
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business
      ///   membership.
      /// 
      /// @param emailAddress
      ///   The email address of the user to remove from the Evernote Business account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
      ///   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "email" - If there is no user with the specified email address in the
      ///     business or that user was not invited via external provisioning. </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="emailAddress"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_removeFromBusiness(AsyncCallback callback, object state, string authenticationToken, string emailAddress);
      void End_removeFromBusiness(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Update the email address used to uniquely identify an Evernote Business user.
      /// 
      /// This will update the identifier for a user who was previously invited using
      /// inviteToBusiness, ensuring that caller and the Evernote service maintain an
      /// agreed-upon identifier for a specific user.
      /// 
      /// For example, the following sequence of calls would invite a user to join
      /// a business, update their email address, and then remove the user
      /// from the business using the updated email address.
      /// 
      /// inviteToBusiness("foo@bar.com")
      /// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
      /// removeFromBusiness("baz@bar.com")
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business
      ///   membership.
      /// 
      /// @param oldEmailAddress
      ///   The existing email address used to uniquely identify the user.
      /// 
      /// @param newEmailAddress
      ///   The new email address used to uniquely identify the user.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
      ///   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
      ///   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
      ///   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
      ///   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
      ///   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
      ///     the provided new email address.</li>
      ///   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
      ///     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
      ///     updated.</li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
      ///     in the business.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="oldEmailAddress"></param>
      /// <param name="newEmailAddress"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateBusinessUserIdentifier(AsyncCallback callback, object state, string authenticationToken, string oldEmailAddress, string newEmailAddress);
      void End_updateBusinessUserIdentifier(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of active business users in a given business.
      /// 
      /// Clients are required to cache this information and re-fetch no more than once per day
      /// or when they encountered a user ID or username that was not known to them.
      /// 
      /// To avoid excessive look ups, clients should also track user IDs and usernames that belong
      /// to users who are not in the business, since they will not be included in the result.
      /// 
      /// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
      /// listBusinessUsers to find information about this user. If the user is not in the resulting
      /// list, the client should track that fact and not re-query the service the next time that it sees
      /// this user on a note.
      /// 
      /// @param authenticationToken
      ///   A business authentication token returned by authenticateToBusiness or with sufficient
      ///   privileges to manage Evernote Business membership.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listBusinessUsers(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.UserProfile> End_listBusinessUsers(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of outstanding invitations to join an Evernote Business account.
      /// 
      /// Only outstanding invitations are returned by this function. Users who have accepted an
      /// invitation and joined a business are listed using listBusinessUsers.
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business membership.
      /// 
      /// @param includeRequestedInvitations
      ///   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
      ///   in the returned list. If false, only invitations with a status of
      ///   BusinessInvitationStatus.APPROVED will be included.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="includeRequestedInvitations"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listBusinessInvitations(AsyncCallback callback, object state, string authenticationToken, bool includeRequestedInvitations);
      List<Evernote.EDAM.Type.BusinessInvitation> End_listBusinessInvitations(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Retrieve the standard account limits for a given service level. This should only be
      /// called when necessary, e.g. to determine if a higher level is available should the
      /// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
      /// not expected to fluctuate frequently.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
      /// </ul>
      /// </summary>
      /// <param name="serviceLevel"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getAccountLimits(AsyncCallback callback, object state, Evernote.EDAM.Type.ServiceLevel serviceLevel);
      Evernote.EDAM.Type.AccountLimits End_getAccountLimits(IAsyncResult asyncResult);
      #endif
    }

    /// <summary>
    /// Service:  UserStore
    /// <p>
    /// The UserStore service is primarily used by EDAM clients to establish
    /// authentication via username and password over a trusted connection (e.g.
    /// SSL).  A client's first call to this interface should be checkVersion() to
    /// ensure that the client's software is up to date.
    /// </p>
    /// All calls which require an authenticationToken may throw an
    /// EDAMUserException for the following reasons:
    ///  <ul>
    ///   <li> AUTH_EXPIRED "authenticationToken" - token has expired
    ///   <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
    ///   <li> DATA_REQUIRED "authenticationToken" - token is empty
    ///   <li> INVALID_AUTH "authenticationToken" - token signature is invalid
    ///   <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
    ///     privileges
    /// </ul>
    /// </summary>
    public class Client : IDisposable, Iface {
      public Client(TProtocol prot) : this(prot, prot)
      {
      }

      public Client(TProtocol iprot, TProtocol oprot)
      {
        iprot_ = iprot;
        oprot_ = oprot;
      }

      protected TProtocol iprot_;
      protected TProtocol oprot_;
      protected int seqid_;

      public TProtocol InputProtocol
      {
        get { return iprot_; }
      }
      public TProtocol OutputProtocol
      {
        get { return oprot_; }
      }


      #region " IDisposable Support "
      private bool _IsDisposed;

      // IDisposable
      public void Dispose()
      {
        Dispose(true);
      }
      

      protected virtual void Dispose(bool disposing)
      {
        if (!_IsDisposed)
        {
          if (disposing)
          {
            if (iprot_ != null)
            {
              ((IDisposable)iprot_).Dispose();
            }
            if (oprot_ != null)
            {
              ((IDisposable)oprot_).Dispose();
            }
          }
        }
        _IsDisposed = true;
      }
      #endregion


      
      #if SILVERLIGHT
      public IAsyncResult Begin_checkVersion(AsyncCallback callback, object state, string clientName, short edamVersionMajor, short edamVersionMinor)
      {
        return send_checkVersion(callback, state, clientName, edamVersionMajor, edamVersionMinor);
      }

      public bool End_checkVersion(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_checkVersion();
      }

      #endif

      /// <summary>
      /// This should be the first call made by a client to the EDAM service.  It
      /// tells the service what protocol version is used by the client.  The
      /// service will then return true if the client is capable of talking to
      /// the service, and false if the client's protocol version is incompatible
      /// with the service, so the client must upgrade.  If a client receives a
      /// false value, it should report the incompatibility to the user and not
      /// continue with any more EDAM requests (UserStore or NoteStore).
      /// 
      /// @param clientName
      ///   This string provides some information about the client for
      ///   tracking/logging on the service.  It should provide information about
      ///   the client's software and platform. The structure should be:
      ///   application/version; platform/version; [ device/version ]
      ///   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
      /// 
      /// @param edamVersionMajor
      ///   This should be the major protocol version that was compiled by the
      ///   client.  This should be the current value of the EDAM_VERSION_MAJOR
      ///   constant for the client.
      /// 
      /// @param edamVersionMinor
      ///   This should be the major protocol version that was compiled by the
      ///   client.  This should be the current value of the EDAM_VERSION_MINOR
      ///   constant for the client.
      /// </summary>
      /// <param name="clientName"></param>
      /// <param name="edamVersionMajor"></param>
      /// <param name="edamVersionMinor"></param>
      public bool checkVersion(string clientName, short edamVersionMajor, short edamVersionMinor)
      {
        #if !SILVERLIGHT
        send_checkVersion(clientName, edamVersionMajor, edamVersionMinor);
        return recv_checkVersion();

        #else
        var asyncResult = Begin_checkVersion(null, null, clientName, edamVersionMajor, edamVersionMinor);
        return End_checkVersion(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_checkVersion(AsyncCallback callback, object state, string clientName, short edamVersionMajor, short edamVersionMinor)
      #else
      public void send_checkVersion(string clientName, short edamVersionMajor, short edamVersionMinor)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("checkVersion", TMessageType.Call, seqid_));
        checkVersion_args args = new checkVersion_args();
        args.ClientName = clientName;
        args.EdamVersionMajor = edamVersionMajor;
        args.EdamVersionMinor = edamVersionMinor;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public bool recv_checkVersion()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        checkVersion_result result = new checkVersion_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "checkVersion failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getBootstrapInfo(AsyncCallback callback, object state, string locale)
      {
        return send_getBootstrapInfo(callback, state, locale);
      }

      public BootstrapInfo End_getBootstrapInfo(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getBootstrapInfo();
      }

      #endif

      /// <summary>
      /// This provides bootstrap information to the client. Various bootstrap
      /// profiles and settings may be used by the client to configure itself.
      /// 
      /// @param locale
      ///   The client's current locale, expressed in language[_country]
      ///   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
      ///   language and country codes.
      /// 
      /// @return
      ///   The bootstrap information suitable for this client.
      /// </summary>
      /// <param name="locale"></param>
      public BootstrapInfo getBootstrapInfo(string locale)
      {
        #if !SILVERLIGHT
        send_getBootstrapInfo(locale);
        return recv_getBootstrapInfo();

        #else
        var asyncResult = Begin_getBootstrapInfo(null, null, locale);
        return End_getBootstrapInfo(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getBootstrapInfo(AsyncCallback callback, object state, string locale)
      #else
      public void send_getBootstrapInfo(string locale)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getBootstrapInfo", TMessageType.Call, seqid_));
        getBootstrapInfo_args args = new getBootstrapInfo_args();
        args.Locale = locale;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public BootstrapInfo recv_getBootstrapInfo()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getBootstrapInfo_result result = new getBootstrapInfo_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getBootstrapInfo failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_authenticateLongSession(AsyncCallback callback, object state, string username, string password, string consumerKey, string consumerSecret, string deviceIdentifier, string deviceDescription, bool supportsTwoFactor)
      {
        return send_authenticateLongSession(callback, state, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
      }

      public AuthenticationResult End_authenticateLongSession(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_authenticateLongSession();
      }

      #endif

      /// <summary>
      /// This is used to check a username and password in order to create a
      /// long-lived authentication token that can be used for further actions.
      /// 
      /// This function is not available to most third party applications,
      /// which typically authenticate using OAuth as
      /// described at
      /// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
      /// If you believe that your application requires permission to authenticate
      /// using username and password instead of OAuth, please contact Evernote
      /// developer support by visiting
      /// <a href="http://dev.evernote.com">dev.evernote.com</a>.
      /// 
      /// @param username
      ///   The username or registered email address of the account to
      ///   authenticate against.
      /// 
      /// @param password
      ///   The plaintext password to check against the account.  Since
      ///   this is not protected by the EDAM protocol, this information must be
      ///   provided over a protected transport (i.e. SSL).
      /// 
      /// @param consumerKey
      ///   The "consumer key" portion of the API key issued to the client application
      ///   by Evernote.
      /// 
      /// @param consumerSecret
      ///   The "consumer secret" portion of the API key issued to the client application
      ///   by Evernote.
      /// 
      /// @param deviceIdentifier
      ///   An optional string that uniquely identifies the device from which the
      ///   authentication is being performed. This string allows the service to return the
      ///   same authentication token when a given application requests authentication
      ///   repeatedly from the same device. This may happen when the user logs out of an
      ///   application and then logs back in, or when the application is uninstalled
      ///   and later reinstalled. If no reliable device identifier can be created,
      ///   this value should be omitted. If set, the device identifier must be between
      ///   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
      ///   EDAM_DEVICE_ID_REGEX.
      /// 
      /// @param deviceDescription
      ///   A description of the device from which the authentication is being performed.
      ///   This field is displayed to the user in a list of authorized applications to
      ///   allow them to distinguish between multiple tokens issued to the same client
      ///   application on different devices. For example, the Evernote iOS client on
      ///   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
      ///   "Bob's iPad". The device description must be between 1 and
      ///   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
      ///   expression EDAM_DEVICE_DESCRIPTION_REGEX.
      /// 
      /// @param supportsTwoFactor
      ///   Whether the calling application supports two-factor authentication. If this
      ///   parameter is false, this method will fail with the error code INVALID_AUTH and the
      ///   parameter "password" when called for a user who has enabled two-factor
      ///   authentication.
      /// 
      /// @return
      ///   <p>The result of the authentication. The level of detail provided in the returned
      ///   AuthenticationResult.User structure depends on the access level granted by
      ///   calling application's API key.</p>
      ///   <p>If the user has two-factor authentication enabled,
      ///   AuthenticationResult.secondFactorRequired will be set and
      ///   AuthenticationResult.authenticationToken will contain a short-lived token
      ///   that may only be used to complete the two-factor authentication process by calling
      ///   UserStore.completeTwoFactorAuthentication.</p>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "username" - username is empty
      ///   <li> DATA_REQUIRED "password" - password is empty
      ///   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
      ///   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
      ///   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
      ///   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
      ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
      ///   <li> INVALID_AUTH "username" - username not found
      ///   <li> INVALID_AUTH "password" - password did not match
      ///   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
      ///   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
      ///   <li> INVALID_AUTH "businessOnly" - the user is a business-only account
      ///   <li> PERMISSION_DENIED "User.active" - user account is closed
      ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
      ///     failed authentication too often
      ///   <li> AUTH_EXPIRED "password" - user password is expired
      /// </ul>
      /// </summary>
      /// <param name="username"></param>
      /// <param name="password"></param>
      /// <param name="consumerKey"></param>
      /// <param name="consumerSecret"></param>
      /// <param name="deviceIdentifier"></param>
      /// <param name="deviceDescription"></param>
      /// <param name="supportsTwoFactor"></param>
      public AuthenticationResult authenticateLongSession(string username, string password, string consumerKey, string consumerSecret, string deviceIdentifier, string deviceDescription, bool supportsTwoFactor)
      {
        #if !SILVERLIGHT
        send_authenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
        return recv_authenticateLongSession();

        #else
        var asyncResult = Begin_authenticateLongSession(null, null, username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor);
        return End_authenticateLongSession(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_authenticateLongSession(AsyncCallback callback, object state, string username, string password, string consumerKey, string consumerSecret, string deviceIdentifier, string deviceDescription, bool supportsTwoFactor)
      #else
      public void send_authenticateLongSession(string username, string password, string consumerKey, string consumerSecret, string deviceIdentifier, string deviceDescription, bool supportsTwoFactor)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("authenticateLongSession", TMessageType.Call, seqid_));
        authenticateLongSession_args args = new authenticateLongSession_args();
        args.Username = username;
        args.Password = password;
        args.ConsumerKey = consumerKey;
        args.ConsumerSecret = consumerSecret;
        args.DeviceIdentifier = deviceIdentifier;
        args.DeviceDescription = deviceDescription;
        args.SupportsTwoFactor = supportsTwoFactor;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public AuthenticationResult recv_authenticateLongSession()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        authenticateLongSession_result result = new authenticateLongSession_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "authenticateLongSession failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_completeTwoFactorAuthentication(AsyncCallback callback, object state, string authenticationToken, string oneTimeCode, string deviceIdentifier, string deviceDescription)
      {
        return send_completeTwoFactorAuthentication(callback, state, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
      }

      public AuthenticationResult End_completeTwoFactorAuthentication(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_completeTwoFactorAuthentication();
      }

      #endif

      /// <summary>
      /// Complete the authentication process when a second factor is required. This
      /// call is made after a successful call to authenticate or authenticateLongSession
      /// when the authenticating user has enabled two-factor authentication.
      /// 
      /// @param authenticationToken An authentication token returned by a previous
      ///   call to UserStore.authenticate or UserStore.authenticateLongSession that
      ///   could not be completed in a single call because a second factor was required.
      /// 
      /// @param oneTimeCode The one time code entered by the user. This value is delivered
      ///   out-of-band, typically via SMS or an authenticator application.
      /// 
      /// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
      /// 
      /// @param deviceDescription See the corresponding parameter in authenticateLongSession.
      /// 
      /// @return
      ///   The result of the authentication. The level of detail provided in the returned
      ///   AuthenticationResult.User structure depends on the access level granted by the
      ///   calling application's API key. If the initial authentication call was made to
      ///   authenticateLongSession, the AuthenticationResult will contain a long-lived
      ///   authentication token.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
      ///   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
      ///   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
      ///   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
      ///   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
      ///   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
      ///   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
      ///   <li> PERMISSION_DENIED "User.active" - user account is closed
      ///   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
      ///     failed authentication too often
      ///   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
      ///      two-factor authentication.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="oneTimeCode"></param>
      /// <param name="deviceIdentifier"></param>
      /// <param name="deviceDescription"></param>
      public AuthenticationResult completeTwoFactorAuthentication(string authenticationToken, string oneTimeCode, string deviceIdentifier, string deviceDescription)
      {
        #if !SILVERLIGHT
        send_completeTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
        return recv_completeTwoFactorAuthentication();

        #else
        var asyncResult = Begin_completeTwoFactorAuthentication(null, null, authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription);
        return End_completeTwoFactorAuthentication(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_completeTwoFactorAuthentication(AsyncCallback callback, object state, string authenticationToken, string oneTimeCode, string deviceIdentifier, string deviceDescription)
      #else
      public void send_completeTwoFactorAuthentication(string authenticationToken, string oneTimeCode, string deviceIdentifier, string deviceDescription)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("completeTwoFactorAuthentication", TMessageType.Call, seqid_));
        completeTwoFactorAuthentication_args args = new completeTwoFactorAuthentication_args();
        args.AuthenticationToken = authenticationToken;
        args.OneTimeCode = oneTimeCode;
        args.DeviceIdentifier = deviceIdentifier;
        args.DeviceDescription = deviceDescription;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public AuthenticationResult recv_completeTwoFactorAuthentication()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        completeTwoFactorAuthentication_result result = new completeTwoFactorAuthentication_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "completeTwoFactorAuthentication failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_revokeLongSession(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_revokeLongSession(callback, state, authenticationToken);
      }

      public void End_revokeLongSession(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_revokeLongSession();
      }

      #endif

      /// <summary>
      /// Revoke an existing long lived authentication token. This can be used to
      /// revoke OAuth tokens or tokens created by calling authenticateLongSession,
      /// and allows a user to effectively log out of Evernote from the perspective
      /// of the application that holds the token. The authentication token that is
      /// passed is immediately revoked and may not be used to call any authenticated
      /// EDAM function.
      /// 
      /// @param authenticationToken the authentication token to revoke.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
      ///   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
      ///   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
      ///   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
      ///     is already revoked.
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      public void revokeLongSession(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_revokeLongSession(authenticationToken);
        recv_revokeLongSession();

        #else
        var asyncResult = Begin_revokeLongSession(null, null, authenticationToken);
        End_revokeLongSession(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_revokeLongSession(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_revokeLongSession(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("revokeLongSession", TMessageType.Call, seqid_));
        revokeLongSession_args args = new revokeLongSession_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_revokeLongSession()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        revokeLongSession_result result = new revokeLongSession_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_authenticateToBusiness(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_authenticateToBusiness(callback, state, authenticationToken);
      }

      public AuthenticationResult End_authenticateToBusiness(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_authenticateToBusiness();
      }

      #endif

      /// <summary>
      /// This is used to take an existing authentication token that grants access
      /// to an individual user account (returned from 'authenticate',
      /// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
      /// authentication token that may be used to access business notebooks if the user
      /// is a member of an Evernote Business account.
      /// 
      /// The resulting authentication token may be used to make NoteStore API calls
      /// against the business using the NoteStore URL returned in the result.
      /// 
      /// @param authenticationToken
      ///   The authentication token for the user. This may not be a shared authentication
      ///   token (returned by NoteStore.authenticateToSharedNotebook or
      ///   NoteStore.authenticateToSharedNote) or a business authentication token.
      /// 
      /// @return
      ///   The result of the authentication, with the token granting access to the
      ///   business in the result's 'authenticationToken' field. The URL that must
      ///   be used to access the business account NoteStore will be returned in the
      ///   result's 'noteStoreUrl' field.  The 'User' field will
      ///   not be set in the result.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
      ///        is a shared or business authentication token. </li>
      ///   <li> PERMISSION_DENIED "Business" - the user identified by the provided
      ///        authentication token is not currently a member of a business. </li>
      ///   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
      ///        member of is not currently in an active status. </li>
      ///   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
      ///        sign-on before authenticating to the business.
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      public AuthenticationResult authenticateToBusiness(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_authenticateToBusiness(authenticationToken);
        return recv_authenticateToBusiness();

        #else
        var asyncResult = Begin_authenticateToBusiness(null, null, authenticationToken);
        return End_authenticateToBusiness(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_authenticateToBusiness(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_authenticateToBusiness(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("authenticateToBusiness", TMessageType.Call, seqid_));
        authenticateToBusiness_args args = new authenticateToBusiness_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public AuthenticationResult recv_authenticateToBusiness()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        authenticateToBusiness_result result = new authenticateToBusiness_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "authenticateToBusiness failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getUser(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_getUser(callback, state, authenticationToken);
      }

      public Evernote.EDAM.Type.User End_getUser(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getUser();
      }

      #endif

      /// <summary>
      /// Returns the User corresponding to the provided authentication token,
      /// or throws an exception if this token is not valid.
      /// The level of detail provided in the returned User structure depends on
      /// the access level granted by the token, so a web service client may receive
      /// fewer fields than an integrated desktop client.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public Evernote.EDAM.Type.User getUser(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_getUser(authenticationToken);
        return recv_getUser();

        #else
        var asyncResult = Begin_getUser(null, null, authenticationToken);
        return End_getUser(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getUser(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_getUser(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getUser", TMessageType.Call, seqid_));
        getUser_args args = new getUser_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.User recv_getUser()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getUser_result result = new getUser_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getUser failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getPublicUserInfo(AsyncCallback callback, object state, string username)
      {
        return send_getPublicUserInfo(callback, state, username);
      }

      public PublicUserInfo End_getPublicUserInfo(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getPublicUserInfo();
      }

      #endif

      /// <summary>
      /// Asks the UserStore about the publicly available location information for
      /// a particular username.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "username" - username is empty
      /// </ul>
      /// </summary>
      /// <param name="username"></param>
      public PublicUserInfo getPublicUserInfo(string username)
      {
        #if !SILVERLIGHT
        send_getPublicUserInfo(username);
        return recv_getPublicUserInfo();

        #else
        var asyncResult = Begin_getPublicUserInfo(null, null, username);
        return End_getPublicUserInfo(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getPublicUserInfo(AsyncCallback callback, object state, string username)
      #else
      public void send_getPublicUserInfo(string username)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getPublicUserInfo", TMessageType.Call, seqid_));
        getPublicUserInfo_args args = new getPublicUserInfo_args();
        args.Username = username;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public PublicUserInfo recv_getPublicUserInfo()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getPublicUserInfo_result result = new getPublicUserInfo_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getPublicUserInfo failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getUserUrls(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_getUserUrls(callback, state, authenticationToken);
      }

      public UserUrls End_getUserUrls(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getUserUrls();
      }

      #endif

      /// <summary>
      /// <p>Returns the URLs that should be used when sending requests to the service on
      /// behalf of the account represented by the provided authenticationToken.</p>
      /// 
      /// <p>This method isn't needed by most clients, who can retreive the correct set of
      /// UserUrls from the AuthenticationResult returned from
      /// UserStore#authenticateLongSession(). This method is typically only needed to look up
      /// the correct URLs for an existing long-lived authentication token.</p>
      /// </summary>
      /// <param name="authenticationToken"></param>
      public UserUrls getUserUrls(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_getUserUrls(authenticationToken);
        return recv_getUserUrls();

        #else
        var asyncResult = Begin_getUserUrls(null, null, authenticationToken);
        return End_getUserUrls(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getUserUrls(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_getUserUrls(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getUserUrls", TMessageType.Call, seqid_));
        getUserUrls_args args = new getUserUrls_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public UserUrls recv_getUserUrls()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getUserUrls_result result = new getUserUrls_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getUserUrls failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_inviteToBusiness(AsyncCallback callback, object state, string authenticationToken, string emailAddress)
      {
        return send_inviteToBusiness(callback, state, authenticationToken, emailAddress);
      }

      public void End_inviteToBusiness(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_inviteToBusiness();
      }

      #endif

      /// <summary>
      /// Invite a user to join an Evernote Business account.
      /// 
      /// Behavior will depend on the auth token. <ol>
      ///   <li>
      ///     auth token with privileges to manage Evernote Business membership.
      ///       "External Provisioning" - The user will receive an email inviting
      ///       them to join the business. They do not need to have an existing Evernote
      ///       account. If the user has already been invited, a new invitation email
      ///       will be sent.
      ///   </li>
      ///   <li>
      ///     business auth token issued to an admin user. Only for first-party clients:
      ///       "Approve Invitation" - If there has been a request to invite the email,
      ///       approve it. Invited user will receive email with a link to join business.
      ///       "Invite User" - If no invitation for the email exists, create an approved
      ///       invitation for the email. An email will be sent to the emailAddress with
      ///       a link to join the caller's business.
      ///   </li>
      ///   </li>
      ///     business auth token:
      ///       "Request Invitation" - If no invitation exists, create a request to
      ///       invite the user to the business. These requests do not count towards a
      ///       business' max active user limit.
      ///   </li>
      /// </ol>
      /// 
      /// @param authenticationToken
      ///   the authentication token with sufficient privileges to manage Evernote Business
      ///   membership or a business auth token.
      /// 
      /// @param emailAddress
      ///   the email address of the user to invite to join the Evernote Business account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
      ///   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
      ///   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
      ///     whose business email address matches the specified email address. </li>
      ///   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
      ///     user limit. </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="emailAddress"></param>
      public void inviteToBusiness(string authenticationToken, string emailAddress)
      {
        #if !SILVERLIGHT
        send_inviteToBusiness(authenticationToken, emailAddress);
        recv_inviteToBusiness();

        #else
        var asyncResult = Begin_inviteToBusiness(null, null, authenticationToken, emailAddress);
        End_inviteToBusiness(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_inviteToBusiness(AsyncCallback callback, object state, string authenticationToken, string emailAddress)
      #else
      public void send_inviteToBusiness(string authenticationToken, string emailAddress)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("inviteToBusiness", TMessageType.Call, seqid_));
        inviteToBusiness_args args = new inviteToBusiness_args();
        args.AuthenticationToken = authenticationToken;
        args.EmailAddress = emailAddress;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_inviteToBusiness()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        inviteToBusiness_result result = new inviteToBusiness_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_removeFromBusiness(AsyncCallback callback, object state, string authenticationToken, string emailAddress)
      {
        return send_removeFromBusiness(callback, state, authenticationToken, emailAddress);
      }

      public void End_removeFromBusiness(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_removeFromBusiness();
      }

      #endif

      /// <summary>
      /// Remove a user from an Evernote Business account. Once removed, the user will no
      /// longer be able to access content within the Evernote Business account.
      /// 
      /// <p>The email address of the user to remove from the business must match the email
      /// address used to invite a user to join the business via UserStore.inviteToBusiness.
      /// This function will only remove users who were invited by external provisioning</p>
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business
      ///   membership.
      /// 
      /// @param emailAddress
      ///   The email address of the user to remove from the Evernote Business account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "email" - if no email address was provided </li>
      ///   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "email" - If there is no user with the specified email address in the
      ///     business or that user was not invited via external provisioning. </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="emailAddress"></param>
      public void removeFromBusiness(string authenticationToken, string emailAddress)
      {
        #if !SILVERLIGHT
        send_removeFromBusiness(authenticationToken, emailAddress);
        recv_removeFromBusiness();

        #else
        var asyncResult = Begin_removeFromBusiness(null, null, authenticationToken, emailAddress);
        End_removeFromBusiness(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_removeFromBusiness(AsyncCallback callback, object state, string authenticationToken, string emailAddress)
      #else
      public void send_removeFromBusiness(string authenticationToken, string emailAddress)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("removeFromBusiness", TMessageType.Call, seqid_));
        removeFromBusiness_args args = new removeFromBusiness_args();
        args.AuthenticationToken = authenticationToken;
        args.EmailAddress = emailAddress;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_removeFromBusiness()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        removeFromBusiness_result result = new removeFromBusiness_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateBusinessUserIdentifier(AsyncCallback callback, object state, string authenticationToken, string oldEmailAddress, string newEmailAddress)
      {
        return send_updateBusinessUserIdentifier(callback, state, authenticationToken, oldEmailAddress, newEmailAddress);
      }

      public void End_updateBusinessUserIdentifier(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_updateBusinessUserIdentifier();
      }

      #endif

      /// <summary>
      /// Update the email address used to uniquely identify an Evernote Business user.
      /// 
      /// This will update the identifier for a user who was previously invited using
      /// inviteToBusiness, ensuring that caller and the Evernote service maintain an
      /// agreed-upon identifier for a specific user.
      /// 
      /// For example, the following sequence of calls would invite a user to join
      /// a business, update their email address, and then remove the user
      /// from the business using the updated email address.
      /// 
      /// inviteToBusiness("foo@bar.com")
      /// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
      /// removeFromBusiness("baz@bar.com")
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business
      ///   membership.
      /// 
      /// @param oldEmailAddress
      ///   The existing email address used to uniquely identify the user.
      /// 
      /// @param newEmailAddress
      ///   The new email address used to uniquely identify the user.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
      ///   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
      ///   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
      ///   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
      ///   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
      ///   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
      ///     the provided new email address.</li>
      ///   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
      ///     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
      ///     updated.</li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
      ///     in the business.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="oldEmailAddress"></param>
      /// <param name="newEmailAddress"></param>
      public void updateBusinessUserIdentifier(string authenticationToken, string oldEmailAddress, string newEmailAddress)
      {
        #if !SILVERLIGHT
        send_updateBusinessUserIdentifier(authenticationToken, oldEmailAddress, newEmailAddress);
        recv_updateBusinessUserIdentifier();

        #else
        var asyncResult = Begin_updateBusinessUserIdentifier(null, null, authenticationToken, oldEmailAddress, newEmailAddress);
        End_updateBusinessUserIdentifier(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateBusinessUserIdentifier(AsyncCallback callback, object state, string authenticationToken, string oldEmailAddress, string newEmailAddress)
      #else
      public void send_updateBusinessUserIdentifier(string authenticationToken, string oldEmailAddress, string newEmailAddress)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateBusinessUserIdentifier", TMessageType.Call, seqid_));
        updateBusinessUserIdentifier_args args = new updateBusinessUserIdentifier_args();
        args.AuthenticationToken = authenticationToken;
        args.OldEmailAddress = oldEmailAddress;
        args.NewEmailAddress = newEmailAddress;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_updateBusinessUserIdentifier()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateBusinessUserIdentifier_result result = new updateBusinessUserIdentifier_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listBusinessUsers(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listBusinessUsers(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.UserProfile> End_listBusinessUsers(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listBusinessUsers();
      }

      #endif

      /// <summary>
      /// Returns a list of active business users in a given business.
      /// 
      /// Clients are required to cache this information and re-fetch no more than once per day
      /// or when they encountered a user ID or username that was not known to them.
      /// 
      /// To avoid excessive look ups, clients should also track user IDs and usernames that belong
      /// to users who are not in the business, since they will not be included in the result.
      /// 
      /// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
      /// listBusinessUsers to find information about this user. If the user is not in the resulting
      /// list, the client should track that fact and not re-query the service the next time that it sees
      /// this user on a note.
      /// 
      /// @param authenticationToken
      ///   A business authentication token returned by authenticateToBusiness or with sufficient
      ///   privileges to manage Evernote Business membership.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.UserProfile> listBusinessUsers(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listBusinessUsers(authenticationToken);
        return recv_listBusinessUsers();

        #else
        var asyncResult = Begin_listBusinessUsers(null, null, authenticationToken);
        return End_listBusinessUsers(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listBusinessUsers(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listBusinessUsers(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listBusinessUsers", TMessageType.Call, seqid_));
        listBusinessUsers_args args = new listBusinessUsers_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.UserProfile> recv_listBusinessUsers()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listBusinessUsers_result result = new listBusinessUsers_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listBusinessUsers failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listBusinessInvitations(AsyncCallback callback, object state, string authenticationToken, bool includeRequestedInvitations)
      {
        return send_listBusinessInvitations(callback, state, authenticationToken, includeRequestedInvitations);
      }

      public List<Evernote.EDAM.Type.BusinessInvitation> End_listBusinessInvitations(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listBusinessInvitations();
      }

      #endif

      /// <summary>
      /// Returns a list of outstanding invitations to join an Evernote Business account.
      /// 
      /// Only outstanding invitations are returned by this function. Users who have accepted an
      /// invitation and joined a business are listed using listBusinessUsers.
      /// 
      /// @param authenticationToken
      ///   An authentication token with sufficient privileges to manage Evernote Business membership.
      /// 
      /// @param includeRequestedInvitations
      ///   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
      ///   in the returned list. If false, only invitations with a status of
      ///   BusinessInvitationStatus.APPROVED will be included.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="includeRequestedInvitations"></param>
      public List<Evernote.EDAM.Type.BusinessInvitation> listBusinessInvitations(string authenticationToken, bool includeRequestedInvitations)
      {
        #if !SILVERLIGHT
        send_listBusinessInvitations(authenticationToken, includeRequestedInvitations);
        return recv_listBusinessInvitations();

        #else
        var asyncResult = Begin_listBusinessInvitations(null, null, authenticationToken, includeRequestedInvitations);
        return End_listBusinessInvitations(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listBusinessInvitations(AsyncCallback callback, object state, string authenticationToken, bool includeRequestedInvitations)
      #else
      public void send_listBusinessInvitations(string authenticationToken, bool includeRequestedInvitations)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listBusinessInvitations", TMessageType.Call, seqid_));
        listBusinessInvitations_args args = new listBusinessInvitations_args();
        args.AuthenticationToken = authenticationToken;
        args.IncludeRequestedInvitations = includeRequestedInvitations;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.BusinessInvitation> recv_listBusinessInvitations()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listBusinessInvitations_result result = new listBusinessInvitations_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listBusinessInvitations failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getAccountLimits(AsyncCallback callback, object state, Evernote.EDAM.Type.ServiceLevel serviceLevel)
      {
        return send_getAccountLimits(callback, state, serviceLevel);
      }

      public Evernote.EDAM.Type.AccountLimits End_getAccountLimits(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getAccountLimits();
      }

      #endif

      /// <summary>
      /// Retrieve the standard account limits for a given service level. This should only be
      /// called when necessary, e.g. to determine if a higher level is available should the
      /// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
      /// not expected to fluctuate frequently.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
      /// </ul>
      /// </summary>
      /// <param name="serviceLevel"></param>
      public Evernote.EDAM.Type.AccountLimits getAccountLimits(Evernote.EDAM.Type.ServiceLevel serviceLevel)
      {
        #if !SILVERLIGHT
        send_getAccountLimits(serviceLevel);
        return recv_getAccountLimits();

        #else
        var asyncResult = Begin_getAccountLimits(null, null, serviceLevel);
        return End_getAccountLimits(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getAccountLimits(AsyncCallback callback, object state, Evernote.EDAM.Type.ServiceLevel serviceLevel)
      #else
      public void send_getAccountLimits(Evernote.EDAM.Type.ServiceLevel serviceLevel)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getAccountLimits", TMessageType.Call, seqid_));
        getAccountLimits_args args = new getAccountLimits_args();
        args.ServiceLevel = serviceLevel;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.AccountLimits recv_getAccountLimits()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getAccountLimits_result result = new getAccountLimits_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getAccountLimits failed: unknown result");
      }

    }
    public class Processor : TProcessor {
      public Processor(ISync iface)
      {
        iface_ = iface;
        processMap_["checkVersion"] = checkVersion_Process;
        processMap_["getBootstrapInfo"] = getBootstrapInfo_Process;
        processMap_["authenticateLongSession"] = authenticateLongSession_Process;
        processMap_["completeTwoFactorAuthentication"] = completeTwoFactorAuthentication_Process;
        processMap_["revokeLongSession"] = revokeLongSession_Process;
        processMap_["authenticateToBusiness"] = authenticateToBusiness_Process;
        processMap_["getUser"] = getUser_Process;
        processMap_["getPublicUserInfo"] = getPublicUserInfo_Process;
        processMap_["getUserUrls"] = getUserUrls_Process;
        processMap_["inviteToBusiness"] = inviteToBusiness_Process;
        processMap_["removeFromBusiness"] = removeFromBusiness_Process;
        processMap_["updateBusinessUserIdentifier"] = updateBusinessUserIdentifier_Process;
        processMap_["listBusinessUsers"] = listBusinessUsers_Process;
        processMap_["listBusinessInvitations"] = listBusinessInvitations_Process;
        processMap_["getAccountLimits"] = getAccountLimits_Process;
      }

      protected delegate void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private ISync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public bool Process(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public void checkVersion_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        checkVersion_args args = new checkVersion_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        checkVersion_result result = new checkVersion_result();
        try
        {
          result.Success = iface_.checkVersion(args.ClientName, args.EdamVersionMajor, args.EdamVersionMinor);
          oprot.WriteMessageBegin(new TMessage("checkVersion", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("checkVersion", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getBootstrapInfo_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getBootstrapInfo_args args = new getBootstrapInfo_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getBootstrapInfo_result result = new getBootstrapInfo_result();
        try
        {
          result.Success = iface_.getBootstrapInfo(args.Locale);
          oprot.WriteMessageBegin(new TMessage("getBootstrapInfo", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getBootstrapInfo", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void authenticateLongSession_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        authenticateLongSession_args args = new authenticateLongSession_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        authenticateLongSession_result result = new authenticateLongSession_result();
        try
        {
          try
          {
            result.Success = iface_.authenticateLongSession(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.DeviceIdentifier, args.DeviceDescription, args.SupportsTwoFactor);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("authenticateLongSession", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("authenticateLongSession", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void completeTwoFactorAuthentication_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        completeTwoFactorAuthentication_args args = new completeTwoFactorAuthentication_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        completeTwoFactorAuthentication_result result = new completeTwoFactorAuthentication_result();
        try
        {
          try
          {
            result.Success = iface_.completeTwoFactorAuthentication(args.AuthenticationToken, args.OneTimeCode, args.DeviceIdentifier, args.DeviceDescription);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("completeTwoFactorAuthentication", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("completeTwoFactorAuthentication", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void revokeLongSession_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        revokeLongSession_args args = new revokeLongSession_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        revokeLongSession_result result = new revokeLongSession_result();
        try
        {
          try
          {
            iface_.revokeLongSession(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("revokeLongSession", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("revokeLongSession", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void authenticateToBusiness_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        authenticateToBusiness_args args = new authenticateToBusiness_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        authenticateToBusiness_result result = new authenticateToBusiness_result();
        try
        {
          try
          {
            result.Success = iface_.authenticateToBusiness(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("authenticateToBusiness", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("authenticateToBusiness", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getUser_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getUser_args args = new getUser_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getUser_result result = new getUser_result();
        try
        {
          try
          {
            result.Success = iface_.getUser(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getUser", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getUser", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getPublicUserInfo_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getPublicUserInfo_args args = new getPublicUserInfo_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getPublicUserInfo_result result = new getPublicUserInfo_result();
        try
        {
          try
          {
            result.Success = iface_.getPublicUserInfo(args.Username);
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          oprot.WriteMessageBegin(new TMessage("getPublicUserInfo", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getPublicUserInfo", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getUserUrls_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getUserUrls_args args = new getUserUrls_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getUserUrls_result result = new getUserUrls_result();
        try
        {
          try
          {
            result.Success = iface_.getUserUrls(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getUserUrls", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getUserUrls", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void inviteToBusiness_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        inviteToBusiness_args args = new inviteToBusiness_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        inviteToBusiness_result result = new inviteToBusiness_result();
        try
        {
          try
          {
            iface_.inviteToBusiness(args.AuthenticationToken, args.EmailAddress);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("inviteToBusiness", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("inviteToBusiness", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void removeFromBusiness_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        removeFromBusiness_args args = new removeFromBusiness_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        removeFromBusiness_result result = new removeFromBusiness_result();
        try
        {
          try
          {
            iface_.removeFromBusiness(args.AuthenticationToken, args.EmailAddress);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("removeFromBusiness", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("removeFromBusiness", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateBusinessUserIdentifier_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateBusinessUserIdentifier_args args = new updateBusinessUserIdentifier_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateBusinessUserIdentifier_result result = new updateBusinessUserIdentifier_result();
        try
        {
          try
          {
            iface_.updateBusinessUserIdentifier(args.AuthenticationToken, args.OldEmailAddress, args.NewEmailAddress);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("updateBusinessUserIdentifier", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateBusinessUserIdentifier", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listBusinessUsers_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listBusinessUsers_args args = new listBusinessUsers_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listBusinessUsers_result result = new listBusinessUsers_result();
        try
        {
          try
          {
            result.Success = iface_.listBusinessUsers(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listBusinessUsers", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listBusinessUsers", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listBusinessInvitations_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listBusinessInvitations_args args = new listBusinessInvitations_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listBusinessInvitations_result result = new listBusinessInvitations_result();
        try
        {
          try
          {
            result.Success = iface_.listBusinessInvitations(args.AuthenticationToken, args.IncludeRequestedInvitations);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listBusinessInvitations", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listBusinessInvitations", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getAccountLimits_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getAccountLimits_args args = new getAccountLimits_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getAccountLimits_result result = new getAccountLimits_result();
        try
        {
          try
          {
            result.Success = iface_.getAccountLimits(args.ServiceLevel);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          oprot.WriteMessageBegin(new TMessage("getAccountLimits", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getAccountLimits", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkVersion_args : TBase
    {
      private string _clientName;
      private short _edamVersionMajor;
      private short _edamVersionMinor;

      public string ClientName
      {
        get
        {
          return _clientName;
        }
        set
        {
          __isset.clientName = true;
          this._clientName = value;
        }
      }

      public short EdamVersionMajor
      {
        get
        {
          return _edamVersionMajor;
        }
        set
        {
          __isset.edamVersionMajor = true;
          this._edamVersionMajor = value;
        }
      }

      public short EdamVersionMinor
      {
        get
        {
          return _edamVersionMinor;
        }
        set
        {
          __isset.edamVersionMinor = true;
          this._edamVersionMinor = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool clientName;
        public bool edamVersionMajor;
        public bool edamVersionMinor;
      }

      public checkVersion_args() {
        this._edamVersionMajor = 1;
        this.__isset.edamVersionMajor = true;
        this._edamVersionMinor = 28;
        this.__isset.edamVersionMinor = true;
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  ClientName = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I16) {
                  EdamVersionMajor = iprot.ReadI16();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I16) {
                  EdamVersionMinor = iprot.ReadI16();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkVersion_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (ClientName != null && __isset.clientName) {
            field.Name = "clientName";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(ClientName);
            oprot.WriteFieldEnd();
          }
          if (__isset.edamVersionMajor) {
            field.Name = "edamVersionMajor";
            field.Type = TType.I16;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteI16(EdamVersionMajor);
            oprot.WriteFieldEnd();
          }
          if (__isset.edamVersionMinor) {
            field.Name = "edamVersionMinor";
            field.Type = TType.I16;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI16(EdamVersionMinor);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkVersion_args(");
        bool __first = true;
        if (ClientName != null && __isset.clientName) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ClientName: ");
          __sb.Append(ClientName);
        }
        if (__isset.edamVersionMajor) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("EdamVersionMajor: ");
          __sb.Append(EdamVersionMajor);
        }
        if (__isset.edamVersionMinor) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("EdamVersionMinor: ");
          __sb.Append(EdamVersionMinor);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class checkVersion_result : TBase
    {
      private bool _success;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public checkVersion_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("checkVersion_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("checkVersion_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getBootstrapInfo_args : TBase
    {
      private string _locale;

      public string Locale
      {
        get
        {
          return _locale;
        }
        set
        {
          __isset.locale = true;
          this._locale = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool locale;
      }

      public getBootstrapInfo_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Locale = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getBootstrapInfo_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Locale != null && __isset.locale) {
            field.Name = "locale";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Locale);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getBootstrapInfo_args(");
        bool __first = true;
        if (Locale != null && __isset.locale) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Locale: ");
          __sb.Append(Locale);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getBootstrapInfo_result : TBase
    {
      private BootstrapInfo _success;

      public BootstrapInfo Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public getBootstrapInfo_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new BootstrapInfo();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getBootstrapInfo_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getBootstrapInfo_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateLongSession_args : TBase
    {
      private string _username;
      private string _password;
      private string _consumerKey;
      private string _consumerSecret;
      private string _deviceIdentifier;
      private string _deviceDescription;
      private bool _supportsTwoFactor;

      public string Username
      {
        get
        {
          return _username;
        }
        set
        {
          __isset.username = true;
          this._username = value;
        }
      }

      public string Password
      {
        get
        {
          return _password;
        }
        set
        {
          __isset.password = true;
          this._password = value;
        }
      }

      public string ConsumerKey
      {
        get
        {
          return _consumerKey;
        }
        set
        {
          __isset.consumerKey = true;
          this._consumerKey = value;
        }
      }

      public string ConsumerSecret
      {
        get
        {
          return _consumerSecret;
        }
        set
        {
          __isset.consumerSecret = true;
          this._consumerSecret = value;
        }
      }

      public string DeviceIdentifier
      {
        get
        {
          return _deviceIdentifier;
        }
        set
        {
          __isset.deviceIdentifier = true;
          this._deviceIdentifier = value;
        }
      }

      public string DeviceDescription
      {
        get
        {
          return _deviceDescription;
        }
        set
        {
          __isset.deviceDescription = true;
          this._deviceDescription = value;
        }
      }

      public bool SupportsTwoFactor
      {
        get
        {
          return _supportsTwoFactor;
        }
        set
        {
          __isset.supportsTwoFactor = true;
          this._supportsTwoFactor = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool username;
        public bool password;
        public bool consumerKey;
        public bool consumerSecret;
        public bool deviceIdentifier;
        public bool deviceDescription;
        public bool supportsTwoFactor;
      }

      public authenticateLongSession_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Username = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Password = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  ConsumerKey = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  ConsumerSecret = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.String) {
                  DeviceIdentifier = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.String) {
                  DeviceDescription = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 7:
                if (field.Type == TType.Bool) {
                  SupportsTwoFactor = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateLongSession_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Username != null && __isset.username) {
            field.Name = "username";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Username);
            oprot.WriteFieldEnd();
          }
          if (Password != null && __isset.password) {
            field.Name = "password";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Password);
            oprot.WriteFieldEnd();
          }
          if (ConsumerKey != null && __isset.consumerKey) {
            field.Name = "consumerKey";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(ConsumerKey);
            oprot.WriteFieldEnd();
          }
          if (ConsumerSecret != null && __isset.consumerSecret) {
            field.Name = "consumerSecret";
            field.Type = TType.String;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(ConsumerSecret);
            oprot.WriteFieldEnd();
          }
          if (DeviceIdentifier != null && __isset.deviceIdentifier) {
            field.Name = "deviceIdentifier";
            field.Type = TType.String;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(DeviceIdentifier);
            oprot.WriteFieldEnd();
          }
          if (DeviceDescription != null && __isset.deviceDescription) {
            field.Name = "deviceDescription";
            field.Type = TType.String;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(DeviceDescription);
            oprot.WriteFieldEnd();
          }
          if (__isset.supportsTwoFactor) {
            field.Name = "supportsTwoFactor";
            field.Type = TType.Bool;
            field.ID = 7;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(SupportsTwoFactor);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateLongSession_args(");
        bool __first = true;
        if (Username != null && __isset.username) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Username: ");
          __sb.Append(Username);
        }
        if (Password != null && __isset.password) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Password: ");
          __sb.Append(Password);
        }
        if (ConsumerKey != null && __isset.consumerKey) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ConsumerKey: ");
          __sb.Append(ConsumerKey);
        }
        if (ConsumerSecret != null && __isset.consumerSecret) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ConsumerSecret: ");
          __sb.Append(ConsumerSecret);
        }
        if (DeviceIdentifier != null && __isset.deviceIdentifier) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("DeviceIdentifier: ");
          __sb.Append(DeviceIdentifier);
        }
        if (DeviceDescription != null && __isset.deviceDescription) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("DeviceDescription: ");
          __sb.Append(DeviceDescription);
        }
        if (__isset.supportsTwoFactor) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SupportsTwoFactor: ");
          __sb.Append(SupportsTwoFactor);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateLongSession_result : TBase
    {
      private AuthenticationResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public AuthenticationResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public authenticateLongSession_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new AuthenticationResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateLongSession_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateLongSession_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class completeTwoFactorAuthentication_args : TBase
    {
      private string _authenticationToken;
      private string _oneTimeCode;
      private string _deviceIdentifier;
      private string _deviceDescription;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string OneTimeCode
      {
        get
        {
          return _oneTimeCode;
        }
        set
        {
          __isset.oneTimeCode = true;
          this._oneTimeCode = value;
        }
      }

      public string DeviceIdentifier
      {
        get
        {
          return _deviceIdentifier;
        }
        set
        {
          __isset.deviceIdentifier = true;
          this._deviceIdentifier = value;
        }
      }

      public string DeviceDescription
      {
        get
        {
          return _deviceDescription;
        }
        set
        {
          __isset.deviceDescription = true;
          this._deviceDescription = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool oneTimeCode;
        public bool deviceIdentifier;
        public bool deviceDescription;
      }

      public completeTwoFactorAuthentication_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  OneTimeCode = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  DeviceIdentifier = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  DeviceDescription = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("completeTwoFactorAuthentication_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (OneTimeCode != null && __isset.oneTimeCode) {
            field.Name = "oneTimeCode";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(OneTimeCode);
            oprot.WriteFieldEnd();
          }
          if (DeviceIdentifier != null && __isset.deviceIdentifier) {
            field.Name = "deviceIdentifier";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(DeviceIdentifier);
            oprot.WriteFieldEnd();
          }
          if (DeviceDescription != null && __isset.deviceDescription) {
            field.Name = "deviceDescription";
            field.Type = TType.String;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(DeviceDescription);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("completeTwoFactorAuthentication_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (OneTimeCode != null && __isset.oneTimeCode) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("OneTimeCode: ");
          __sb.Append(OneTimeCode);
        }
        if (DeviceIdentifier != null && __isset.deviceIdentifier) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("DeviceIdentifier: ");
          __sb.Append(DeviceIdentifier);
        }
        if (DeviceDescription != null && __isset.deviceDescription) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("DeviceDescription: ");
          __sb.Append(DeviceDescription);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class completeTwoFactorAuthentication_result : TBase
    {
      private AuthenticationResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public AuthenticationResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public completeTwoFactorAuthentication_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new AuthenticationResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("completeTwoFactorAuthentication_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("completeTwoFactorAuthentication_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class revokeLongSession_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public revokeLongSession_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("revokeLongSession_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("revokeLongSession_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class revokeLongSession_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool systemException;
      }

      public revokeLongSession_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("revokeLongSession_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("revokeLongSession_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateToBusiness_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public authenticateToBusiness_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateToBusiness_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateToBusiness_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateToBusiness_result : TBase
    {
      private AuthenticationResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public AuthenticationResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public authenticateToBusiness_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new AuthenticationResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateToBusiness_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateToBusiness_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getUser_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public getUser_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getUser_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getUser_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getUser_result : TBase
    {
      private Evernote.EDAM.Type.User _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.User Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public getUser_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.User();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getUser_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getUser_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getPublicUserInfo_args : TBase
    {
      private string _username;

      public string Username
      {
        get
        {
          return _username;
        }
        set
        {
          __isset.username = true;
          this._username = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool username;
      }

      public getPublicUserInfo_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Username = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getPublicUserInfo_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Username != null && __isset.username) {
            field.Name = "username";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Username);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getPublicUserInfo_args(");
        bool __first = true;
        if (Username != null && __isset.username) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Username: ");
          __sb.Append(Username);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getPublicUserInfo_result : TBase
    {
      private PublicUserInfo _success;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMUserException _userException;

      public PublicUserInfo Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool notFoundException;
        public bool systemException;
        public bool userException;
      }

      public getPublicUserInfo_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new PublicUserInfo();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getPublicUserInfo_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getPublicUserInfo_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getUserUrls_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public getUserUrls_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getUserUrls_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getUserUrls_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getUserUrls_result : TBase
    {
      private UserUrls _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public UserUrls Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public getUserUrls_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new UserUrls();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getUserUrls_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getUserUrls_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class inviteToBusiness_args : TBase
    {
      private string _authenticationToken;
      private string _emailAddress;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string EmailAddress
      {
        get
        {
          return _emailAddress;
        }
        set
        {
          __isset.emailAddress = true;
          this._emailAddress = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool emailAddress;
      }

      public inviteToBusiness_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  EmailAddress = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("inviteToBusiness_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (EmailAddress != null && __isset.emailAddress) {
            field.Name = "emailAddress";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(EmailAddress);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("inviteToBusiness_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (EmailAddress != null && __isset.emailAddress) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("EmailAddress: ");
          __sb.Append(EmailAddress);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class inviteToBusiness_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool systemException;
      }

      public inviteToBusiness_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("inviteToBusiness_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("inviteToBusiness_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class removeFromBusiness_args : TBase
    {
      private string _authenticationToken;
      private string _emailAddress;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string EmailAddress
      {
        get
        {
          return _emailAddress;
        }
        set
        {
          __isset.emailAddress = true;
          this._emailAddress = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool emailAddress;
      }

      public removeFromBusiness_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  EmailAddress = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("removeFromBusiness_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (EmailAddress != null && __isset.emailAddress) {
            field.Name = "emailAddress";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(EmailAddress);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("removeFromBusiness_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (EmailAddress != null && __isset.emailAddress) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("EmailAddress: ");
          __sb.Append(EmailAddress);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class removeFromBusiness_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public removeFromBusiness_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("removeFromBusiness_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("removeFromBusiness_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateBusinessUserIdentifier_args : TBase
    {
      private string _authenticationToken;
      private string _oldEmailAddress;
      private string _newEmailAddress;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string OldEmailAddress
      {
        get
        {
          return _oldEmailAddress;
        }
        set
        {
          __isset.oldEmailAddress = true;
          this._oldEmailAddress = value;
        }
      }

      public string NewEmailAddress
      {
        get
        {
          return _newEmailAddress;
        }
        set
        {
          __isset.newEmailAddress = true;
          this._newEmailAddress = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool oldEmailAddress;
        public bool newEmailAddress;
      }

      public updateBusinessUserIdentifier_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  OldEmailAddress = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  NewEmailAddress = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateBusinessUserIdentifier_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (OldEmailAddress != null && __isset.oldEmailAddress) {
            field.Name = "oldEmailAddress";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(OldEmailAddress);
            oprot.WriteFieldEnd();
          }
          if (NewEmailAddress != null && __isset.newEmailAddress) {
            field.Name = "newEmailAddress";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NewEmailAddress);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateBusinessUserIdentifier_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (OldEmailAddress != null && __isset.oldEmailAddress) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("OldEmailAddress: ");
          __sb.Append(OldEmailAddress);
        }
        if (NewEmailAddress != null && __isset.newEmailAddress) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NewEmailAddress: ");
          __sb.Append(NewEmailAddress);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateBusinessUserIdentifier_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public updateBusinessUserIdentifier_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateBusinessUserIdentifier_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateBusinessUserIdentifier_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listBusinessUsers_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listBusinessUsers_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listBusinessUsers_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listBusinessUsers_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listBusinessUsers_result : TBase
    {
      private List<Evernote.EDAM.Type.UserProfile> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.UserProfile> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public listBusinessUsers_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.UserProfile>();
                    TList _list4 = iprot.ReadListBegin();
                    for( int _i5 = 0; _i5 < _list4.Count; ++_i5)
                    {
                      Evernote.EDAM.Type.UserProfile _elem6;
                      _elem6 = new Evernote.EDAM.Type.UserProfile();
                      _elem6.Read(iprot);
                      Success.Add(_elem6);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listBusinessUsers_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.UserProfile _iter7 in Success)
                {
                  _iter7.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listBusinessUsers_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listBusinessInvitations_args : TBase
    {
      private string _authenticationToken;
      private bool _includeRequestedInvitations;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public bool IncludeRequestedInvitations
      {
        get
        {
          return _includeRequestedInvitations;
        }
        set
        {
          __isset.includeRequestedInvitations = true;
          this._includeRequestedInvitations = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool includeRequestedInvitations;
      }

      public listBusinessInvitations_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Bool) {
                  IncludeRequestedInvitations = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listBusinessInvitations_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (__isset.includeRequestedInvitations) {
            field.Name = "includeRequestedInvitations";
            field.Type = TType.Bool;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(IncludeRequestedInvitations);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listBusinessInvitations_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (__isset.includeRequestedInvitations) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("IncludeRequestedInvitations: ");
          __sb.Append(IncludeRequestedInvitations);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listBusinessInvitations_result : TBase
    {
      private List<Evernote.EDAM.Type.BusinessInvitation> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.BusinessInvitation> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public listBusinessInvitations_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.BusinessInvitation>();
                    TList _list8 = iprot.ReadListBegin();
                    for( int _i9 = 0; _i9 < _list8.Count; ++_i9)
                    {
                      Evernote.EDAM.Type.BusinessInvitation _elem10;
                      _elem10 = new Evernote.EDAM.Type.BusinessInvitation();
                      _elem10.Read(iprot);
                      Success.Add(_elem10);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listBusinessInvitations_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.BusinessInvitation _iter11 in Success)
                {
                  _iter11.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listBusinessInvitations_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getAccountLimits_args : TBase
    {
      private Evernote.EDAM.Type.ServiceLevel _serviceLevel;

      /// <summary>
      /// 
      /// <seealso cref="Evernote.EDAM.Type.ServiceLevel"/>
      /// </summary>
      public Evernote.EDAM.Type.ServiceLevel ServiceLevel
      {
        get
        {
          return _serviceLevel;
        }
        set
        {
          __isset.serviceLevel = true;
          this._serviceLevel = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool serviceLevel;
      }

      public getAccountLimits_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  ServiceLevel = (Evernote.EDAM.Type.ServiceLevel)iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getAccountLimits_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (__isset.serviceLevel) {
            field.Name = "serviceLevel";
            field.Type = TType.I32;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32((int)ServiceLevel);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getAccountLimits_args(");
        bool __first = true;
        if (__isset.serviceLevel) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ServiceLevel: ");
          __sb.Append(ServiceLevel);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getAccountLimits_result : TBase
    {
      private Evernote.EDAM.Type.AccountLimits _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;

      public Evernote.EDAM.Type.AccountLimits Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
      }

      public getAccountLimits_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.AccountLimits();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getAccountLimits_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getAccountLimits_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }

  }
}
