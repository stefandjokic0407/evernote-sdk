/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.Type
{

  /// <summary>
  /// The list of optional attributes that can be stored on a note.
  /// <dl>
  /// <dt>subjectDate</dt>
  ///   <dd>time that the note refers to
  ///   </dd>
  /// 
  /// <dt>latitude</dt>
  ///   <dd>the latitude where the note was taken
  ///   </dd>
  /// 
  /// <dt>longitude</dt>
  ///   <dd>the longitude where the note was taken
  ///   </dd>
  /// 
  /// <dt>altitude</dt>
  ///   <dd>the altitude where the note was taken
  ///   </dd>
  /// 
  /// <dt>author</dt>
  ///   <dd>the author of the content of the note
  ///   <br/>
  ///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
  ///   </dd>
  /// 
  /// <dt>source</dt>
  ///   <dd>the method that the note was added to the account, if the
  ///   note wasn't directly authored in an Evernote desktop client.
  ///   <br/>
  ///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
  ///   </dd>
  /// 
  /// <dt>sourceURL</dt>
  ///   <dd>the original location where the resource was hosted. For web clips,
  ///   this will be the URL of the page that was clipped.
  ///   <br/>
  ///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
  ///   </dd>
  /// 
  /// <dt>sourceApplication</dt>
  ///   <dd>an identifying string for the application that
  ///   created this note.  This string does not have a guaranteed syntax or
  ///   structure -- it is intended for human inspection and tracking.
  ///   <br/>
  ///   Length:  EDAM_ATTRIBUTE_LEN_MIN - EDAM_ATTRIBUTE_LEN_MAX
  ///   </dd>
  /// 
  /// <dt>shareDate</dt>
  ///  <dd>The date and time when this note was directly shared via its own URL.
  ///  This is only set on notes that were individually shared - it is independent
  ///  of any notebook-level sharing of the containing notebook. This field
  ///  is treated as "read-only" for clients; the server will ignore changes
  ///  to this field from an external client.
  ///  </dd>
  /// 
  /// <dt>reminderOrder</dt>
  /// <dd>The set of notes with this parameter set are considered
  /// "reminders" and are to be treated specially by clients to give them
  /// higher UI prominence within a notebook.  The value is used to sort
  /// the reminder notes within the notebook with higher values
  /// representing greater prominence.  Outside of the context of a
  /// notebook, the value of this parameter is undefined.  The value is
  /// not intended to be compared to the values of reminder notes in
  /// other notebooks.  In order to allow clients to place a note at a
  /// higher precedence than other notes, you should never set a value
  /// greater than the current time (as defined for a Timetstamp). To
  /// place a note at higher precedence than existing notes, set the
  /// value to the current time as defined for a timestamp (milliseconds
  /// since the epoch).  Synchronizing clients must remember the time when
  /// the update was performed, using the local clock on the client,
  /// and use that value when they later upload the note to the service.
  /// Clients must not set the reminderOrder to the reminderTime as the
  /// reminderTime could be in the future.  Those two fields are never
  /// intended to be related.  The correct value for reminderOrder field
  /// for new notes is the "current" time when the user indicated that
  /// the note is a reminder.  Clients may implement a separate
  /// "sort by date" feature to show notes ordered by reminderTime.
  /// Whenever a reminderDoneTime or reminderTime is set but a
  /// reminderOrder is not set, the server will fill in the current
  /// server time for the reminderOrder field.</dd>
  /// 
  /// <dt>reminderDoneTime</dt>
  /// <dd>The date and time when a user dismissed/"marked done" the reminder
  /// on the note.  Users typically do not manually set this value directly
  /// as it is set to the time when the user dismissed/"marked done" the
  /// reminder.</dd>
  /// 
  /// <dt>reminderTime</dt>
  /// <dd>The date and time a user has selected to be reminded of the note.
  /// A note with this value set is known as a "reminder" and the user can
  /// be reminded, via e-mail or client-specific notifications, of the note
  /// when the time is reached or about to be reached.  When a user sets
  /// a reminder time on a note that has a reminder done time, and that
  /// reminder time is in the future, then the reminder done time should be
  /// cleared.  This should happen regardless of any existing reminder time
  /// that may have previously existed on the note.</dd>
  /// 
  /// <dt>placeName</dt>
  /// <dd>Allows the user to assign a human-readable location name associated
  /// with a note. Users may assign values like 'Home' and 'Work'. Place
  /// names may also be populated with values from geonames database
  /// (e.g., a restaurant name). Applications are encouraged to normalize values
  /// so that grouping values by place name provides a useful result. Applications
  /// MUST NOT automatically add place name values based on geolocation without
  /// confirmation from the user; that is, the value in this field should be
  /// more useful than a simple automated lookup based on the note's latitude
  /// and longitude.</dd>
  /// 
  /// <dt>contentClass</dt>
  /// <dd>The class (or type) of note. This field is used to indicate to
  /// clients that special structured information is represented within
  /// the note such that special rules apply when making
  /// modifications. If contentClass is set and the client
  /// application does not specifically support the specified class,
  /// the client MUST treat the note as read-only. In this case, the
  /// client MAY modify the note's notebook and tags via the
  /// Note.notebookGuid and Note.tagGuids fields.  The client MAY also
  /// modify the reminderOrder field as well as the reminderTime and
  /// reminderDoneTime fields.
  /// <p>Applications should set contentClass only when they are creating notes
  /// that contain structured information that needs to be maintained in order
  /// for the user to be able to use the note within that application.
  /// Setting contentClass makes a note read-only in other applications, so
  /// there is a trade-off when an application chooses to use contentClass.
  /// Applications that set contentClass when creating notes must use a contentClass
  /// string of the form <i>CompanyName.ApplicationName</i> to ensure uniqueness.</p>
  /// Length restrictions: EDAM_NOTE_CONTENT_CLASS_LEN_MIN, EDAM_NOTE_CONTENT_CLASS_LEN_MAX
  /// <br/>
  /// Regex: EDAM_NOTE_CONTENT_CLASS_REGEX
  /// </dd>
  /// 
  /// <dt>applicationData</dt>
  /// <dd>Provides a location for applications to store a relatively small
  /// (4kb) blob of data that is not meant to be visible to the user and
  /// that is opaque to the Evernote service. A single application may use at most
  /// one entry in this map, using its API consumer key as the map key. See the
  /// documentation for LazyMap for a description of when the actual map values
  /// are returned by the service.
  /// <p>To safely add or modify your application's entry in the map, use
  /// NoteStore.setNoteApplicationDataEntry. To safely remove your application's
  /// entry from the map, use NoteStore.unsetNoteApplicationDataEntry.</p>
  /// Minimum length of a name (key): EDAM_APPLICATIONDATA_NAME_LEN_MIN
  /// <br/>
  /// Sum max size of key and value: EDAM_APPLICATIONDATA_ENTRY_LEN_MAX
  /// <br/>
  /// Syntax regex for name (key): EDAM_APPLICATIONDATA_NAME_REGEX
  /// </dd>
  /// 
  /// <dt>creatorId</dt>
  /// <dd>The numeric user ID of the user who originally created the note.</dd>
  /// 
  /// <dt>lastEditedBy</dt>
  /// <dd>An indication of who made the last change to the note.  If you are
  /// accessing the note via a shared notebook to which you have modification
  /// rights, or if you are the owner of the notebook to which the note belongs,
  /// then you have access to the value.  In this case, the value will be
  /// unset if the owner of the notebook containing the note was the last to
  /// make the modification, else it will be a string describing the
  /// guest who made the last edit.  If you do not have access to this value,
  /// it will be left unset.  This field is read-only by clients.  The server
  /// will ignore all values set by clients into this field.</dd>
  /// 
  /// <dt>lastEditorId</dt>
  /// <dd>The numeric user ID of the user described in lastEditedBy.</dd>
  /// 
  /// <dt>classifications</dt>
  /// <dd>A map of classifications applied to the note by clients or by the
  /// Evernote service. The key is the string name of the classification type,
  /// and the value is a constant that begins with CLASSIFICATION_.</dd>
  /// 
  /// <dt>sharedWithBusiness</dt>
  /// <dd>When this flag is set on a business note, any user in that business
  /// may view the note if they request it by GUID. This field is read-only by
  /// clients. The server will ignore all values set by clients into this field.
  /// 
  /// To share a note with the business, use NoteStore.shareNoteWithBusiness and
  /// to stop sharing a note with the business, use NoteStore.stopSharingNoteWithBusiness.
  /// </dd>
  /// 
  /// <dt>conflictSourceNoteGuid</dt>
  /// <dd>If set, this specifies the GUID of a note that caused a sync conflict
  /// resulting in the creation of a duplicate note. The duplicated note contains
  /// the user's changes that could not be applied as a result of the sync conflict,
  /// and uses the conflictSourceNoteGuid field to specify the note that caused the
  /// conflict. This allows clients to provide a customized user experience for note
  /// conflicts.
  /// </dd>
  /// 
  /// <dt>noteTitleQuality</dt>
  /// <dd>If set, this specifies that the note's title was automatically generated
  /// and indicates the likelihood that the generated title is useful for display to
  /// the user. If not set, the note's title was manually entered by the user.
  /// 
  /// Clients MUST set this attribute to one of the following values when the
  /// corresponding note's title was not manually entered by the user:
  /// EDAM_NOTE_TITLE_QUALITY_UNTITLED, EDAM_NOTE_TITLE_QUALITY_LOW,
  /// EDAM_NOTE_TITLE_QUALITY_MEDIUM or EDAM_NOTE_TITLE_QUALITY_HIGH.
  /// 
  /// When a user edits a note's title, clients MUST unset this value.
  /// </dd>
  /// </dl>
  /// </summary>
  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class NoteAttributes : TBase
  {
    private long _subjectDate;
    private double _latitude;
    private double _longitude;
    private double _altitude;
    private string _author;
    private string _source;
    private string _sourceURL;
    private string _sourceApplication;
    private long _shareDate;
    private long _reminderOrder;
    private long _reminderDoneTime;
    private long _reminderTime;
    private string _placeName;
    private string _contentClass;
    private LazyMap _applicationData;
    private string _lastEditedBy;
    private Dictionary<string, string> _classifications;
    private int _creatorId;
    private int _lastEditorId;
    private bool _sharedWithBusiness;
    private string _conflictSourceNoteGuid;
    private int _noteTitleQuality;

    public long SubjectDate
    {
      get
      {
        return _subjectDate;
      }
      set
      {
        __isset.subjectDate = true;
        this._subjectDate = value;
      }
    }

    public double Latitude
    {
      get
      {
        return _latitude;
      }
      set
      {
        __isset.latitude = true;
        this._latitude = value;
      }
    }

    public double Longitude
    {
      get
      {
        return _longitude;
      }
      set
      {
        __isset.longitude = true;
        this._longitude = value;
      }
    }

    public double Altitude
    {
      get
      {
        return _altitude;
      }
      set
      {
        __isset.altitude = true;
        this._altitude = value;
      }
    }

    public string Author
    {
      get
      {
        return _author;
      }
      set
      {
        __isset.author = true;
        this._author = value;
      }
    }

    public string Source
    {
      get
      {
        return _source;
      }
      set
      {
        __isset.source = true;
        this._source = value;
      }
    }

    public string SourceURL
    {
      get
      {
        return _sourceURL;
      }
      set
      {
        __isset.sourceURL = true;
        this._sourceURL = value;
      }
    }

    public string SourceApplication
    {
      get
      {
        return _sourceApplication;
      }
      set
      {
        __isset.sourceApplication = true;
        this._sourceApplication = value;
      }
    }

    public long ShareDate
    {
      get
      {
        return _shareDate;
      }
      set
      {
        __isset.shareDate = true;
        this._shareDate = value;
      }
    }

    public long ReminderOrder
    {
      get
      {
        return _reminderOrder;
      }
      set
      {
        __isset.reminderOrder = true;
        this._reminderOrder = value;
      }
    }

    public long ReminderDoneTime
    {
      get
      {
        return _reminderDoneTime;
      }
      set
      {
        __isset.reminderDoneTime = true;
        this._reminderDoneTime = value;
      }
    }

    public long ReminderTime
    {
      get
      {
        return _reminderTime;
      }
      set
      {
        __isset.reminderTime = true;
        this._reminderTime = value;
      }
    }

    public string PlaceName
    {
      get
      {
        return _placeName;
      }
      set
      {
        __isset.placeName = true;
        this._placeName = value;
      }
    }

    public string ContentClass
    {
      get
      {
        return _contentClass;
      }
      set
      {
        __isset.contentClass = true;
        this._contentClass = value;
      }
    }

    public LazyMap ApplicationData
    {
      get
      {
        return _applicationData;
      }
      set
      {
        __isset.applicationData = true;
        this._applicationData = value;
      }
    }

    public string LastEditedBy
    {
      get
      {
        return _lastEditedBy;
      }
      set
      {
        __isset.lastEditedBy = true;
        this._lastEditedBy = value;
      }
    }

    public Dictionary<string, string> Classifications
    {
      get
      {
        return _classifications;
      }
      set
      {
        __isset.classifications = true;
        this._classifications = value;
      }
    }

    public int CreatorId
    {
      get
      {
        return _creatorId;
      }
      set
      {
        __isset.creatorId = true;
        this._creatorId = value;
      }
    }

    public int LastEditorId
    {
      get
      {
        return _lastEditorId;
      }
      set
      {
        __isset.lastEditorId = true;
        this._lastEditorId = value;
      }
    }

    public bool SharedWithBusiness
    {
      get
      {
        return _sharedWithBusiness;
      }
      set
      {
        __isset.sharedWithBusiness = true;
        this._sharedWithBusiness = value;
      }
    }

    public string ConflictSourceNoteGuid
    {
      get
      {
        return _conflictSourceNoteGuid;
      }
      set
      {
        __isset.conflictSourceNoteGuid = true;
        this._conflictSourceNoteGuid = value;
      }
    }

    public int NoteTitleQuality
    {
      get
      {
        return _noteTitleQuality;
      }
      set
      {
        __isset.noteTitleQuality = true;
        this._noteTitleQuality = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool subjectDate;
      public bool latitude;
      public bool longitude;
      public bool altitude;
      public bool author;
      public bool source;
      public bool sourceURL;
      public bool sourceApplication;
      public bool shareDate;
      public bool reminderOrder;
      public bool reminderDoneTime;
      public bool reminderTime;
      public bool placeName;
      public bool contentClass;
      public bool applicationData;
      public bool lastEditedBy;
      public bool classifications;
      public bool creatorId;
      public bool lastEditorId;
      public bool sharedWithBusiness;
      public bool conflictSourceNoteGuid;
      public bool noteTitleQuality;
    }

    public NoteAttributes() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                SubjectDate = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 10:
              if (field.Type == TType.Double) {
                Latitude = iprot.ReadDouble();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 11:
              if (field.Type == TType.Double) {
                Longitude = iprot.ReadDouble();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 12:
              if (field.Type == TType.Double) {
                Altitude = iprot.ReadDouble();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 13:
              if (field.Type == TType.String) {
                Author = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 14:
              if (field.Type == TType.String) {
                Source = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 15:
              if (field.Type == TType.String) {
                SourceURL = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 16:
              if (field.Type == TType.String) {
                SourceApplication = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 17:
              if (field.Type == TType.I64) {
                ShareDate = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 18:
              if (field.Type == TType.I64) {
                ReminderOrder = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 19:
              if (field.Type == TType.I64) {
                ReminderDoneTime = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 20:
              if (field.Type == TType.I64) {
                ReminderTime = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 21:
              if (field.Type == TType.String) {
                PlaceName = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 22:
              if (field.Type == TType.String) {
                ContentClass = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 23:
              if (field.Type == TType.Struct) {
                ApplicationData = new LazyMap();
                ApplicationData.Read(iprot);
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 24:
              if (field.Type == TType.String) {
                LastEditedBy = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 26:
              if (field.Type == TType.Map) {
                {
                  Classifications = new Dictionary<string, string>();
                  TMap _map17 = iprot.ReadMapBegin();
                  for( int _i18 = 0; _i18 < _map17.Count; ++_i18)
                  {
                    string _key19;
                    string _val20;
                    _key19 = iprot.ReadString();
                    _val20 = iprot.ReadString();
                    Classifications[_key19] = _val20;
                  }
                  iprot.ReadMapEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 27:
              if (field.Type == TType.I32) {
                CreatorId = iprot.ReadI32();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 28:
              if (field.Type == TType.I32) {
                LastEditorId = iprot.ReadI32();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 29:
              if (field.Type == TType.Bool) {
                SharedWithBusiness = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 30:
              if (field.Type == TType.String) {
                ConflictSourceNoteGuid = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 31:
              if (field.Type == TType.I32) {
                NoteTitleQuality = iprot.ReadI32();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("NoteAttributes");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.subjectDate) {
          field.Name = "subjectDate";
          field.Type = TType.I64;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(SubjectDate);
          oprot.WriteFieldEnd();
        }
        if (__isset.latitude) {
          field.Name = "latitude";
          field.Type = TType.Double;
          field.ID = 10;
          oprot.WriteFieldBegin(field);
          oprot.WriteDouble(Latitude);
          oprot.WriteFieldEnd();
        }
        if (__isset.longitude) {
          field.Name = "longitude";
          field.Type = TType.Double;
          field.ID = 11;
          oprot.WriteFieldBegin(field);
          oprot.WriteDouble(Longitude);
          oprot.WriteFieldEnd();
        }
        if (__isset.altitude) {
          field.Name = "altitude";
          field.Type = TType.Double;
          field.ID = 12;
          oprot.WriteFieldBegin(field);
          oprot.WriteDouble(Altitude);
          oprot.WriteFieldEnd();
        }
        if (Author != null && __isset.author) {
          field.Name = "author";
          field.Type = TType.String;
          field.ID = 13;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Author);
          oprot.WriteFieldEnd();
        }
        if (Source != null && __isset.source) {
          field.Name = "source";
          field.Type = TType.String;
          field.ID = 14;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Source);
          oprot.WriteFieldEnd();
        }
        if (SourceURL != null && __isset.sourceURL) {
          field.Name = "sourceURL";
          field.Type = TType.String;
          field.ID = 15;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(SourceURL);
          oprot.WriteFieldEnd();
        }
        if (SourceApplication != null && __isset.sourceApplication) {
          field.Name = "sourceApplication";
          field.Type = TType.String;
          field.ID = 16;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(SourceApplication);
          oprot.WriteFieldEnd();
        }
        if (__isset.shareDate) {
          field.Name = "shareDate";
          field.Type = TType.I64;
          field.ID = 17;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(ShareDate);
          oprot.WriteFieldEnd();
        }
        if (__isset.reminderOrder) {
          field.Name = "reminderOrder";
          field.Type = TType.I64;
          field.ID = 18;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(ReminderOrder);
          oprot.WriteFieldEnd();
        }
        if (__isset.reminderDoneTime) {
          field.Name = "reminderDoneTime";
          field.Type = TType.I64;
          field.ID = 19;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(ReminderDoneTime);
          oprot.WriteFieldEnd();
        }
        if (__isset.reminderTime) {
          field.Name = "reminderTime";
          field.Type = TType.I64;
          field.ID = 20;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(ReminderTime);
          oprot.WriteFieldEnd();
        }
        if (PlaceName != null && __isset.placeName) {
          field.Name = "placeName";
          field.Type = TType.String;
          field.ID = 21;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(PlaceName);
          oprot.WriteFieldEnd();
        }
        if (ContentClass != null && __isset.contentClass) {
          field.Name = "contentClass";
          field.Type = TType.String;
          field.ID = 22;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(ContentClass);
          oprot.WriteFieldEnd();
        }
        if (ApplicationData != null && __isset.applicationData) {
          field.Name = "applicationData";
          field.Type = TType.Struct;
          field.ID = 23;
          oprot.WriteFieldBegin(field);
          ApplicationData.Write(oprot);
          oprot.WriteFieldEnd();
        }
        if (LastEditedBy != null && __isset.lastEditedBy) {
          field.Name = "lastEditedBy";
          field.Type = TType.String;
          field.ID = 24;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(LastEditedBy);
          oprot.WriteFieldEnd();
        }
        if (Classifications != null && __isset.classifications) {
          field.Name = "classifications";
          field.Type = TType.Map;
          field.ID = 26;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteMapBegin(new TMap(TType.String, TType.String, Classifications.Count));
            foreach (string _iter21 in Classifications.Keys)
            {
              oprot.WriteString(_iter21);
              oprot.WriteString(Classifications[_iter21]);
            }
            oprot.WriteMapEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (__isset.creatorId) {
          field.Name = "creatorId";
          field.Type = TType.I32;
          field.ID = 27;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(CreatorId);
          oprot.WriteFieldEnd();
        }
        if (__isset.lastEditorId) {
          field.Name = "lastEditorId";
          field.Type = TType.I32;
          field.ID = 28;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(LastEditorId);
          oprot.WriteFieldEnd();
        }
        if (__isset.sharedWithBusiness) {
          field.Name = "sharedWithBusiness";
          field.Type = TType.Bool;
          field.ID = 29;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(SharedWithBusiness);
          oprot.WriteFieldEnd();
        }
        if (ConflictSourceNoteGuid != null && __isset.conflictSourceNoteGuid) {
          field.Name = "conflictSourceNoteGuid";
          field.Type = TType.String;
          field.ID = 30;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(ConflictSourceNoteGuid);
          oprot.WriteFieldEnd();
        }
        if (__isset.noteTitleQuality) {
          field.Name = "noteTitleQuality";
          field.Type = TType.I32;
          field.ID = 31;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(NoteTitleQuality);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("NoteAttributes(");
      bool __first = true;
      if (__isset.subjectDate) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SubjectDate: ");
        __sb.Append(SubjectDate);
      }
      if (__isset.latitude) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Latitude: ");
        __sb.Append(Latitude);
      }
      if (__isset.longitude) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Longitude: ");
        __sb.Append(Longitude);
      }
      if (__isset.altitude) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Altitude: ");
        __sb.Append(Altitude);
      }
      if (Author != null && __isset.author) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Author: ");
        __sb.Append(Author);
      }
      if (Source != null && __isset.source) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Source: ");
        __sb.Append(Source);
      }
      if (SourceURL != null && __isset.sourceURL) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SourceURL: ");
        __sb.Append(SourceURL);
      }
      if (SourceApplication != null && __isset.sourceApplication) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SourceApplication: ");
        __sb.Append(SourceApplication);
      }
      if (__isset.shareDate) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ShareDate: ");
        __sb.Append(ShareDate);
      }
      if (__isset.reminderOrder) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ReminderOrder: ");
        __sb.Append(ReminderOrder);
      }
      if (__isset.reminderDoneTime) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ReminderDoneTime: ");
        __sb.Append(ReminderDoneTime);
      }
      if (__isset.reminderTime) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ReminderTime: ");
        __sb.Append(ReminderTime);
      }
      if (PlaceName != null && __isset.placeName) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("PlaceName: ");
        __sb.Append(PlaceName);
      }
      if (ContentClass != null && __isset.contentClass) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ContentClass: ");
        __sb.Append(ContentClass);
      }
      if (ApplicationData != null && __isset.applicationData) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ApplicationData: ");
        __sb.Append(ApplicationData== null ? "<null>" : ApplicationData.ToString());
      }
      if (LastEditedBy != null && __isset.lastEditedBy) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("LastEditedBy: ");
        __sb.Append(LastEditedBy);
      }
      if (Classifications != null && __isset.classifications) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Classifications: ");
        __sb.Append(Classifications);
      }
      if (__isset.creatorId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("CreatorId: ");
        __sb.Append(CreatorId);
      }
      if (__isset.lastEditorId) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("LastEditorId: ");
        __sb.Append(LastEditorId);
      }
      if (__isset.sharedWithBusiness) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SharedWithBusiness: ");
        __sb.Append(SharedWithBusiness);
      }
      if (ConflictSourceNoteGuid != null && __isset.conflictSourceNoteGuid) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ConflictSourceNoteGuid: ");
        __sb.Append(ConflictSourceNoteGuid);
      }
      if (__isset.noteTitleQuality) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("NoteTitleQuality: ");
        __sb.Append(NoteTitleQuality);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
