/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  /// This structure encapsulates the information about the state of the
  /// user's account for the purpose of "state based" synchronization.
  /// <dl>
  /// <dt>currentTime</dt>
  ///   <dd>
  ///   The server's current date and time.
  ///   </dd>
  /// <dt>fullSyncBefore</dt>
  ///   <dd>
  ///   The cutoff date and time for client caches to be
  ///   updated via incremental synchronization.  Any clients that were last
  ///   synched with the server before this date/time must do a full resync of all
  ///   objects.  This cutoff point will change over time as archival data is
  ///   deleted or special circumstances on the service require resynchronization.
  ///   </dd>
  /// <dt>updateCount</dt>
  ///   <dd>
  ///   Indicates the total number of transactions that have
  ///   been committed within the account.  This reflects (for example) the
  ///   number of discrete additions or modifications that have been made to
  ///   the data in this account (tags, notes, resources, etc.).
  ///   This number is the "high water mark" for Update Sequence Numbers (USN)
  ///   within the account.
  ///   </dd>
  /// <dt>uploaded</dt>
  ///   <dd>
  ///   The total number of bytes that have been uploaded to
  ///   this account in the current monthly period.  This can be compared against
  ///   Accounting.uploadLimit (from the UserStore) to determine how close the user
  ///   is to their monthly upload limit.
  ///   This value may not be present if the SyncState has been retrieved by
  ///   a caller that only has read access to the account.
  ///   </dd>
  /// <dt>userLastUpdated</dt>
  ///   <dd>
  ///   The last time when a user's account level information was changed. This value
  ///   is the latest time when a modification was made to any of the following:
  ///   accounting information (billing, quota, premium status, etc.), user attributes
  ///   and business user information (business name, business user attributes, etc.) if
  ///   the user is in a business.
  ///   Clients who need to maintain account information about a User should watch this
  ///   field for updates rather than polling UserStore.getUser for updates. Here is the
  ///   basic flow that clients should follow:
  ///   <ol>
  ///     <li>Call NoteStore.getSyncState to retrieve the SyncState object</li>
  ///     <li>Compare SyncState.userLastUpdated to previously stored value:
  ///         if (SyncState.userLastUpdated > previousValue)
  ///           call UserStore.getUser to get the latest User object;
  ///         else
  ///           do nothing;</li>
  ///     <li>Update previousValue = SyncState.userLastUpdated</li>
  ///   </ol>
  ///   </dd>
  /// <dt>userMaxMessageEventId</dt>
  ///   <dd>
  ///   The greatest MessageEventID for this user's account. Clients that do a full
  ///   sync should store this value locally and compare their local copy to the
  ///   value returned by getSyncState to determine if they need to sync with
  ///   MessageStore. This value will be omitted if the user has never sent or
  ///   received a message.
  ///   </dd>
  /// </dl>
  /// </summary>
  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class SyncState : TBase
  {
    private long _uploaded;
    private long _userLastUpdated;
    private long _userMaxMessageEventId;

    public long CurrentTime { get; set; }

    public long FullSyncBefore { get; set; }

    public int UpdateCount { get; set; }

    public long Uploaded
    {
      get
      {
        return _uploaded;
      }
      set
      {
        __isset.uploaded = true;
        this._uploaded = value;
      }
    }

    public long UserLastUpdated
    {
      get
      {
        return _userLastUpdated;
      }
      set
      {
        __isset.userLastUpdated = true;
        this._userLastUpdated = value;
      }
    }

    public long UserMaxMessageEventId
    {
      get
      {
        return _userMaxMessageEventId;
      }
      set
      {
        __isset.userMaxMessageEventId = true;
        this._userMaxMessageEventId = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool uploaded;
      public bool userLastUpdated;
      public bool userMaxMessageEventId;
    }

    public SyncState() {
    }

    public SyncState(long currentTime, long fullSyncBefore, int updateCount) : this() {
      this.CurrentTime = currentTime;
      this.FullSyncBefore = fullSyncBefore;
      this.UpdateCount = updateCount;
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_currentTime = false;
        bool isset_fullSyncBefore = false;
        bool isset_updateCount = false;
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I64) {
                CurrentTime = iprot.ReadI64();
                isset_currentTime = true;
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I64) {
                FullSyncBefore = iprot.ReadI64();
                isset_fullSyncBefore = true;
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.I32) {
                UpdateCount = iprot.ReadI32();
                isset_updateCount = true;
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 4:
              if (field.Type == TType.I64) {
                Uploaded = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 5:
              if (field.Type == TType.I64) {
                UserLastUpdated = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 6:
              if (field.Type == TType.I64) {
                UserMaxMessageEventId = iprot.ReadI64();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
        if (!isset_currentTime)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field CurrentTime not set");
        if (!isset_fullSyncBefore)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field FullSyncBefore not set");
        if (!isset_updateCount)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field UpdateCount not set");
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("SyncState");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        field.Name = "currentTime";
        field.Type = TType.I64;
        field.ID = 1;
        oprot.WriteFieldBegin(field);
        oprot.WriteI64(CurrentTime);
        oprot.WriteFieldEnd();
        field.Name = "fullSyncBefore";
        field.Type = TType.I64;
        field.ID = 2;
        oprot.WriteFieldBegin(field);
        oprot.WriteI64(FullSyncBefore);
        oprot.WriteFieldEnd();
        field.Name = "updateCount";
        field.Type = TType.I32;
        field.ID = 3;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(UpdateCount);
        oprot.WriteFieldEnd();
        if (__isset.uploaded) {
          field.Name = "uploaded";
          field.Type = TType.I64;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(Uploaded);
          oprot.WriteFieldEnd();
        }
        if (__isset.userLastUpdated) {
          field.Name = "userLastUpdated";
          field.Type = TType.I64;
          field.ID = 5;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(UserLastUpdated);
          oprot.WriteFieldEnd();
        }
        if (__isset.userMaxMessageEventId) {
          field.Name = "userMaxMessageEventId";
          field.Type = TType.I64;
          field.ID = 6;
          oprot.WriteFieldBegin(field);
          oprot.WriteI64(UserMaxMessageEventId);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("SyncState(");
      __sb.Append(", CurrentTime: ");
      __sb.Append(CurrentTime);
      __sb.Append(", FullSyncBefore: ");
      __sb.Append(FullSyncBefore);
      __sb.Append(", UpdateCount: ");
      __sb.Append(UpdateCount);
      if (__isset.uploaded) {
        __sb.Append(", Uploaded: ");
        __sb.Append(Uploaded);
      }
      if (__isset.userLastUpdated) {
        __sb.Append(", UserLastUpdated: ");
        __sb.Append(UserLastUpdated);
      }
      if (__isset.userMaxMessageEventId) {
        __sb.Append(", UserMaxMessageEventId: ");
        __sb.Append(UserMaxMessageEventId);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
