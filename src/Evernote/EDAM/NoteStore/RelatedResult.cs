/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  /// The result of calling findRelated().  The contents of the notes,
  /// notebooks, and tags fields will be in decreasing order of expected
  /// relevance.  It is possible that fewer results than requested will be
  /// returned even if there are enough distinct entities in the account
  /// in cases where the relevance is estimated to be low.
  /// 
  /// <dl>
  /// <dt>notes</dt>
  /// <dd>If notes have been requested to be included, this will be the
  ///     list of notes.</dd>
  /// 
  /// <dt>notebooks</dt>
  /// <dd>If notebooks have been requested to be included, this will be the
  ///     list of notebooks.</dd>
  /// 
  /// <dt>tags</dt>
  /// <dd>If tags have been requested to be included, this will be the list
  ///     of tags.</dd>
  /// 
  /// <dt>containingNotebooks</dt>
  /// <dd>If <code>includeContainingNotebooks</code> is set to <code>true</code>
  ///     in the RelatedResultSpec, return the list of notebooks to
  ///     to which the returned related notes belong. The notebooks in this
  ///     list will occur once per notebook GUID and are represented as
  ///     NotebookDescriptor objects.</dd>
  /// 
  /// <dt>experts</dt>
  /// <dd>If experts have been requested to be included, this will return
  ///  a list of users within your business who have knowledge about the specified query.
  /// </dd>
  /// 
  /// <dt>relatedContent</dt>
  /// <dd>If related content has been requested to be included, this will be the list of
  ///  related content snippets.
  /// </dd>
  /// 
  /// <dt>cacheKey</dt>
  /// <dd>If set and non-empty, this cache key may be used in subsequent
  ///     "NoteStore.findRelated" calls (via "RelatedQuery") to re-use previous
  ///     responses that were cached on the client-side, instead of actually performing
  ///     another search.
  /// 
  ///     If set to an empty string, this indicates that the server could not determine
  ///     a specific key for this response, but the client should nevertheless remove
  ///     any previously cached result for this request.
  /// 
  ///     If unset/null, it is up to the client whether to re-use cached results or to
  ///     use the server's response.
  /// 
  ///     If set to the exact non-empty cache key that was specified in
  ///     "RelatedQuery.cacheKey", this indicates that the server decided that cached results
  ///     could be reused.
  /// 
  ///     Depending on the cache key specified in the query, the "RelatedResult" may only be
  ///     partially filled. For each set field, the client should replace the corresponding
  ///     part in the previously cached result with the new partial result.
  /// 
  ///     For example, for a specific query that has both "RelatedResultSpec.maxNotes" and
  ///     "RelatedResultSpec.maxRelatedContent" set to positive values, the server may decide
  ///     that the previously requested and cached <em>Related Content</em> are unchanged,
  ///     but new results for <em>Related Notes</em> are available. The
  ///     response will have a new cache key and have "RelatedResult.notes" set, but have
  ///     "RelatedResult.relatedContent" unset (not just empty, but really unset).
  /// 
  ///     In this situation, the client should replace any cached notes with the newly
  ///     returned "RelatedResult.notes", but it can re-use the previously cached entries for
  ///     "RelatedResult.relatedContent". List fields that are set, but empty indicate that
  ///     no results could be found; the cache should be updated correspondingly.
  /// </dd>
  /// 
  /// <dt>cacheExpires</dt>
  /// <dd> If set, clients should reuse this response for any situations where the same input
  ///      parameters are applicable for up to this many seconds after receiving this result.
  /// 
  ///      After this time has passed, the client may request a new result from the service,
  ///      but it should supply the stored cacheKey to the service when checking for an
  ///      update.
  /// </dd>
  /// 
  /// </dl>
  /// </summary>
  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class RelatedResult : TBase
  {
    private List<Evernote.EDAM.Type.Note> _notes;
    private List<Evernote.EDAM.Type.Notebook> _notebooks;
    private List<Evernote.EDAM.Type.Tag> _tags;
    private List<Evernote.EDAM.Type.NotebookDescriptor> _containingNotebooks;
    private string _debugInfo;
    private List<Evernote.EDAM.Type.UserProfile> _experts;
    private List<Evernote.EDAM.Type.RelatedContent> _relatedContent;
    private string _cacheKey;
    private int _cacheExpires;

    public List<Evernote.EDAM.Type.Note> Notes
    {
      get
      {
        return _notes;
      }
      set
      {
        __isset.notes = true;
        this._notes = value;
      }
    }

    public List<Evernote.EDAM.Type.Notebook> Notebooks
    {
      get
      {
        return _notebooks;
      }
      set
      {
        __isset.notebooks = true;
        this._notebooks = value;
      }
    }

    public List<Evernote.EDAM.Type.Tag> Tags
    {
      get
      {
        return _tags;
      }
      set
      {
        __isset.tags = true;
        this._tags = value;
      }
    }

    public List<Evernote.EDAM.Type.NotebookDescriptor> ContainingNotebooks
    {
      get
      {
        return _containingNotebooks;
      }
      set
      {
        __isset.containingNotebooks = true;
        this._containingNotebooks = value;
      }
    }

    public string DebugInfo
    {
      get
      {
        return _debugInfo;
      }
      set
      {
        __isset.debugInfo = true;
        this._debugInfo = value;
      }
    }

    public List<Evernote.EDAM.Type.UserProfile> Experts
    {
      get
      {
        return _experts;
      }
      set
      {
        __isset.experts = true;
        this._experts = value;
      }
    }

    public List<Evernote.EDAM.Type.RelatedContent> RelatedContent
    {
      get
      {
        return _relatedContent;
      }
      set
      {
        __isset.relatedContent = true;
        this._relatedContent = value;
      }
    }

    public string CacheKey
    {
      get
      {
        return _cacheKey;
      }
      set
      {
        __isset.cacheKey = true;
        this._cacheKey = value;
      }
    }

    public int CacheExpires
    {
      get
      {
        return _cacheExpires;
      }
      set
      {
        __isset.cacheExpires = true;
        this._cacheExpires = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool notes;
      public bool notebooks;
      public bool tags;
      public bool containingNotebooks;
      public bool debugInfo;
      public bool experts;
      public bool relatedContent;
      public bool cacheKey;
      public bool cacheExpires;
    }

    public RelatedResult() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.List) {
                {
                  Notes = new List<Evernote.EDAM.Type.Note>();
                  TList _list98 = iprot.ReadListBegin();
                  for( int _i99 = 0; _i99 < _list98.Count; ++_i99)
                  {
                    Evernote.EDAM.Type.Note _elem100;
                    _elem100 = new Evernote.EDAM.Type.Note();
                    _elem100.Read(iprot);
                    Notes.Add(_elem100);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.List) {
                {
                  Notebooks = new List<Evernote.EDAM.Type.Notebook>();
                  TList _list101 = iprot.ReadListBegin();
                  for( int _i102 = 0; _i102 < _list101.Count; ++_i102)
                  {
                    Evernote.EDAM.Type.Notebook _elem103;
                    _elem103 = new Evernote.EDAM.Type.Notebook();
                    _elem103.Read(iprot);
                    Notebooks.Add(_elem103);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.List) {
                {
                  Tags = new List<Evernote.EDAM.Type.Tag>();
                  TList _list104 = iprot.ReadListBegin();
                  for( int _i105 = 0; _i105 < _list104.Count; ++_i105)
                  {
                    Evernote.EDAM.Type.Tag _elem106;
                    _elem106 = new Evernote.EDAM.Type.Tag();
                    _elem106.Read(iprot);
                    Tags.Add(_elem106);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 4:
              if (field.Type == TType.List) {
                {
                  ContainingNotebooks = new List<Evernote.EDAM.Type.NotebookDescriptor>();
                  TList _list107 = iprot.ReadListBegin();
                  for( int _i108 = 0; _i108 < _list107.Count; ++_i108)
                  {
                    Evernote.EDAM.Type.NotebookDescriptor _elem109;
                    _elem109 = new Evernote.EDAM.Type.NotebookDescriptor();
                    _elem109.Read(iprot);
                    ContainingNotebooks.Add(_elem109);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 5:
              if (field.Type == TType.String) {
                DebugInfo = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 6:
              if (field.Type == TType.List) {
                {
                  Experts = new List<Evernote.EDAM.Type.UserProfile>();
                  TList _list110 = iprot.ReadListBegin();
                  for( int _i111 = 0; _i111 < _list110.Count; ++_i111)
                  {
                    Evernote.EDAM.Type.UserProfile _elem112;
                    _elem112 = new Evernote.EDAM.Type.UserProfile();
                    _elem112.Read(iprot);
                    Experts.Add(_elem112);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 7:
              if (field.Type == TType.List) {
                {
                  RelatedContent = new List<Evernote.EDAM.Type.RelatedContent>();
                  TList _list113 = iprot.ReadListBegin();
                  for( int _i114 = 0; _i114 < _list113.Count; ++_i114)
                  {
                    Evernote.EDAM.Type.RelatedContent _elem115;
                    _elem115 = new Evernote.EDAM.Type.RelatedContent();
                    _elem115.Read(iprot);
                    RelatedContent.Add(_elem115);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 8:
              if (field.Type == TType.String) {
                CacheKey = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 9:
              if (field.Type == TType.I32) {
                CacheExpires = iprot.ReadI32();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("RelatedResult");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (Notes != null && __isset.notes) {
          field.Name = "notes";
          field.Type = TType.List;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Notes.Count));
            foreach (Evernote.EDAM.Type.Note _iter116 in Notes)
            {
              _iter116.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (Notebooks != null && __isset.notebooks) {
          field.Name = "notebooks";
          field.Type = TType.List;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Notebooks.Count));
            foreach (Evernote.EDAM.Type.Notebook _iter117 in Notebooks)
            {
              _iter117.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (Tags != null && __isset.tags) {
          field.Name = "tags";
          field.Type = TType.List;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Tags.Count));
            foreach (Evernote.EDAM.Type.Tag _iter118 in Tags)
            {
              _iter118.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (ContainingNotebooks != null && __isset.containingNotebooks) {
          field.Name = "containingNotebooks";
          field.Type = TType.List;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, ContainingNotebooks.Count));
            foreach (Evernote.EDAM.Type.NotebookDescriptor _iter119 in ContainingNotebooks)
            {
              _iter119.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (DebugInfo != null && __isset.debugInfo) {
          field.Name = "debugInfo";
          field.Type = TType.String;
          field.ID = 5;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(DebugInfo);
          oprot.WriteFieldEnd();
        }
        if (Experts != null && __isset.experts) {
          field.Name = "experts";
          field.Type = TType.List;
          field.ID = 6;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, Experts.Count));
            foreach (Evernote.EDAM.Type.UserProfile _iter120 in Experts)
            {
              _iter120.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (RelatedContent != null && __isset.relatedContent) {
          field.Name = "relatedContent";
          field.Type = TType.List;
          field.ID = 7;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.Struct, RelatedContent.Count));
            foreach (Evernote.EDAM.Type.RelatedContent _iter121 in RelatedContent)
            {
              _iter121.Write(oprot);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (CacheKey != null && __isset.cacheKey) {
          field.Name = "cacheKey";
          field.Type = TType.String;
          field.ID = 8;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(CacheKey);
          oprot.WriteFieldEnd();
        }
        if (__isset.cacheExpires) {
          field.Name = "cacheExpires";
          field.Type = TType.I32;
          field.ID = 9;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(CacheExpires);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("RelatedResult(");
      bool __first = true;
      if (Notes != null && __isset.notes) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Notes: ");
        __sb.Append(Notes);
      }
      if (Notebooks != null && __isset.notebooks) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Notebooks: ");
        __sb.Append(Notebooks);
      }
      if (Tags != null && __isset.tags) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Tags: ");
        __sb.Append(Tags);
      }
      if (ContainingNotebooks != null && __isset.containingNotebooks) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("ContainingNotebooks: ");
        __sb.Append(ContainingNotebooks);
      }
      if (DebugInfo != null && __isset.debugInfo) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("DebugInfo: ");
        __sb.Append(DebugInfo);
      }
      if (Experts != null && __isset.experts) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Experts: ");
        __sb.Append(Experts);
      }
      if (RelatedContent != null && __isset.relatedContent) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("RelatedContent: ");
        __sb.Append(RelatedContent);
      }
      if (CacheKey != null && __isset.cacheKey) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("CacheKey: ");
        __sb.Append(CacheKey);
      }
      if (__isset.cacheExpires) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("CacheExpires: ");
        __sb.Append(CacheExpires);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
