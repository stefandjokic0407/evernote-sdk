/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  ///  This structure is returned from calls to the findNotesMetadata function to
  ///  give the high-level metadata about a subset of Notes that are found to
  ///  match a specified NoteFilter in a search.
  /// 
  /// <dl>
  ///  <dt>startIndex</dt>
  ///    <dd>
  ///    The starting index within the overall set of notes.  This
  ///    is also the number of notes that are "before" this list in the set.
  ///    </dd>
  /// 
  ///  <dt>totalNotes</dt>
  ///    <dd>
  ///    The number of notes in the larger set.  This can be used
  ///    to calculate how many notes are "after" this note in the set.
  ///    (I.e.  remaining = totalNotes - (startIndex + notes.length)  )
  ///    </dd>
  /// 
  ///  <dt>notes</dt>
  ///    <dd>
  ///    The list of metadata for Notes in this range.  The set of optional fields
  ///    that are set in each metadata structure will depend on the
  ///    NotesMetadataResultSpec provided by the caller when the search was
  ///    performed.  Only the 'guid' field will be guaranteed to be set in each
  ///    Note.
  ///    </dd>
  /// 
  ///  <dt>stoppedWords</dt>
  ///    <dd>
  ///    If the NoteList was produced using a text based search
  ///    query that included words that are not indexed or searched by the service,
  ///    this will include a list of those ignored words.
  ///    </dd>
  /// 
  ///  <dt>searchedWords</dt>
  ///    <dd>
  ///    If the NoteList was produced using a text based search
  ///    query that included viable search words or quoted expressions, this will
  ///    include a list of those words.  Any stopped words will not be included
  ///    in this list.
  ///    </dd>
  /// 
  ///  <dt>updateCount</dt>
  ///    <dd>
  ///    Indicates the total number of transactions that have
  ///    been committed within the account.  This reflects (for example) the
  ///    number of discrete additions or modifications that have been made to
  ///    the data in this account (tags, notes, resources, etc.).
  ///    This number is the "high water mark" for Update Sequence Numbers (USN)
  ///    within the account.
  ///    </dd>
  /// 
  ///  <dt>searchContextBytes</dt>
  ///    <dd>
  ///    Specifies the correlating information about the current search session, in byte array.
  ///    </dd>
  /// 
  ///  <dt>debugInfo</dt>
  ///    <dd>
  ///    Depends on the value of <code>context</code> in NoteFilter, this field
  ///    may contain debug information if the service decides to do so.
  ///    </dd>
  /// 
  ///  </dl>
  /// </summary>
  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class NotesMetadataList : TBase
  {
    private List<string> _stoppedWords;
    private List<string> _searchedWords;
    private int _updateCount;
    private byte[] _searchContextBytes;
    private string _debugInfo;

    public int StartIndex { get; set; }

    public int TotalNotes { get; set; }

    public List<NoteMetadata> Notes { get; set; }

    public List<string> StoppedWords
    {
      get
      {
        return _stoppedWords;
      }
      set
      {
        __isset.stoppedWords = true;
        this._stoppedWords = value;
      }
    }

    public List<string> SearchedWords
    {
      get
      {
        return _searchedWords;
      }
      set
      {
        __isset.searchedWords = true;
        this._searchedWords = value;
      }
    }

    public int UpdateCount
    {
      get
      {
        return _updateCount;
      }
      set
      {
        __isset.updateCount = true;
        this._updateCount = value;
      }
    }

    public byte[] SearchContextBytes
    {
      get
      {
        return _searchContextBytes;
      }
      set
      {
        __isset.searchContextBytes = true;
        this._searchContextBytes = value;
      }
    }

    public string DebugInfo
    {
      get
      {
        return _debugInfo;
      }
      set
      {
        __isset.debugInfo = true;
        this._debugInfo = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool stoppedWords;
      public bool searchedWords;
      public bool updateCount;
      public bool searchContextBytes;
      public bool debugInfo;
    }

    public NotesMetadataList() {
    }

    public NotesMetadataList(int startIndex, int totalNotes, List<NoteMetadata> notes) : this() {
      this.StartIndex = startIndex;
      this.TotalNotes = totalNotes;
      this.Notes = notes;
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_startIndex = false;
        bool isset_totalNotes = false;
        bool isset_notes = false;
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32) {
                StartIndex = iprot.ReadI32();
                isset_startIndex = true;
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.I32) {
                TotalNotes = iprot.ReadI32();
                isset_totalNotes = true;
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.List) {
                {
                  Notes = new List<NoteMetadata>();
                  TList _list68 = iprot.ReadListBegin();
                  for( int _i69 = 0; _i69 < _list68.Count; ++_i69)
                  {
                    NoteMetadata _elem70;
                    _elem70 = new NoteMetadata();
                    _elem70.Read(iprot);
                    Notes.Add(_elem70);
                  }
                  iprot.ReadListEnd();
                }
                isset_notes = true;
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 4:
              if (field.Type == TType.List) {
                {
                  StoppedWords = new List<string>();
                  TList _list71 = iprot.ReadListBegin();
                  for( int _i72 = 0; _i72 < _list71.Count; ++_i72)
                  {
                    string _elem73;
                    _elem73 = iprot.ReadString();
                    StoppedWords.Add(_elem73);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 5:
              if (field.Type == TType.List) {
                {
                  SearchedWords = new List<string>();
                  TList _list74 = iprot.ReadListBegin();
                  for( int _i75 = 0; _i75 < _list74.Count; ++_i75)
                  {
                    string _elem76;
                    _elem76 = iprot.ReadString();
                    SearchedWords.Add(_elem76);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 6:
              if (field.Type == TType.I32) {
                UpdateCount = iprot.ReadI32();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 7:
              if (field.Type == TType.String) {
                SearchContextBytes = iprot.ReadBinary();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 9:
              if (field.Type == TType.String) {
                DebugInfo = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
        if (!isset_startIndex)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field StartIndex not set");
        if (!isset_totalNotes)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field TotalNotes not set");
        if (!isset_notes)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Notes not set");
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("NotesMetadataList");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        field.Name = "startIndex";
        field.Type = TType.I32;
        field.ID = 1;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(StartIndex);
        oprot.WriteFieldEnd();
        field.Name = "totalNotes";
        field.Type = TType.I32;
        field.ID = 2;
        oprot.WriteFieldBegin(field);
        oprot.WriteI32(TotalNotes);
        oprot.WriteFieldEnd();
        if (Notes == null)
          throw new TProtocolException(TProtocolException.INVALID_DATA, "required field Notes not set");
        field.Name = "notes";
        field.Type = TType.List;
        field.ID = 3;
        oprot.WriteFieldBegin(field);
        {
          oprot.WriteListBegin(new TList(TType.Struct, Notes.Count));
          foreach (NoteMetadata _iter77 in Notes)
          {
            _iter77.Write(oprot);
          }
          oprot.WriteListEnd();
        }
        oprot.WriteFieldEnd();
        if (StoppedWords != null && __isset.stoppedWords) {
          field.Name = "stoppedWords";
          field.Type = TType.List;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.String, StoppedWords.Count));
            foreach (string _iter78 in StoppedWords)
            {
              oprot.WriteString(_iter78);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (SearchedWords != null && __isset.searchedWords) {
          field.Name = "searchedWords";
          field.Type = TType.List;
          field.ID = 5;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.String, SearchedWords.Count));
            foreach (string _iter79 in SearchedWords)
            {
              oprot.WriteString(_iter79);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (__isset.updateCount) {
          field.Name = "updateCount";
          field.Type = TType.I32;
          field.ID = 6;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(UpdateCount);
          oprot.WriteFieldEnd();
        }
        if (SearchContextBytes != null && __isset.searchContextBytes) {
          field.Name = "searchContextBytes";
          field.Type = TType.String;
          field.ID = 7;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(SearchContextBytes);
          oprot.WriteFieldEnd();
        }
        if (DebugInfo != null && __isset.debugInfo) {
          field.Name = "debugInfo";
          field.Type = TType.String;
          field.ID = 9;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(DebugInfo);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("NotesMetadataList(");
      __sb.Append(", StartIndex: ");
      __sb.Append(StartIndex);
      __sb.Append(", TotalNotes: ");
      __sb.Append(TotalNotes);
      __sb.Append(", Notes: ");
      __sb.Append(Notes);
      if (StoppedWords != null && __isset.stoppedWords) {
        __sb.Append(", StoppedWords: ");
        __sb.Append(StoppedWords);
      }
      if (SearchedWords != null && __isset.searchedWords) {
        __sb.Append(", SearchedWords: ");
        __sb.Append(SearchedWords);
      }
      if (__isset.updateCount) {
        __sb.Append(", UpdateCount: ");
        __sb.Append(UpdateCount);
      }
      if (SearchContextBytes != null && __isset.searchContextBytes) {
        __sb.Append(", SearchContextBytes: ");
        __sb.Append(SearchContextBytes);
      }
      if (DebugInfo != null && __isset.debugInfo) {
        __sb.Append(", DebugInfo: ");
        __sb.Append(DebugInfo);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
