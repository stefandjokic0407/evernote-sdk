/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.NoteStore
{

  /// <summary>
  ///  A list of criteria that are used to indicate which notes are desired from
  ///  the account.  This is used in queries to the NoteStore to determine
  ///  which notes should be retrieved.
  /// 
  /// <dl>
  ///  <dt>order</dt>
  ///    <dd>
  ///    The NoteSortOrder value indicating what criterion should be
  ///    used to sort the results of the filter.
  ///    </dd>
  /// 
  ///  <dt>ascending</dt>
  ///    <dd>
  ///    If true, the results will be ascending in the requested
  ///    sort order.  If false, the results will be descending.
  ///    </dd>
  /// 
  ///  <dt>words</dt>
  ///    <dd>
  ///    If present, a search query string that will filter the set of notes to be returned.
  ///    Accepts the full search grammar documented in the Evernote API Overview.
  ///    </dd>
  /// 
  ///  <dt>notebookGuid</dt>
  ///    <dd>
  ///    If present, the Guid of the notebook that must contain
  ///    the notes.
  ///    </dd>
  /// 
  ///  <dt>tagGuids</dt>
  ///    <dd>
  ///    If present, the list of tags (by GUID) that must be present
  ///    on the notes.
  ///    </dd>
  /// 
  ///  <dt>timeZone</dt>
  ///    <dd>
  ///    The zone ID for the user, which will be used to interpret
  ///    any dates or times in the queries that do not include their desired zone
  ///    information.
  ///    For example, if a query requests notes created "yesterday", this
  ///    will be evaluated from the provided time zone, if provided.
  ///    The format must be encoded as a standard zone ID such as
  ///    "America/Los_Angeles".
  ///    </dd>
  /// 
  ///  <dt>inactive</dt>
  ///    <dd>
  ///    If true, then only notes that are not active (i.e. notes in
  ///    the Trash) will be returned. Otherwise, only active notes will be returned.
  ///    There is no way to find both active and inactive notes in a single query.
  ///    </dd>
  /// 
  ///  <dt>emphasized</dt>
  ///    <dd>
  ///    If present, a search query string that may or may not influence the notes
  ///    to be returned, both in terms of coverage as well as of order. Think of it
  ///    as a wish list, not a requirement.
  ///    Accepts the full search grammar documented in the Evernote API Overview.
  ///    </dd>
  /// 
  ///  <dt>includeAllReadableNotebooks</dt>
  ///    <dd>
  ///    If true, then the search will include all business notebooks that are readable
  ///    by the user. A business authentication token must be supplied for
  ///    this option to take effect when calling search APIs.
  ///    </dd>
  /// 
  ///  <dt>includeAllReadableWorkspaces</dt>
  ///    <dd>
  ///    If true, then the search will include all workspaces that are readable
  ///    by the user. A business authentication token must be supplied for
  ///    this option to take effect when calling search APIs.
  ///    </dd>
  /// 
  ///  <dt>context</dt>
  ///    <dd>
  ///    Specifies the context to consider when determining result ranking.
  ///    Clients must leave this value unset unless they wish to explicitly specify a known
  ///    non-default context.
  ///    </dd>
  /// 
  ///  <dt>rawWords</dt>
  ///    <dd>
  ///    If present, the raw user query input.
  ///    Accepts the full search grammar documented in the Evernote API Overview.
  ///    </dd>
  /// 
  ///  <dt>searchContextBytes</dt>
  ///    <dd>
  ///    Specifies the correlating information about the current search session, in byte array.
  ///    If this request is not for the first page of search results, the client should populate
  ///    this field with the value of searchContextBytes from the NotesMetadataList of the
  ///    original search response.
  ///    </dd>
  ///  </dl>
  /// </summary>
  #if !SILVERLIGHT
  [Serializable]
  #endif
  public partial class NoteFilter : TBase
  {
    private int _order;
    private bool _ascending;
    private string _words;
    private string _notebookGuid;
    private List<string> _tagGuids;
    private string _timeZone;
    private bool _inactive;
    private string _emphasized;
    private bool _includeAllReadableNotebooks;
    private bool _includeAllReadableWorkspaces;
    private string _context;
    private string _rawWords;
    private byte[] _searchContextBytes;

    public int Order
    {
      get
      {
        return _order;
      }
      set
      {
        __isset.order = true;
        this._order = value;
      }
    }

    public bool Ascending
    {
      get
      {
        return _ascending;
      }
      set
      {
        __isset.@ascending = true;
        this._ascending = value;
      }
    }

    public string Words
    {
      get
      {
        return _words;
      }
      set
      {
        __isset.words = true;
        this._words = value;
      }
    }

    public string NotebookGuid
    {
      get
      {
        return _notebookGuid;
      }
      set
      {
        __isset.notebookGuid = true;
        this._notebookGuid = value;
      }
    }

    public List<string> TagGuids
    {
      get
      {
        return _tagGuids;
      }
      set
      {
        __isset.tagGuids = true;
        this._tagGuids = value;
      }
    }

    public string TimeZone
    {
      get
      {
        return _timeZone;
      }
      set
      {
        __isset.timeZone = true;
        this._timeZone = value;
      }
    }

    public bool Inactive
    {
      get
      {
        return _inactive;
      }
      set
      {
        __isset.inactive = true;
        this._inactive = value;
      }
    }

    public string Emphasized
    {
      get
      {
        return _emphasized;
      }
      set
      {
        __isset.emphasized = true;
        this._emphasized = value;
      }
    }

    public bool IncludeAllReadableNotebooks
    {
      get
      {
        return _includeAllReadableNotebooks;
      }
      set
      {
        __isset.includeAllReadableNotebooks = true;
        this._includeAllReadableNotebooks = value;
      }
    }

    public bool IncludeAllReadableWorkspaces
    {
      get
      {
        return _includeAllReadableWorkspaces;
      }
      set
      {
        __isset.includeAllReadableWorkspaces = true;
        this._includeAllReadableWorkspaces = value;
      }
    }

    public string Context
    {
      get
      {
        return _context;
      }
      set
      {
        __isset.context = true;
        this._context = value;
      }
    }

    public string RawWords
    {
      get
      {
        return _rawWords;
      }
      set
      {
        __isset.rawWords = true;
        this._rawWords = value;
      }
    }

    public byte[] SearchContextBytes
    {
      get
      {
        return _searchContextBytes;
      }
      set
      {
        __isset.searchContextBytes = true;
        this._searchContextBytes = value;
      }
    }


    public Isset __isset;
    #if !SILVERLIGHT
    [Serializable]
    #endif
    public struct Isset {
      public bool order;
      public bool @ascending;
      public bool words;
      public bool notebookGuid;
      public bool tagGuids;
      public bool timeZone;
      public bool inactive;
      public bool emphasized;
      public bool includeAllReadableNotebooks;
      public bool includeAllReadableWorkspaces;
      public bool context;
      public bool rawWords;
      public bool searchContextBytes;
    }

    public NoteFilter() {
    }

    public void Read (TProtocol iprot)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        TField field;
        iprot.ReadStructBegin();
        while (true)
        {
          field = iprot.ReadFieldBegin();
          if (field.Type == TType.Stop) { 
            break;
          }
          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32) {
                Order = iprot.ReadI32();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 2:
              if (field.Type == TType.Bool) {
                Ascending = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 3:
              if (field.Type == TType.String) {
                Words = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 4:
              if (field.Type == TType.String) {
                NotebookGuid = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 5:
              if (field.Type == TType.List) {
                {
                  TagGuids = new List<string>();
                  TList _list48 = iprot.ReadListBegin();
                  for( int _i49 = 0; _i49 < _list48.Count; ++_i49)
                  {
                    string _elem50;
                    _elem50 = iprot.ReadString();
                    TagGuids.Add(_elem50);
                  }
                  iprot.ReadListEnd();
                }
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 6:
              if (field.Type == TType.String) {
                TimeZone = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 7:
              if (field.Type == TType.Bool) {
                Inactive = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 8:
              if (field.Type == TType.String) {
                Emphasized = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 9:
              if (field.Type == TType.Bool) {
                IncludeAllReadableNotebooks = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 15:
              if (field.Type == TType.Bool) {
                IncludeAllReadableWorkspaces = iprot.ReadBool();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 10:
              if (field.Type == TType.String) {
                Context = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 11:
              if (field.Type == TType.String) {
                RawWords = iprot.ReadString();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            case 12:
              if (field.Type == TType.String) {
                SearchContextBytes = iprot.ReadBinary();
              } else { 
                TProtocolUtil.Skip(iprot, field.Type);
              }
              break;
            default: 
              TProtocolUtil.Skip(iprot, field.Type);
              break;
          }
          iprot.ReadFieldEnd();
        }
        iprot.ReadStructEnd();
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public void Write(TProtocol oprot) {
      oprot.IncrementRecursionDepth();
      try
      {
        TStruct struc = new TStruct("NoteFilter");
        oprot.WriteStructBegin(struc);
        TField field = new TField();
        if (__isset.order) {
          field.Name = "order";
          field.Type = TType.I32;
          field.ID = 1;
          oprot.WriteFieldBegin(field);
          oprot.WriteI32(Order);
          oprot.WriteFieldEnd();
        }
        if (__isset.@ascending) {
          field.Name = "ascending";
          field.Type = TType.Bool;
          field.ID = 2;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Ascending);
          oprot.WriteFieldEnd();
        }
        if (Words != null && __isset.words) {
          field.Name = "words";
          field.Type = TType.String;
          field.ID = 3;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Words);
          oprot.WriteFieldEnd();
        }
        if (NotebookGuid != null && __isset.notebookGuid) {
          field.Name = "notebookGuid";
          field.Type = TType.String;
          field.ID = 4;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(NotebookGuid);
          oprot.WriteFieldEnd();
        }
        if (TagGuids != null && __isset.tagGuids) {
          field.Name = "tagGuids";
          field.Type = TType.List;
          field.ID = 5;
          oprot.WriteFieldBegin(field);
          {
            oprot.WriteListBegin(new TList(TType.String, TagGuids.Count));
            foreach (string _iter51 in TagGuids)
            {
              oprot.WriteString(_iter51);
            }
            oprot.WriteListEnd();
          }
          oprot.WriteFieldEnd();
        }
        if (TimeZone != null && __isset.timeZone) {
          field.Name = "timeZone";
          field.Type = TType.String;
          field.ID = 6;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(TimeZone);
          oprot.WriteFieldEnd();
        }
        if (__isset.inactive) {
          field.Name = "inactive";
          field.Type = TType.Bool;
          field.ID = 7;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(Inactive);
          oprot.WriteFieldEnd();
        }
        if (Emphasized != null && __isset.emphasized) {
          field.Name = "emphasized";
          field.Type = TType.String;
          field.ID = 8;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Emphasized);
          oprot.WriteFieldEnd();
        }
        if (__isset.includeAllReadableNotebooks) {
          field.Name = "includeAllReadableNotebooks";
          field.Type = TType.Bool;
          field.ID = 9;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(IncludeAllReadableNotebooks);
          oprot.WriteFieldEnd();
        }
        if (Context != null && __isset.context) {
          field.Name = "context";
          field.Type = TType.String;
          field.ID = 10;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(Context);
          oprot.WriteFieldEnd();
        }
        if (RawWords != null && __isset.rawWords) {
          field.Name = "rawWords";
          field.Type = TType.String;
          field.ID = 11;
          oprot.WriteFieldBegin(field);
          oprot.WriteString(RawWords);
          oprot.WriteFieldEnd();
        }
        if (SearchContextBytes != null && __isset.searchContextBytes) {
          field.Name = "searchContextBytes";
          field.Type = TType.String;
          field.ID = 12;
          oprot.WriteFieldBegin(field);
          oprot.WriteBinary(SearchContextBytes);
          oprot.WriteFieldEnd();
        }
        if (__isset.includeAllReadableWorkspaces) {
          field.Name = "includeAllReadableWorkspaces";
          field.Type = TType.Bool;
          field.ID = 15;
          oprot.WriteFieldBegin(field);
          oprot.WriteBool(IncludeAllReadableWorkspaces);
          oprot.WriteFieldEnd();
        }
        oprot.WriteFieldStop();
        oprot.WriteStructEnd();
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override string ToString() {
      StringBuilder __sb = new StringBuilder("NoteFilter(");
      bool __first = true;
      if (__isset.order) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Order: ");
        __sb.Append(Order);
      }
      if (__isset.@ascending) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Ascending: ");
        __sb.Append(Ascending);
      }
      if (Words != null && __isset.words) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Words: ");
        __sb.Append(Words);
      }
      if (NotebookGuid != null && __isset.notebookGuid) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("NotebookGuid: ");
        __sb.Append(NotebookGuid);
      }
      if (TagGuids != null && __isset.tagGuids) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("TagGuids: ");
        __sb.Append(TagGuids);
      }
      if (TimeZone != null && __isset.timeZone) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("TimeZone: ");
        __sb.Append(TimeZone);
      }
      if (__isset.inactive) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Inactive: ");
        __sb.Append(Inactive);
      }
      if (Emphasized != null && __isset.emphasized) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Emphasized: ");
        __sb.Append(Emphasized);
      }
      if (__isset.includeAllReadableNotebooks) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("IncludeAllReadableNotebooks: ");
        __sb.Append(IncludeAllReadableNotebooks);
      }
      if (__isset.includeAllReadableWorkspaces) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("IncludeAllReadableWorkspaces: ");
        __sb.Append(IncludeAllReadableWorkspaces);
      }
      if (Context != null && __isset.context) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("Context: ");
        __sb.Append(Context);
      }
      if (RawWords != null && __isset.rawWords) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("RawWords: ");
        __sb.Append(RawWords);
      }
      if (SearchContextBytes != null && __isset.searchContextBytes) {
        if(!__first) { __sb.Append(", "); }
        __first = false;
        __sb.Append("SearchContextBytes: ");
        __sb.Append(SearchContextBytes);
      }
      __sb.Append(")");
      return __sb.ToString();
    }

  }

}
