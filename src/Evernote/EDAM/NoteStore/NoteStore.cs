/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Evernote.EDAM.NoteStore
{
  public partial class NoteStore {
    /// <summary>
    /// Service:  NoteStore
    /// <p>
    /// The NoteStore service is used by EDAM clients to exchange information
    /// about the collection of notes in an account. This is primarily used for
    /// synchronization, but could also be used by a "thin" client without a full
    /// local cache.
    /// </p><p>
    /// Most functions take an "authenticationToken" parameter, which is the
    /// value returned by the UserStore which permits access to the account.
    /// </p>
    /// 
    /// Calls which require an authenticationToken may throw an EDAMUserException
    /// for the following reasons:
    ///  <ul>
    ///   <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
    ///   <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
    ///   <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
    ///   <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
    ///   <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
    ///       to perform the requested action</li>
    ///   <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
    ///       that requires single sign-on, and must complete SSO before accessing business
    ///       content.
    /// </ul>
    /// </summary>
    public interface ISync {
      /// <summary>
      /// Asks the NoteStore to provide information about the status of the user
      /// account corresponding to the provided authentication token.
      /// </summary>
      /// <param name="authenticationToken"></param>
      SyncState getSyncState(string authenticationToken);
      /// <summary>
      /// Asks the NoteStore to provide the state of the account in order of
      /// last modification.  This request retrieves one block of the server's
      /// state so that a client can make several small requests against a large
      /// account rather than getting the entire state in one big message.
      /// This call gives fine-grained control of the data that will
      /// be received by a client by omitting data elements that a client doesn't
      /// need. This may reduce network traffic and sync times.
      /// 
      /// @param afterUSN
      ///   The client can pass this value to ask only for objects that
      ///   have been updated after a certain point.  This allows the client to
      ///   receive updates after its last checkpoint rather than doing a full
      ///   synchronization on every pass.  The default value of "0" indicates
      ///   that the client wants to get objects from the start of the account.
      /// 
      /// @param maxEntries
      ///   The maximum number of modified objects that should be
      ///   returned in the result SyncChunk.  This can be used to limit the size
      ///   of each individual message to be friendly for network transfer.
      /// 
      /// @param filter
      ///   The caller must set some of the flags in this structure to specify which
      ///   data types should be returned during the synchronization.  See
      ///   the SyncChunkFilter structure for information on each flag.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="afterUSN"></param>
      /// <param name="maxEntries"></param>
      /// <param name="filter"></param>
      SyncChunk getFilteredSyncChunk(string authenticationToken, int afterUSN, int maxEntries, SyncChunkFilter filter);
      /// <summary>
      /// Asks the NoteStore to provide information about the status of a linked
      /// notebook that has been shared with the caller, or that is public to the
      /// world.
      /// This will return a result that is similar to getSyncState, but may omit
      /// SyncState.uploaded if the caller doesn't have permission to write to
      /// the linked notebook.
      /// 
      /// This function must be called on the shard that owns the referenced
      /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
      /// same as LinkedNotebook.shardId.)
      /// 
      /// @param authenticationToken
      ///   This should be an authenticationToken for the guest who has received
      ///   the invitation to the share.  (I.e. this should not be the result of
      ///   NoteStore.authenticateToSharedNotebook)
      /// 
      /// @param linkedNotebook
      ///   This structure should contain identifying information and permissions
      ///   to access the notebook in question.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
      ///       populated with the current username of the owner of the notebook for which
      ///       you are obtaining sync state.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
      ///       correspond to a current user on the service.
      ///   </li>
      /// </ul>
      /// 
      /// @throws SystemException <ul>
      ///   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
      ///       user whose account is on a shard other than that on which this method was
      ///       invoked.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      SyncState getLinkedNotebookSyncState(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook);
      /// <summary>
      /// Asks the NoteStore to provide information about the contents of a linked
      /// notebook that has been shared with the caller, or that is public to the
      /// world.
      /// This will return a result that is similar to getSyncChunk, but will only
      /// contain entries that are visible to the caller.  I.e. only that particular
      /// Notebook will be visible, along with its Notes, and Tags on those Notes.
      /// 
      /// This function must be called on the shard that owns the referenced
      /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
      /// same as LinkedNotebook.shardId.)
      /// 
      /// @param authenticationToken
      ///   This should be an authenticationToken for the guest who has received
      ///   the invitation to the share.  (I.e. this should not be the result of
      ///   NoteStore.authenticateToSharedNotebook)
      /// 
      /// @param linkedNotebook
      ///   This structure should contain identifying information and permissions
      ///   to access the notebook in question.  This must contain the valid fields
      ///   for either a shared notebook (e.g. shareKey)
      ///   or a public notebook (e.g. username, uri)
      /// 
      /// @param afterUSN
      ///   The client can pass this value to ask only for objects that
      ///   have been updated after a certain point.  This allows the client to
      ///   receive updates after its last checkpoint rather than doing a full
      ///   synchronization on every pass.  The default value of "0" indicates
      ///   that the client wants to get objects from the start of the account.
      /// 
      /// @param maxEntries
      ///   The maximum number of modified objects that should be
      ///   returned in the result SyncChunk.  This can be used to limit the size
      ///   of each individual message to be friendly for network transfer.
      ///   Applications should not request more than 256 objects at a time,
      ///   and must handle the case where the service returns less than the
      ///   requested number of objects in a given request even though more
      ///   objects are available on the service.
      /// 
      /// @param fullSyncOnly
      ///   If true, then the client only wants initial data for a full sync.
      ///   In this case, the service will not return any expunged objects,
      ///   and will not return any Resources, since these are also provided
      ///   in their corresponding Notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "LinkedNotebook" - if the provided information doesn't match any
      ///     valid notebook
      ///   </li>
      ///   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
      ///     valid notebook
      ///   </li>
      ///   <li> "SharedNotebook.id" - if the provided information indicates a
      ///      shared notebook that no longer exists
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      /// <param name="afterUSN"></param>
      /// <param name="maxEntries"></param>
      /// <param name="fullSyncOnly"></param>
      SyncChunk getLinkedNotebookSyncChunk(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook, int afterUSN, int maxEntries, bool fullSyncOnly);
      /// <summary>
      /// Returns a list of all of the notebooks in the account.
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.Notebook> listNotebooks(string authenticationToken);
      /// <summary>
      /// Returns a list of all the notebooks in a business that the user has permission to access,
      /// regardless of whether the user has joined them. This includes notebooks that have been shared
      /// with the entire business as well as notebooks that have been shared directly with the user.
      /// 
      /// @param authenticationToken A business authentication token obtained by calling
      ///   UserStore.authenticateToBusiness.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
      ///     business auth token.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.Notebook> listAccessibleBusinessNotebooks(string authenticationToken);
      /// <summary>
      /// Returns the current state of the notebook with the provided GUID.
      /// The notebook may be active or deleted (but not expunged).
      /// 
      /// @param guid
      ///   The GUID of the notebook to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      Evernote.EDAM.Type.Notebook getNotebook(string authenticationToken, string guid);
      /// <summary>
      /// Returns the notebook that should be used to store new notes in the
      /// user's account when no other notebooks are specified.
      /// </summary>
      /// <param name="authenticationToken"></param>
      Evernote.EDAM.Type.Notebook getDefaultNotebook(string authenticationToken);
      /// <summary>
      /// Asks the service to make a notebook with the provided name.
      /// 
      /// @param notebook
      ///   The desired fields for the notebook must be provided on this
      ///   object.  The name of the notebook must be set, and either the 'active'
      ///   or 'defaultNotebook' fields may be set by the client at creation.
      ///   If a notebook exists in the account with the same name (via
      ///   case-insensitive compare), this will throw an EDAMUserException.
      /// 
      /// @return
      ///   The newly created Notebook.  The server-side GUID will be
      ///   saved in this object's 'guid' field.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
      ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
      ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
      ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
      ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
      ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
      ///        is set to 'true' for a Notebook that is not owned by the user identified by
      ///        the passed authenticationToken.</li>
      ///   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebook"></param>
      Evernote.EDAM.Type.Notebook createNotebook(string authenticationToken, Evernote.EDAM.Type.Notebook notebook);
      /// <summary>
      /// Submits notebook changes to the service. The provided data must include the
      /// notebook's guid field for identification.
      /// <p />
      /// The Notebook will be moved to the specified Workspace, if a non empty
      /// Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
      /// Notebook is in a Workspace, then it will be removed from the Workspace and a full
      /// access SharedNotebook record will be ensured for the caller. If the caller does not
      /// already have a full access share, either the privilege of an existing share will be
      /// upgraded or a new share will be created. It is illegal to set a
      /// Notebook.workspaceGuid on a Workspace backing Notebook.
      /// 
      /// @param notebook
      ///   The notebook object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
      ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
      ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
      ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
      ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
      ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
      ///        is set to 'true' for a Notebook that is not owned by the user identified by
      ///        the passed authenticationToken.</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID</li>
      ///   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
      ///        for the GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebook"></param>
      int updateNotebook(string authenticationToken, Evernote.EDAM.Type.Notebook notebook);
      /// <summary>
      /// Permanently removes the notebook from the user's account.
      /// After this action, the notebook is no longer available for undeletion, etc.
      /// If the notebook contains any Notes, they will be moved to the current
      /// default notebook and moved into the trash (i.e. Note.active=false).
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the notebook to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      ///   </li>
      ///   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      int expungeNotebook(string authenticationToken, string guid);
      /// <summary>
      /// Returns a list of the tags in the account.  Evernote does not support
      /// the undeletion of tags, so this will only include active tags.
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.Tag> listTags(string authenticationToken);
      /// <summary>
      /// Returns a list of the tags that are applied to at least one note within
      /// the provided notebook.  If the notebook is public, the authenticationToken
      /// may be ignored.
      /// 
      /// @param notebookGuid
      ///    the GUID of the notebook to use to find tags
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - notebook not found by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      List<Evernote.EDAM.Type.Tag> listTagsByNotebook(string authenticationToken, string notebookGuid);
      /// <summary>
      /// Returns the current state of the Tag with the provided GUID.
      /// 
      /// @param guid
      ///   The GUID of the tag to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      Evernote.EDAM.Type.Tag getTag(string authenticationToken, string guid);
      /// <summary>
      /// Asks the service to make a tag with a set of information.
      /// 
      /// @param tag
      ///   The desired list of fields for the tag are specified in this
      ///   object.  The caller must specify the tag name, and may provide
      ///   the parentGUID.
      /// 
      /// @return
      ///   The newly created Tag.  The server-side GUID will be
      ///   saved in this object.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.name" - name already in use
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - at max number of tags
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.parentGuid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="tag"></param>
      Evernote.EDAM.Type.Tag createTag(string authenticationToken, Evernote.EDAM.Type.Tag tag);
      /// <summary>
      /// Submits tag changes to the service.  The provided data must include
      /// the tag's guid field for identification.  The service will apply
      /// updates to the following tag fields:  name, parentGuid
      /// 
      /// @param tag
      ///   The tag object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.name" - name already in use
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      ///   <li> "Tag.parentGuid" - parent not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="tag"></param>
      int updateTag(string authenticationToken, Evernote.EDAM.Type.Tag tag);
      /// <summary>
      /// Removes the provided tag from every note that is currently tagged with
      /// this tag.  If this operation is successful, the tag will still be in
      /// the account, but it will not be tagged on any notes.
      /// 
      /// This function is not indended for use by full synchronizing clients, since
      /// it does not provide enough result information to the client to reconcile
      /// the local state without performing a follow-up sync from the service.  This
      /// is intended for "thin clients" that need to efficiently support this as
      /// a UI operation.
      /// 
      /// @param guid
      ///   The GUID of the tag to remove from all notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      void untagAll(string authenticationToken, string guid);
      /// <summary>
      /// Permanently deletes the tag with the provided GUID, if present.
      /// <p/>
      /// NOTE: This function is not generally available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the tag to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      int expungeTag(string authenticationToken, string guid);
      /// <summary>
      /// Returns a list of the searches in the account.  Evernote does not support
      /// the undeletion of searches, so this will only include active searches.
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.SavedSearch> listSearches(string authenticationToken);
      /// <summary>
      /// Returns the current state of the search with the provided GUID.
      /// 
      /// @param guid
      ///   The GUID of the search to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      ///   </li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      Evernote.EDAM.Type.SavedSearch getSearch(string authenticationToken, string guid);
      /// <summary>
      /// Asks the service to make a saved search with a set of information.
      /// 
      /// @param search
      ///   The desired list of fields for the search are specified in this
      ///   object. The caller must specify the name and query for the
      ///   search, and may optionally specify a search scope.
      ///   The SavedSearch.format field is ignored by the service.
      /// 
      /// @return
      ///   The newly created SavedSearch.  The server-side GUID will be
      ///   saved in this object.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      ///   </li>
      ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      ///   </li>
      ///   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="search"></param>
      Evernote.EDAM.Type.SavedSearch createSearch(string authenticationToken, Evernote.EDAM.Type.SavedSearch search);
      /// <summary>
      /// Submits search changes to the service. The provided data must include
      /// the search's guid field for identification. The service will apply
      /// updates to the following search fields: name, query, and scope.
      /// 
      /// @param search
      ///   The search object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      ///   </li>
      ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="search"></param>
      int updateSearch(string authenticationToken, Evernote.EDAM.Type.SavedSearch search);
      /// <summary>
      /// Permanently deletes the saved search with the provided GUID, if present.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the search to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      int expungeSearch(string authenticationToken, string guid);
      /// <summary>
      /// Finds the position of a note within a sorted subset of all of the user's
      /// notes. This may be useful for thin clients that are displaying a paginated
      /// listing of a large account, which need to know where a particular note
      /// sits in the list without retrieving all notes first.
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The list of criteria that will constrain the notes to be returned.
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @return
      ///   If the note with the provided GUID is found within the matching note
      ///   list, this will return the offset of that note within that list (where
      ///   the first offset is 0).  If the note is not found within the set of
      ///   notes, this will return -1.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="guid"></param>
      int findNoteOffset(string authenticationToken, NoteFilter filter, string guid);
      /// <summary>
      /// Used to find the high-level information about a set of the notes from a
      /// user's account based on various criteria specified via a NoteFilter object.
      /// <p/>
      /// Web applications that wish to periodically check for new content in a user's
      /// Evernote account should consider using webhooks instead of polling this API.
      /// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
      /// for more information.
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The list of criteria that will constrain the notes to be returned.
      /// 
      /// @param offset
      ///   The numeric index of the first note to show within the sorted
      ///   results.  The numbering scheme starts with "0".  This can be used for
      ///   pagination.
      /// 
      /// @param maxNotes
      ///   The maximum notes to return in this query.  The service will return a set
      ///   of notes that is no larger than this number, but may return fewer notes
      ///   if needed.  The NoteList.totalNotes field in the return value will
      ///   indicate whether there are more values available after the returned set.
      ///   Currently, the service will not return more than 250 notes in a single request,
      ///   but this number may change in the future.
      /// 
      /// @param resultSpec
      ///   This specifies which information should be returned for each matching
      ///   Note. The fields on this structure can be used to eliminate data that
      ///   the client doesn't need, which will reduce the time and bandwidth
      ///   to receive and process the reply.
      /// 
      /// @return
      ///   The list of notes that match the criteria.
      ///   The Notes.sharedNotes field will not be set.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="offset"></param>
      /// <param name="maxNotes"></param>
      /// <param name="resultSpec"></param>
      NotesMetadataList findNotesMetadata(string authenticationToken, NoteFilter filter, int offset, int maxNotes, NotesMetadataResultSpec resultSpec);
      /// <summary>
      /// This function is used to determine how many notes are found for each
      /// notebook and tag in the user's account, given a current set of filter
      /// parameters that determine the current selection.  This function will
      /// return a structure that gives the note count for each notebook and tag
      /// that has at least one note under the requested filter.  Any notebook or
      /// tag that has zero notes in the filtered set will not be listed in the
      /// reply to this function (so they can be assumed to be 0).
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The note selection filter that is currently being applied.  The note
      ///   counts are to be calculated with this filter applied to the total set
      ///   of notes in the user's account.
      /// 
      /// @param withTrash
      ///   If true, then the NoteCollectionCounts.trashCount will be calculated
      ///   and supplied in the reply. Otherwise, the trash value will be omitted.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="withTrash"></param>
      NoteCollectionCounts findNoteCounts(string authenticationToken, NoteFilter filter, bool withTrash);
      /// <summary>
      /// Returns the current state of the note in the service with the provided
      /// GUID.  The ENML contents of the note will only be provided if the
      /// 'withContent' parameter is true.  The service will include the meta-data
      /// for each resource in the note, but the binary content depends
      /// on whether it is explicitly requested in resultSpec parameter.
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).  The applicationData
      /// fields are returned as keysOnly.
      /// 
      /// @param authenticationToken
      ///   An authentication token that grants the caller access to the requested note.
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param resultSpec
      ///   A structure specifying the fields of the note that the caller would like to get.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="resultSpec"></param>
      Evernote.EDAM.Type.Note getNoteWithResultSpec(string authenticationToken, string guid, NoteResultSpec resultSpec);
      /// <summary>
      /// DEPRECATED. See getNoteWithResultSpec.
      /// 
      /// This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
      /// mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
      /// populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="withContent"></param>
      /// <param name="withResourcesData"></param>
      /// <param name="withResourcesRecognition"></param>
      /// <param name="withResourcesAlternateData"></param>
      Evernote.EDAM.Type.Note getNote(string authenticationToken, string guid, bool withContent, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData);
      /// <summary>
      /// Get all of the application data for the note identified by GUID,
      /// with values returned within the LazyMap fullMap field.
      /// If there are no applicationData entries, then a LazyMap
      /// with an empty fullMap will be returned. If your application
      /// only needs to fetch its own applicationData entry, use
      /// getNoteApplicationDataEntry instead.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      Evernote.EDAM.Type.LazyMap getNoteApplicationData(string authenticationToken, string guid);
      /// <summary>
      /// Get the value of a single entry in the applicationData map
      /// for the note identified by GUID.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - note not found, by GUID</li>
      ///   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      string getNoteApplicationDataEntry(string authenticationToken, string guid, string key);
      /// <summary>
      /// Update, or create, an entry in the applicationData map for
      /// the note identified by guid.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      /// <param name="value"></param>
      int setNoteApplicationDataEntry(string authenticationToken, string guid, string key, string @value);
      /// <summary>
      /// Remove an entry identified by 'key' from the applicationData map for
      /// the note identified by 'guid'. Silently ignores an unset of a
      /// non-existing key.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      int unsetNoteApplicationDataEntry(string authenticationToken, string guid, string key);
      /// <summary>
      /// Returns XHTML contents of the note with the provided GUID.
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      string getNoteContent(string authenticationToken, string guid);
      /// <summary>
      /// Returns a block of the extracted plain text contents of the note with the
      /// provided GUID.  This text can be indexed for search purposes by a light
      /// client that doesn't have capabilities to extract all of the searchable
      /// text content from the note and its resources.
      /// 
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param noteOnly
      ///   If true, this will only return the text extracted from the ENML contents
      ///   of the note itself.  If false, this will also include the extracted text
      ///   from any text-bearing resources (PDF, recognized images)
      /// 
      /// @param tokenizeForIndexing
      ///   If true, this will break the text into cleanly separated and sanitized
      ///   tokens.  If false, this will return the more raw text extraction, with
      ///   its original punctuation, capitalization, spacing, etc.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="noteOnly"></param>
      /// <param name="tokenizeForIndexing"></param>
      string getNoteSearchText(string authenticationToken, string guid, bool noteOnly, bool tokenizeForIndexing);
      /// <summary>
      /// Returns a block of the extracted plain text contents of the resource with
      /// the provided GUID.  This text can be indexed for search purposes by a light
      /// client that doesn't have capability to extract all of the searchable
      /// text content from a resource.
      /// 
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      string getResourceSearchText(string authenticationToken, string guid);
      /// <summary>
      /// Returns a list of the names of the tags for the note with the provided
      /// guid.  This can be used with authentication to get the tags for a
      /// user's own note, or can be used without valid authentication to retrieve
      /// the names of the tags for a note in a public notebook.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      List<string> getNoteTagNames(string authenticationToken, string guid);
      /// <summary>
      /// Asks the service to make a note with the provided set of information.
      /// 
      /// @param note
      ///   A Note object containing the desired fields to be populated on
      ///   the service.
      /// 
      /// @return
      ///   The newly created Note from the service.  The server-side
      ///   GUIDs for the Note and any Resources will be saved in this object.
      ///   The service will include the meta-data
      ///   for each resource in the note, but the binary contents of the resources
      ///   and their recognition data will be omitted (except Recognition Resource body,
      ///   for which the behavior is unspecified).
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      ///   </li>
      ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> LIMIT_REACHED "Note" - at max number per account
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.size" - total note size too large
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
      ///   </li>
      ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
      ///     of the specified tags had an invalid length or pattern
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
      ///     new tags would exceed the maximum number per account
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.notebookGuid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      Evernote.EDAM.Type.Note createNote(string authenticationToken, Evernote.EDAM.Type.Note note);
      /// <summary>
      /// Submit a set of changes to a note to the service.  The provided data
      /// must include the note's guid field for identification. The note's
      /// title must also be set.
      /// 
      /// @param note
      ///   A Note object containing the desired fields to be populated on
      ///   the service. With the exception of the note's title and guid, fields
      ///   that are not being changed do not need to be set. If the content is not
      ///   being modified, note.content should be left unset. If the list of
      ///   resources is not being modified, note.resources should be left unset.
      /// 
      /// @return
      ///   The Note.sharedNotes field will not be set.
      ///   The service will include the meta-data
      ///   for each resource in the note, but the binary contents of the resources
      ///   and their recognition data will be omitted.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      ///   </li>
      ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.size" - total note size too large
      ///   </li>
      ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
      ///   </li>
      ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      ///   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
      ///     modify the note's tags. note.tags must be unset.
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
      ///     to modify the note's attributes. note.attributes must be unset.
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
      ///     of the specified tags had an invalid length or pattern
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
      ///     new tags would exceed the maximum number per account
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - note not found, by GUID
      ///   </li>
      ///   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      Evernote.EDAM.Type.Note updateNote(string authenticationToken, Evernote.EDAM.Type.Note note);
      /// <summary>
      /// Moves the note into the trash. The note may still be undeleted, unless it
      /// is expunged.  This is equivalent to calling updateNote() after setting
      /// Note.active = false
      /// 
      /// @param guid
      ///   The GUID of the note to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
      ///          update the note.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      ///   </li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      int deleteNote(string authenticationToken, string guid);
      /// <summary>
      /// Permanently removes a Note, and all of its Resources,
      /// from the service.
      /// <p/>
      /// NOTE: This function is not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the note to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      int expungeNote(string authenticationToken, string guid);
      /// <summary>
      /// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
      /// the Notebook with the provided GUID 'toNotebookGuid'.
      /// The caller must be the owner of both the Note and the Notebook.
      /// This creates a new Note in the destination Notebook with new content and
      /// Resources that match all of the content and Resources from the original
      /// Note, but with new GUID identifiers.
      /// The original Note is not modified by this operation.
      /// The copied note is considered as an "upload" for the purpose of upload
      /// transfer limit calculation, so its size is added to the upload count for
      /// the owner.
      /// 
      /// If the original note has been shared and has SharedNote records, the shares
      /// are NOT copied.
      /// 
      /// @param noteGuid
      ///   The GUID of the Note to copy.
      /// 
      /// @param toNotebookGuid
      ///   The GUID of the Notebook that should receive the new Note.
      /// 
      /// @return
      ///   The metadata for the new Note that was created.  This will include the
      ///   new GUID for this Note (and any copied Resources), but will not include
      ///   the content body or the binary bodies of any Resources.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> LIMIT_REACHED "Note" - at max number per account
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't own
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="toNotebookGuid"></param>
      Evernote.EDAM.Type.Note copyNote(string authenticationToken, string noteGuid, string toNotebookGuid);
      /// <summary>
      /// Returns a list of the prior versions of a particular note that are
      /// saved within the service.  These prior versions are stored to provide a
      /// recovery from unintentional removal of content from a note. The identifiers
      /// that are returned by this call can be used with getNoteVersion to retrieve
      /// the previous note.
      /// The identifiers will be listed from the most recent versions to the oldest.
      /// This call is only available for notes in Premium accounts. (I.e. access
      /// to past versions of Notes is a Premium-only feature.)
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      List<NoteVersionId> listNoteVersions(string authenticationToken, string noteGuid);
      /// <summary>
      /// This can be used to retrieve a previous version of a Note after it has been
      /// updated within the service.  The caller must identify the note (via its
      /// guid) and the version (via the updateSequenceNumber of that version).
      /// to find a listing of the stored version USNs for a note, call
      /// listNoteVersions.
      /// This call is only available for notes in Premium accounts. (I.e. access
      /// to past versions of Notes is a Premium-only feature.)
      /// 
      /// @param noteGuid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param updateSequenceNum
      ///   The USN of the version of the note that is being retrieved
      /// 
      /// @param withResourcesData
      ///   If true, any Resource elements in this Note will include the binary
      ///   contents of their 'data' field's body.
      /// 
      /// @param withResourcesRecognition
      ///   If true, any Resource elements will include the binary contents of the
      ///   'recognition' field's body if recognition data is present.
      /// 
      /// @param withResourcesAlternateData
      ///   If true, any Resource elements in this Note will include the binary
      ///   contents of their 'alternateData' fields' body, if an alternate form
      ///   is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID.
      ///   </li>
      ///   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
      ///      the corresponding USN.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="updateSequenceNum"></param>
      /// <param name="withResourcesData"></param>
      /// <param name="withResourcesRecognition"></param>
      /// <param name="withResourcesAlternateData"></param>
      Evernote.EDAM.Type.Note getNoteVersion(string authenticationToken, string noteGuid, int updateSequenceNum, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData);
      /// <summary>
      /// Returns the current state of the resource in the service with the
      /// provided GUID.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).  Only the
      /// keys for the applicationData will be returned.
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @param withData
      ///   If true, the Resource will include the binary contents of the
      ///   'data' field's body.
      /// 
      /// @param withRecognition
      ///   If true, the Resource will include the binary contents of the
      ///   'recognition' field's body if recognition data is present.
      /// 
      /// @param withAttributes
      ///   If true, the Resource will include the attributes
      /// 
      /// @param withAlternateData
      ///   If true, the Resource will include the binary contents of the
      ///   'alternateData' field's body, if an alternate form is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="withData"></param>
      /// <param name="withRecognition"></param>
      /// <param name="withAttributes"></param>
      /// <param name="withAlternateData"></param>
      Evernote.EDAM.Type.Resource getResource(string authenticationToken, string guid, bool withData, bool withRecognition, bool withAttributes, bool withAlternateData);
      /// <summary>
      /// Get all of the application data for the Resource identified by GUID,
      /// with values returned within the LazyMap fullMap field.
      /// If there are no applicationData entries, then a LazyMap
      /// with an empty fullMap will be returned. If your application
      /// only needs to fetch its own applicationData entry, use
      /// getResourceApplicationDataEntry instead.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      Evernote.EDAM.Type.LazyMap getResourceApplicationData(string authenticationToken, string guid);
      /// <summary>
      /// Get the value of a single entry in the applicationData map
      /// for the Resource identified by GUID.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - Resource not found, by GUID</li>
      ///   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      string getResourceApplicationDataEntry(string authenticationToken, string guid, string key);
      /// <summary>
      /// Update, or create, an entry in the applicationData map for
      /// the Resource identified by guid.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      /// <param name="value"></param>
      int setResourceApplicationDataEntry(string authenticationToken, string guid, string key, string @value);
      /// <summary>
      /// Remove an entry identified by 'key' from the applicationData map for
      /// the Resource identified by 'guid'.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      int unsetResourceApplicationDataEntry(string authenticationToken, string guid, string key);
      /// <summary>
      /// Submit a set of changes to a resource to the service.  This can be used
      /// to update the meta-data about the resource, but cannot be used to change
      /// the binary contents of the resource (including the length and hash).  These
      /// cannot be changed directly without creating a new resource and removing the
      /// old one via updateNote.
      /// 
      /// @param resource
      ///   A Resource object containing the desired fields to be populated on
      ///   the service.  The service will attempt to update the resource with the
      ///   following fields from the client:
      ///   <ul>
      ///      <li>guid:  must be provided to identify the resource
      ///      </li>
      ///      <li>mime
      ///      </li>
      ///      <li>width
      ///      </li>
      ///      <li>height
      ///      </li>
      ///      <li>duration
      ///      </li>
      ///      <li>attributes:  optional.  if present, the set of attributes will
      ///           be replaced.
      ///      </li>
      ///   </ul>
      /// 
      /// @return
      ///   The Update Sequence Number of the resource after the changes have been
      ///   applied.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="resource"></param>
      int updateResource(string authenticationToken, Evernote.EDAM.Type.Resource resource);
      /// <summary>
      /// Returns binary data of the resource with the provided GUID.  For
      /// example, if this were an image resource, this would contain the
      /// raw bits of the image.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      byte[] getResourceData(string authenticationToken, string guid);
      /// <summary>
      /// Returns the current state of a resource, referenced by containing
      /// note GUID and resource content hash.
      /// 
      /// @param noteGuid
      ///   The GUID of the note that holds the resource to be retrieved.
      /// 
      /// @param contentHash
      ///   The MD5 checksum of the resource within that note. Note that
      ///   this is the binary checksum, for example from Resource.data.bodyHash,
      ///   and not the hex-encoded checksum that is used within an en-media
      ///   tag in a note body.
      /// 
      /// @param withData
      ///   If true, the Resource will include the binary contents of the
      ///   'data' field's body.
      /// 
      /// @param withRecognition
      ///   If true, the Resource will include the binary contents of the
      ///   'recognition' field's body.
      /// 
      /// @param withAlternateData
      ///   If true, the Resource will include the binary contents of the
      ///   'alternateData' field's body, if an alternate form is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note" - not found, by guid
      ///   </li>
      ///   <li> "Resource" - not found, by hash
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="contentHash"></param>
      /// <param name="withData"></param>
      /// <param name="withRecognition"></param>
      /// <param name="withAlternateData"></param>
      Evernote.EDAM.Type.Resource getResourceByHash(string authenticationToken, string noteGuid, byte[] contentHash, bool withData, bool withRecognition, bool withAlternateData);
      /// <summary>
      /// Returns the binary contents of the recognition index for the resource
      /// with the provided GUID.  If the caller asks about a resource that has
      /// no recognition data, this will throw EDAMNotFoundException.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource whose recognition data should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Resource.recognition" - resource has no recognition
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      byte[] getResourceRecognition(string authenticationToken, string guid);
      /// <summary>
      /// If the Resource with the provided GUID has an alternate data representation
      /// (indicated via the Resource.alternateData field), then this request can
      /// be used to retrieve the binary contents of that alternate data file.
      /// If the caller asks about a resource that has no alternate data form, this
      /// will throw EDAMNotFoundException.
      /// 
      /// @param guid
      ///    The GUID of the resource whose recognition data should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Resource.alternateData" - resource has no recognition
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      byte[] getResourceAlternateData(string authenticationToken, string guid);
      /// <summary>
      /// Returns the set of attributes for the Resource with the provided GUID.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource whose attributes should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      Evernote.EDAM.Type.ResourceAttributes getResourceAttributes(string authenticationToken, string guid);
      /// <summary>
      /// <p>
      /// Looks for a user account with the provided userId on this NoteStore
      /// shard and determines whether that account contains a public notebook
      /// with the given URI.  If the account is not found, or no public notebook
      /// exists with this URI, this will throw an EDAMNotFoundException,
      /// otherwise this will return the information for that Notebook.
      /// </p>
      /// <p>
      /// If a notebook is visible on the web with a full URL like
      /// http://www.evernote.com/pub/sethdemo/api
      /// Then 'sethdemo' is the username that can be used to look up the userId,
      /// and 'api' is the publicUri.
      /// </p>
      /// 
      /// @param userId
      ///    The numeric identifier for the user who owns the public notebook.
      ///    To find this value based on a username string, you can invoke
      ///    UserStore.getPublicUserInfo
      /// 
      /// @param publicUri
      ///    The uri string for the public notebook, from Notebook.publishing.uri.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Publishing.uri" - not found, by URI</li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
      ///     taken down (for all requesters).</li>
      ///   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
      ///     down for the requester because of an IP-based country lookup.</li>
      /// </ul>
      /// </summary>
      /// <param name="userId"></param>
      /// <param name="publicUri"></param>
      Evernote.EDAM.Type.Notebook getPublicNotebook(int userId, string publicUri);
      /// <summary>
      /// * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
      /// *
      /// * Share a notebook with an email address, and optionally to a specific
      /// * recipient. If an existing SharedNotebook associated with
      /// * sharedNotebook.notebookGuid is found by recipientUsername or email, then
      /// * the values of sharedNotebook will be used to update the existing record,
      /// * else a new record will be created.
      /// *
      /// * If recipientUsername is set and there is already a SharedNotebook
      /// * for that Notebook with that recipientUsername and the privileges on the
      /// * existing notebook are lower, than on this one, this will update the
      /// * privileges and sharerUserId. If there isn't an existing SharedNotebook for
      /// * recipientUsername, this will create and return a shared notebook for that
      /// * email and recipientUsername. If recipientUsername is not set and there
      /// * already is a SharedNotebook for a Notebook for that email address and the
      /// * privileges on the existing SharedNotebook are lower than on this one, this
      /// * will update the privileges and sharerUserId, and return the updated
      /// * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
      /// * the email address.
      /// *
      /// * If the authenticationToken is a Business auth token, recipientUsername is
      /// * set and the recipient is in the same business as the business auth token,
      /// * this method will also auto-join the business user to the SharedNotebook -
      /// * that is it will set serviceJoined on the SharedNotebook and create a
      /// * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
      /// * The LinkedNotebook creation happens out-of-band, so there will be a delay
      /// * on the order of half a minute between the SharedNotebook and LinkedNotebook
      /// * creation.
      /// *
      /// * Also handles sending an email to the email addresses: if a SharedNotebook
      /// * is being created, this will send the shared notebook invite email, and
      /// * if a SharedNotebook already exists, it will send the shared notebook
      /// * reminder email. Both these emails contain a link to join the notebook.
      /// * If the notebook is being auto-joined, it sends an email with that
      /// * information to the recipient.
      /// *
      /// * @param authenticationToken
      /// *   Must be an authentication token from the owner or a shared notebook
      /// *   authentication token or business authentication token with sufficient
      /// *   permissions to change invitations for a notebook.
      /// *
      /// * @param sharedNotebook
      /// *   A shared notebook object populated with the email address of the share
      /// *   recipient, the notebook guid and the access permissions. All other
      /// *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
      /// *   field must be explicitly set with either a true or false value.
      /// *
      /// * @param message
      /// *   The sharer-defined message to put in the email sent out.
      /// *
      /// * @return
      /// *   The fully populated SharedNotebook object including the server assigned
      /// *   globalId which can both be used to uniquely identify the SharedNotebook.
      /// *
      /// * @throws EDAMUserException <ul>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
      /// *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
      /// *       SharedNotebook.privilegeLevel was not set.</li>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
      /// *       set. requireLogin is deprecated.</li>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
      /// *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
      /// *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
      ///         owner's account is not confirmed.</li>
      /// *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
      /// *       recipientSettings is set in the sharedNotebook.  Only the recipient
      /// *       can set these values via the setSharedNotebookRecipientSettings
      /// *       method.</li>
      /// *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
      /// *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
      /// *   </ul>
      /// * @throws EDAMNotFoundException <ul>
      /// *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
      /// *   </li>
      /// *   </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="sharedNotebook"></param>
      /// <param name="message"></param>
      Evernote.EDAM.Type.SharedNotebook shareNotebook(string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook, string message);
      /// <summary>
      /// Share a notebook by a messaging thread ID or a list of contacts. This function is
      /// intended to be used in conjunction with Evernote messaging, and as such does not
      /// notify the recipient that a notebook has been shared with them.
      /// 
      /// Sharing with a subset of participants on a thread is accomplished by specifying both
      /// a thread ID and a list of contacts. This ensures that even if those contacts are
      /// on the thread under a deactivated identity, the correct user (the one who has the
      /// given contact on the thread) receives the share.
      /// 
      /// @param authenticationToken
      ///   An authentication token that grants the caller permission to share the notebook.
      ///   This should be an owner token if the notebook is owned by the caller.
      ///   If the notebook is a business notebook to which the caller has full access,
      ///   this should be their business authentication token. If the notebook is a shared
      ///   (non-business) notebook to which the caller has full access, this should be the
      ///   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
      /// 
      /// @param shareTemplate
      ///   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
      ///   should be shared, and the recipient information.
      /// 
      /// @return
      ///   A structure containing the USN of the Notebook after the change and a list of created
      ///   or updated SharedNotebooks.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
      ///   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
      ///     valid GUID</li>
      ///   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
      ///   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
      ///     specified</li>
      ///   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
      ///     is not allowed.</li>
      ///   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
      ///     specified, either by thread ID or as a list of contacts</li>
      ///   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
      ///     number of shares</li>
      /// </ul>
      /// 
      /// @throws EDAMInvalidContactsException <ul>
      ///   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
      ///     in shareTemplate.recipients was not syntactically valid, or if attempting to
      ///     share a notebook with an Evernote identity that the sharer does not have a
      ///     connection to. The exception will specify which recipients were invalid.</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
      ///   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
      ///     specified, but no thread with that ID exists</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="shareTemplate"></param>
      CreateOrUpdateNotebookSharesResult createOrUpdateNotebookShares(string authenticationToken, NotebookShareTemplate shareTemplate);
      /// <summary>
      /// @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="sharedNotebook"></param>
      int updateSharedNotebook(string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook);
      /// <summary>
      /// Set values for the recipient settings associated with a notebook share. Only the
      /// recipient of the share can update their recipient settings.
      /// 
      /// If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
      /// you must leave that field unset in recipientSettings.
      /// This method will skip that field for updates and attempt to leave the existing value as
      /// it is.
      /// 
      /// If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
      /// will be either left as null or converted to false (if currently true).
      /// 
      /// To unset a notebook's stack, pass in the empty string for the stack field.
      /// 
      /// @param authenticationToken The owner authentication token for the recipient of the share.
      /// 
      /// @return The updated Notebook with the new recipient settings. Note that some of the
      /// recipient settings may differ from what was requested. Clients should update their state
      /// based on this return value.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
      ///       notebookGuid on the given shard.</li>
      ///   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
      ///       user and is also not published to their business.</li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
      ///       allowed to set recipient settings on the specified notebook.</li>
      ///   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
      ///       is allowed only for notebooks which belong to the same business as the user.</li>
      ///   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
      ///       to false and any of reminder* settings to true.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      /// <param name="recipientSettings"></param>
      Evernote.EDAM.Type.Notebook setNotebookRecipientSettings(string authenticationToken, string notebookGuid, Evernote.EDAM.Type.NotebookRecipientSettings recipientSettings);
      /// <summary>
      /// Lists the collection of shared notebooks for all notebooks in the
      /// users account.
      /// 
      /// @return
      ///  The list of all SharedNotebooks for the user
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.SharedNotebook> listSharedNotebooks(string authenticationToken);
      /// <summary>
      /// Asks the service to make a linked notebook with the provided name, username
      /// of the owner and identifiers provided. A linked notebook can be either a
      /// link to a public notebook or to a private shared notebook.
      /// 
      /// @param linkedNotebook
      ///   The desired fields for the linked notebook must be provided on this
      ///   object.  The name of the linked notebook must be set. Either a username
      ///   uri or a shard id and share key must be provided otherwise a
      ///   EDAMUserException is thrown.
      /// 
      /// @return
      ///   The newly created LinkedNotebook.  The server-side id will be
      ///   saved in this object's 'id' field.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
      ///     if public notebook set but bad uri
      ///   </li>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
      ///     if private notebook but shard id not provided
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
      ///     if a bad global identifer was set on a private notebook
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      Evernote.EDAM.Type.LinkedNotebook createLinkedNotebook(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook);
      /// <summary>
      /// @param linkedNotebook
      ///   Updates the name of a linked notebook.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      int updateLinkedNotebook(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook);
      /// <summary>
      /// Returns a list of linked notebooks
      /// </summary>
      /// <param name="authenticationToken"></param>
      List<Evernote.EDAM.Type.LinkedNotebook> listLinkedNotebooks(string authenticationToken);
      /// <summary>
      /// Permanently expunges the linked notebook from the account.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      ///   from the account.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      int expungeLinkedNotebook(string authenticationToken, string guid);
      /// <summary>
      /// Asks the service to produce an authentication token that can be used to
      /// access the contents of a shared notebook from someone else's account.
      /// This authenticationToken can be used with the various other NoteStore
      /// calls to find and retrieve notes, and if the permissions in the shared
      /// notebook are sufficient, to make changes to the contents of the notebook.
      /// 
      /// @param shareKeyOrGlobalId
      ///   May be one of the following:
      ///   <ul>
      ///     <li>A share key for a shared notebook that was granted to some recipient
      ///         Must be used if you are joining a notebook unless it was shared via
      ///         createOrUpdateNotebookShares. Share keys are delivered out-of-band
      ///         and are generally not available to clients. For security reasons,
      ///         share keys may be invalidated at the discretion of the service.
      ///     </li>
      ///     <li>The shared notebook global identifier. May be used to access a
      ///         notebook that is already joined.
      ///     </li>
      ///     <li>The Notebook GUID. May be used to access a notebook that was already
      ///         joined, or to access a notebook that was shared with the recipient
      ///         via createOrUpdateNotebookShares.
      ///     </li>
      ///   </ul>
      /// 
      /// @param authenticationToken
      ///   If a non-empty string is provided, this is the full user-based
      ///   authentication token that identifies the user who is currently logged in
      ///   and trying to access the shared notebook.
      ///   If this string is empty, the service will attempt to authenticate to the
      ///   shared notebook without any logged in user.
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
      ///   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
      ///          no valid authentication token was provided.
      ///   </li>
      ///   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
      ///          and another username has already been bound to this notebook.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="shareKeyOrGlobalId"></param>
      /// <param name="authenticationToken"></param>
      Evernote.EDAM.UserStore.AuthenticationResult authenticateToSharedNotebook(string shareKeyOrGlobalId, string authenticationToken);
      /// <summary>
      /// This function is used to retrieve extended information about a shared
      /// notebook by a guest who has already authenticated to access that notebook.
      /// This requires an 'authenticationToken' parameter which should be the
      /// resut of a call to authenticateToSharedNotebook(...).
      /// I.e. this is the token that gives access to the particular shared notebook
      /// in someone else's account -- it's not the authenticationToken for the
      /// owner of the notebook itself.
      /// 
      /// @param authenticationToken
      ///   Should be the authentication token retrieved from the reply of
      ///   authenticateToSharedNotebook(), proving access to a particular shared
      ///   notebook.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "authenticationToken" -
      ///          authentication token doesn't correspond to a valid shared notebook
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SharedNotebook.id" - the shared notebook no longer exists
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      Evernote.EDAM.Type.SharedNotebook getSharedNotebookByAuth(string authenticationToken);
      /// <summary>
      /// Attempts to send a single note to one or more email recipients.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param authenticationToken
      ///    The note will be sent as the user logged in via this token, using that
      ///    user's registered email address.  If the authenticated user doesn't
      ///    have permission to read that note, the emailing will fail.
      /// 
      /// @param parameters
      ///    The note must be specified either by GUID (in which case it will be
      ///    sent using the existing data in the service), or else the full Note
      ///    must be passed to this call.  This also specifies the additional
      ///    email fields that will be used in the email.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
      ///     The email can't be sent because this would exceed the user's daily
      ///     email limit.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "(email address)" -
      ///     email address malformed
      ///   </li>
      ///   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
      ///     if there are no To: or Cc: addresses provided.
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.title" -
      ///     if the caller provides a Note parameter with no title
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.content" -
      ///     if the caller provides a Note parameter with no content
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> DATA_REQUIRED "NoteEmailParameters.note" -
      ///     if no guid or note provided
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="parameters"></param>
      void emailNote(string authenticationToken, NoteEmailParameters parameters);
      /// <summary>
      /// If this note is not already shared publicly (via its own direct URL), then this
      /// will start sharing that note.
      /// This will return the secret "Note Key" for this note that
      /// can currently be used in conjunction with the Note's GUID to gain direct
      /// read-only access to the Note.
      /// If the note is already shared, then this won't make any changes to the
      /// note, and the existing "Note Key" will be returned.  The only way to change
      /// the Note Key for an existing note is to stopSharingNote first, and then
      /// call this function.
      /// 
      /// @param guid
      ///   The GUID of the note to be shared.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      string shareNote(string authenticationToken, string guid);
      /// <summary>
      /// If this note is shared publicly then this will stop sharing that note
      /// and invalidate its "Note Key", so any existing URLs to access that Note
      /// will stop working.
      /// 
      /// If the Note is not shared, then this function will do nothing.
      /// 
      /// This function does not remove invididual shares for the note. To remove
      /// individual shares, see stopSharingNoteWithRecipients.
      /// 
      /// @param guid
      ///   The GUID of the note to be un-shared.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Note.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      void stopSharingNote(string authenticationToken, string guid);
      /// <summary>
      /// Asks the service to produce an authentication token that can be used to
      /// access the contents of a single Note which was individually shared
      /// from someone's account.
      /// This authenticationToken can be used with the various other NoteStore
      /// calls to find and retrieve the Note and its directly-referenced children.
      /// 
      /// @param guid
      ///   The GUID identifying this Note on this shard.
      /// 
      /// @param noteKey
      ///   The 'noteKey' identifier from the Note that was originally created via
      ///   a call to shareNote() and then given to a recipient to access.
      /// 
      /// @param authenticationToken
      ///   An optional authenticationToken that identifies the user accessing the
      ///   shared note. This parameter may be required to access some shared notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
      ///     shared, or the noteKey doesn't match the current key for this note
      ///   </li>
      ///   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
      ///     required to access this Note, but either no authentication token or a
      ///     "non-owner" authentication token was provided.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "guid" - the note with that GUID is not found
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
      ///     all requesters).
      ///   </li>
      ///   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
      ///     for the requester because of an IP-based country lookup.
      ///   </ul>
      /// </ul>
      /// </summary>
      /// <param name="guid"></param>
      /// <param name="noteKey"></param>
      /// <param name="authenticationToken"></param>
      Evernote.EDAM.UserStore.AuthenticationResult authenticateToSharedNote(string guid, string noteKey, string authenticationToken);
      /// <summary>
      /// Identify related entities on the service, such as notes,
      /// notebooks, tags and users in a business related to notes or content.
      /// 
      /// @param query
      ///   The information about which we are finding related entities.
      /// 
      /// @param resultSpec
      ///   Allows the client to indicate the type and quantity of
      ///   information to be returned, allowing a saving of time and
      ///   bandwidth.
      /// 
      /// @return
      ///   The result of the query, with information considered
      ///   to likely be relevantly related to the information
      ///   described by the query.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
      ///     a zero-length plain text value.
      ///   </li>
      ///   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
      ///     invalid Note GUID, that is, one that does not match the constraints
      ///     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      ///   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
      ///     the note identified by RelatedQuery.noteGuid.
      ///   </li>
      ///   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
      ///     findExperts in the context of a non business user (i.e. The authenticationToken
      ///     is not a business auth token).
      ///   </li>
      ///   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
      ///     in the result spec.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
      ///     found, if that field has been set in the query.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="query"></param>
      /// <param name="resultSpec"></param>
      RelatedResult findRelated(string authenticationToken, RelatedQuery query, RelatedResultSpec resultSpec);
      /// <summary>
      /// Perform the same operation as updateNote() would provided that the update
      /// sequence number on the parameter Note object matches the current update sequence
      /// number that the service has for the note.  If they do <i>not</i> match, then
      /// <i>no</i> update is performed and the return value will have the current server
      /// state in the note field and updated will be false.  If the update sequence
      /// numbers between the client and server do match, then the note will be updated
      /// and the note field of the return value will be returned as it would be for the
      /// updateNote method.  This method allows you to check for an update to the note
      /// on the service, by another client instance, from when you obtained the
      /// note state as a baseline for your edits and the time when you wish to save your
      /// edits.  If your client can merge the conflict, you can avoid overwriting changes
      /// that were saved to the service by the other client.
      /// 
      /// See the updateNote method for information on the exceptions and parameters for
      /// this method.  The only difference is that you must have an update sequence number
      /// defined on the note parameter (equal to the USN of the note as synched to the
      /// client), and the following additional exceptions might be thrown.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
      ///       not provided.  This includes a value that is set as 0.</li>
      ///   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
      ///       sequence number that is larger than the current server value, which should
      ///       not happen if your client is working correctly.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      UpdateNoteIfUsnMatchesResult updateNoteIfUsnMatches(string authenticationToken, Evernote.EDAM.Type.Note note);
      /// <summary>
      /// Manage invitations and memberships associated with a given notebook.
      /// 
      /// <i>Note:</i> Beta method! This method is currently intended for
      /// limited use by Evernote clients that have discussed using this
      /// routine with the platform team.
      /// 
      /// @param parameters A structure containing all parameters for the updates.
      ///    See the structure documentation for details.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
      ///    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
      ///    shares.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="parameters"></param>
      ManageNotebookSharesResult manageNotebookShares(string authenticationToken, ManageNotebookSharesParameters parameters);
      /// <summary>
      /// Return the share relationships for the given notebook, including
      /// both the invitations and the memberships.
      /// 
      /// <i>Note:</i> Beta method! This method is currently intended for
      /// limited use by Evernote clients that have discussed using this
      /// routine with the platform team.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      ShareRelationships getNotebookShares(string authenticationToken, string notebookGuid);
    }

    /// <summary>
    /// Service:  NoteStore
    /// <p>
    /// The NoteStore service is used by EDAM clients to exchange information
    /// about the collection of notes in an account. This is primarily used for
    /// synchronization, but could also be used by a "thin" client without a full
    /// local cache.
    /// </p><p>
    /// Most functions take an "authenticationToken" parameter, which is the
    /// value returned by the UserStore which permits access to the account.
    /// </p>
    /// 
    /// Calls which require an authenticationToken may throw an EDAMUserException
    /// for the following reasons:
    ///  <ul>
    ///   <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
    ///   <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
    ///   <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
    ///   <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
    ///   <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
    ///       to perform the requested action</li>
    ///   <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
    ///       that requires single sign-on, and must complete SSO before accessing business
    ///       content.
    /// </ul>
    /// </summary>
    public interface Iface : ISync {
      /// <summary>
      /// Asks the NoteStore to provide information about the status of the user
      /// account corresponding to the provided authentication token.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getSyncState(AsyncCallback callback, object state, string authenticationToken);
      SyncState End_getSyncState(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the NoteStore to provide the state of the account in order of
      /// last modification.  This request retrieves one block of the server's
      /// state so that a client can make several small requests against a large
      /// account rather than getting the entire state in one big message.
      /// This call gives fine-grained control of the data that will
      /// be received by a client by omitting data elements that a client doesn't
      /// need. This may reduce network traffic and sync times.
      /// 
      /// @param afterUSN
      ///   The client can pass this value to ask only for objects that
      ///   have been updated after a certain point.  This allows the client to
      ///   receive updates after its last checkpoint rather than doing a full
      ///   synchronization on every pass.  The default value of "0" indicates
      ///   that the client wants to get objects from the start of the account.
      /// 
      /// @param maxEntries
      ///   The maximum number of modified objects that should be
      ///   returned in the result SyncChunk.  This can be used to limit the size
      ///   of each individual message to be friendly for network transfer.
      /// 
      /// @param filter
      ///   The caller must set some of the flags in this structure to specify which
      ///   data types should be returned during the synchronization.  See
      ///   the SyncChunkFilter structure for information on each flag.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="afterUSN"></param>
      /// <param name="maxEntries"></param>
      /// <param name="filter"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getFilteredSyncChunk(AsyncCallback callback, object state, string authenticationToken, int afterUSN, int maxEntries, SyncChunkFilter filter);
      SyncChunk End_getFilteredSyncChunk(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the NoteStore to provide information about the status of a linked
      /// notebook that has been shared with the caller, or that is public to the
      /// world.
      /// This will return a result that is similar to getSyncState, but may omit
      /// SyncState.uploaded if the caller doesn't have permission to write to
      /// the linked notebook.
      /// 
      /// This function must be called on the shard that owns the referenced
      /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
      /// same as LinkedNotebook.shardId.)
      /// 
      /// @param authenticationToken
      ///   This should be an authenticationToken for the guest who has received
      ///   the invitation to the share.  (I.e. this should not be the result of
      ///   NoteStore.authenticateToSharedNotebook)
      /// 
      /// @param linkedNotebook
      ///   This structure should contain identifying information and permissions
      ///   to access the notebook in question.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
      ///       populated with the current username of the owner of the notebook for which
      ///       you are obtaining sync state.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
      ///       correspond to a current user on the service.
      ///   </li>
      /// </ul>
      /// 
      /// @throws SystemException <ul>
      ///   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
      ///       user whose account is on a shard other than that on which this method was
      ///       invoked.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getLinkedNotebookSyncState(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook);
      SyncState End_getLinkedNotebookSyncState(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the NoteStore to provide information about the contents of a linked
      /// notebook that has been shared with the caller, or that is public to the
      /// world.
      /// This will return a result that is similar to getSyncChunk, but will only
      /// contain entries that are visible to the caller.  I.e. only that particular
      /// Notebook will be visible, along with its Notes, and Tags on those Notes.
      /// 
      /// This function must be called on the shard that owns the referenced
      /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
      /// same as LinkedNotebook.shardId.)
      /// 
      /// @param authenticationToken
      ///   This should be an authenticationToken for the guest who has received
      ///   the invitation to the share.  (I.e. this should not be the result of
      ///   NoteStore.authenticateToSharedNotebook)
      /// 
      /// @param linkedNotebook
      ///   This structure should contain identifying information and permissions
      ///   to access the notebook in question.  This must contain the valid fields
      ///   for either a shared notebook (e.g. shareKey)
      ///   or a public notebook (e.g. username, uri)
      /// 
      /// @param afterUSN
      ///   The client can pass this value to ask only for objects that
      ///   have been updated after a certain point.  This allows the client to
      ///   receive updates after its last checkpoint rather than doing a full
      ///   synchronization on every pass.  The default value of "0" indicates
      ///   that the client wants to get objects from the start of the account.
      /// 
      /// @param maxEntries
      ///   The maximum number of modified objects that should be
      ///   returned in the result SyncChunk.  This can be used to limit the size
      ///   of each individual message to be friendly for network transfer.
      ///   Applications should not request more than 256 objects at a time,
      ///   and must handle the case where the service returns less than the
      ///   requested number of objects in a given request even though more
      ///   objects are available on the service.
      /// 
      /// @param fullSyncOnly
      ///   If true, then the client only wants initial data for a full sync.
      ///   In this case, the service will not return any expunged objects,
      ///   and will not return any Resources, since these are also provided
      ///   in their corresponding Notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "LinkedNotebook" - if the provided information doesn't match any
      ///     valid notebook
      ///   </li>
      ///   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
      ///     valid notebook
      ///   </li>
      ///   <li> "SharedNotebook.id" - if the provided information indicates a
      ///      shared notebook that no longer exists
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      /// <param name="afterUSN"></param>
      /// <param name="maxEntries"></param>
      /// <param name="fullSyncOnly"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getLinkedNotebookSyncChunk(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook, int afterUSN, int maxEntries, bool fullSyncOnly);
      SyncChunk End_getLinkedNotebookSyncChunk(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of all of the notebooks in the account.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listNotebooks(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.Notebook> End_listNotebooks(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of all the notebooks in a business that the user has permission to access,
      /// regardless of whether the user has joined them. This includes notebooks that have been shared
      /// with the entire business as well as notebooks that have been shared directly with the user.
      /// 
      /// @param authenticationToken A business authentication token obtained by calling
      ///   UserStore.authenticateToBusiness.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
      ///     business auth token.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listAccessibleBusinessNotebooks(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.Notebook> End_listAccessibleBusinessNotebooks(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the current state of the notebook with the provided GUID.
      /// The notebook may be active or deleted (but not expunged).
      /// 
      /// @param guid
      ///   The GUID of the notebook to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNotebook(AsyncCallback callback, object state, string authenticationToken, string guid);
      Evernote.EDAM.Type.Notebook End_getNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the notebook that should be used to store new notes in the
      /// user's account when no other notebooks are specified.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getDefaultNotebook(AsyncCallback callback, object state, string authenticationToken);
      Evernote.EDAM.Type.Notebook End_getDefaultNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to make a notebook with the provided name.
      /// 
      /// @param notebook
      ///   The desired fields for the notebook must be provided on this
      ///   object.  The name of the notebook must be set, and either the 'active'
      ///   or 'defaultNotebook' fields may be set by the client at creation.
      ///   If a notebook exists in the account with the same name (via
      ///   case-insensitive compare), this will throw an EDAMUserException.
      /// 
      /// @return
      ///   The newly created Notebook.  The server-side GUID will be
      ///   saved in this object's 'guid' field.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
      ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
      ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
      ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
      ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
      ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
      ///        is set to 'true' for a Notebook that is not owned by the user identified by
      ///        the passed authenticationToken.</li>
      ///   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebook"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_createNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Notebook notebook);
      Evernote.EDAM.Type.Notebook End_createNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Submits notebook changes to the service. The provided data must include the
      /// notebook's guid field for identification.
      /// <p />
      /// The Notebook will be moved to the specified Workspace, if a non empty
      /// Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
      /// Notebook is in a Workspace, then it will be removed from the Workspace and a full
      /// access SharedNotebook record will be ensured for the caller. If the caller does not
      /// already have a full access share, either the privilege of an existing share will be
      /// upgraded or a new share will be created. It is illegal to set a
      /// Notebook.workspaceGuid on a Workspace backing Notebook.
      /// 
      /// @param notebook
      ///   The notebook object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
      ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
      ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
      ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
      ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
      ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
      ///        is set to 'true' for a Notebook that is not owned by the user identified by
      ///        the passed authenticationToken.</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID</li>
      ///   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
      ///        for the GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebook"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Notebook notebook);
      int End_updateNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Permanently removes the notebook from the user's account.
      /// After this action, the notebook is no longer available for undeletion, etc.
      /// If the notebook contains any Notes, they will be moved to the current
      /// default notebook and moved into the trash (i.e. Note.active=false).
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the notebook to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      ///   </li>
      ///   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_expungeNotebook(AsyncCallback callback, object state, string authenticationToken, string guid);
      int End_expungeNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of the tags in the account.  Evernote does not support
      /// the undeletion of tags, so this will only include active tags.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listTags(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.Tag> End_listTags(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of the tags that are applied to at least one note within
      /// the provided notebook.  If the notebook is public, the authenticationToken
      /// may be ignored.
      /// 
      /// @param notebookGuid
      ///    the GUID of the notebook to use to find tags
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - notebook not found by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listTagsByNotebook(AsyncCallback callback, object state, string authenticationToken, string notebookGuid);
      List<Evernote.EDAM.Type.Tag> End_listTagsByNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the current state of the Tag with the provided GUID.
      /// 
      /// @param guid
      ///   The GUID of the tag to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getTag(AsyncCallback callback, object state, string authenticationToken, string guid);
      Evernote.EDAM.Type.Tag End_getTag(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to make a tag with a set of information.
      /// 
      /// @param tag
      ///   The desired list of fields for the tag are specified in this
      ///   object.  The caller must specify the tag name, and may provide
      ///   the parentGUID.
      /// 
      /// @return
      ///   The newly created Tag.  The server-side GUID will be
      ///   saved in this object.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.name" - name already in use
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - at max number of tags
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.parentGuid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="tag"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_createTag(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Tag tag);
      Evernote.EDAM.Type.Tag End_createTag(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Submits tag changes to the service.  The provided data must include
      /// the tag's guid field for identification.  The service will apply
      /// updates to the following tag fields:  name, parentGuid
      /// 
      /// @param tag
      ///   The tag object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.name" - name already in use
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      ///   <li> "Tag.parentGuid" - parent not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="tag"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateTag(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Tag tag);
      int End_updateTag(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Removes the provided tag from every note that is currently tagged with
      /// this tag.  If this operation is successful, the tag will still be in
      /// the account, but it will not be tagged on any notes.
      /// 
      /// This function is not indended for use by full synchronizing clients, since
      /// it does not provide enough result information to the client to reconcile
      /// the local state without performing a follow-up sync from the service.  This
      /// is intended for "thin clients" that need to efficiently support this as
      /// a UI operation.
      /// 
      /// @param guid
      ///   The GUID of the tag to remove from all notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_untagAll(AsyncCallback callback, object state, string authenticationToken, string guid);
      void End_untagAll(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Permanently deletes the tag with the provided GUID, if present.
      /// <p/>
      /// NOTE: This function is not generally available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the tag to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_expungeTag(AsyncCallback callback, object state, string authenticationToken, string guid);
      int End_expungeTag(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of the searches in the account.  Evernote does not support
      /// the undeletion of searches, so this will only include active searches.
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listSearches(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.SavedSearch> End_listSearches(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the current state of the search with the provided GUID.
      /// 
      /// @param guid
      ///   The GUID of the search to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      ///   </li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getSearch(AsyncCallback callback, object state, string authenticationToken, string guid);
      Evernote.EDAM.Type.SavedSearch End_getSearch(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to make a saved search with a set of information.
      /// 
      /// @param search
      ///   The desired list of fields for the search are specified in this
      ///   object. The caller must specify the name and query for the
      ///   search, and may optionally specify a search scope.
      ///   The SavedSearch.format field is ignored by the service.
      /// 
      /// @return
      ///   The newly created SavedSearch.  The server-side GUID will be
      ///   saved in this object.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      ///   </li>
      ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      ///   </li>
      ///   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="search"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_createSearch(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SavedSearch search);
      Evernote.EDAM.Type.SavedSearch End_createSearch(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Submits search changes to the service. The provided data must include
      /// the search's guid field for identification. The service will apply
      /// updates to the following search fields: name, query, and scope.
      /// 
      /// @param search
      ///   The search object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      ///   </li>
      ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="search"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateSearch(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SavedSearch search);
      int End_updateSearch(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Permanently deletes the saved search with the provided GUID, if present.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the search to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_expungeSearch(AsyncCallback callback, object state, string authenticationToken, string guid);
      int End_expungeSearch(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Finds the position of a note within a sorted subset of all of the user's
      /// notes. This may be useful for thin clients that are displaying a paginated
      /// listing of a large account, which need to know where a particular note
      /// sits in the list without retrieving all notes first.
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The list of criteria that will constrain the notes to be returned.
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @return
      ///   If the note with the provided GUID is found within the matching note
      ///   list, this will return the offset of that note within that list (where
      ///   the first offset is 0).  If the note is not found within the set of
      ///   notes, this will return -1.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_findNoteOffset(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, string guid);
      int End_findNoteOffset(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Used to find the high-level information about a set of the notes from a
      /// user's account based on various criteria specified via a NoteFilter object.
      /// <p/>
      /// Web applications that wish to periodically check for new content in a user's
      /// Evernote account should consider using webhooks instead of polling this API.
      /// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
      /// for more information.
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The list of criteria that will constrain the notes to be returned.
      /// 
      /// @param offset
      ///   The numeric index of the first note to show within the sorted
      ///   results.  The numbering scheme starts with "0".  This can be used for
      ///   pagination.
      /// 
      /// @param maxNotes
      ///   The maximum notes to return in this query.  The service will return a set
      ///   of notes that is no larger than this number, but may return fewer notes
      ///   if needed.  The NoteList.totalNotes field in the return value will
      ///   indicate whether there are more values available after the returned set.
      ///   Currently, the service will not return more than 250 notes in a single request,
      ///   but this number may change in the future.
      /// 
      /// @param resultSpec
      ///   This specifies which information should be returned for each matching
      ///   Note. The fields on this structure can be used to eliminate data that
      ///   the client doesn't need, which will reduce the time and bandwidth
      ///   to receive and process the reply.
      /// 
      /// @return
      ///   The list of notes that match the criteria.
      ///   The Notes.sharedNotes field will not be set.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="offset"></param>
      /// <param name="maxNotes"></param>
      /// <param name="resultSpec"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_findNotesMetadata(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, int offset, int maxNotes, NotesMetadataResultSpec resultSpec);
      NotesMetadataList End_findNotesMetadata(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// This function is used to determine how many notes are found for each
      /// notebook and tag in the user's account, given a current set of filter
      /// parameters that determine the current selection.  This function will
      /// return a structure that gives the note count for each notebook and tag
      /// that has at least one note under the requested filter.  Any notebook or
      /// tag that has zero notes in the filtered set will not be listed in the
      /// reply to this function (so they can be assumed to be 0).
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The note selection filter that is currently being applied.  The note
      ///   counts are to be calculated with this filter applied to the total set
      ///   of notes in the user's account.
      /// 
      /// @param withTrash
      ///   If true, then the NoteCollectionCounts.trashCount will be calculated
      ///   and supplied in the reply. Otherwise, the trash value will be omitted.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="withTrash"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_findNoteCounts(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, bool withTrash);
      NoteCollectionCounts End_findNoteCounts(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the current state of the note in the service with the provided
      /// GUID.  The ENML contents of the note will only be provided if the
      /// 'withContent' parameter is true.  The service will include the meta-data
      /// for each resource in the note, but the binary content depends
      /// on whether it is explicitly requested in resultSpec parameter.
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).  The applicationData
      /// fields are returned as keysOnly.
      /// 
      /// @param authenticationToken
      ///   An authentication token that grants the caller access to the requested note.
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param resultSpec
      ///   A structure specifying the fields of the note that the caller would like to get.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="resultSpec"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteWithResultSpec(AsyncCallback callback, object state, string authenticationToken, string guid, NoteResultSpec resultSpec);
      Evernote.EDAM.Type.Note End_getNoteWithResultSpec(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// DEPRECATED. See getNoteWithResultSpec.
      /// 
      /// This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
      /// mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
      /// populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="withContent"></param>
      /// <param name="withResourcesData"></param>
      /// <param name="withResourcesRecognition"></param>
      /// <param name="withResourcesAlternateData"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNote(AsyncCallback callback, object state, string authenticationToken, string guid, bool withContent, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData);
      Evernote.EDAM.Type.Note End_getNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all of the application data for the note identified by GUID,
      /// with values returned within the LazyMap fullMap field.
      /// If there are no applicationData entries, then a LazyMap
      /// with an empty fullMap will be returned. If your application
      /// only needs to fetch its own applicationData entry, use
      /// getNoteApplicationDataEntry instead.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteApplicationData(AsyncCallback callback, object state, string authenticationToken, string guid);
      Evernote.EDAM.Type.LazyMap End_getNoteApplicationData(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the value of a single entry in the applicationData map
      /// for the note identified by GUID.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - note not found, by GUID</li>
      ///   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key);
      string End_getNoteApplicationDataEntry(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Update, or create, an entry in the applicationData map for
      /// the note identified by guid.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      /// <param name="value"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_setNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key, string @value);
      int End_setNoteApplicationDataEntry(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Remove an entry identified by 'key' from the applicationData map for
      /// the note identified by 'guid'. Silently ignores an unset of a
      /// non-existing key.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_unsetNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key);
      int End_unsetNoteApplicationDataEntry(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns XHTML contents of the note with the provided GUID.
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteContent(AsyncCallback callback, object state, string authenticationToken, string guid);
      string End_getNoteContent(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a block of the extracted plain text contents of the note with the
      /// provided GUID.  This text can be indexed for search purposes by a light
      /// client that doesn't have capabilities to extract all of the searchable
      /// text content from the note and its resources.
      /// 
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param noteOnly
      ///   If true, this will only return the text extracted from the ENML contents
      ///   of the note itself.  If false, this will also include the extracted text
      ///   from any text-bearing resources (PDF, recognized images)
      /// 
      /// @param tokenizeForIndexing
      ///   If true, this will break the text into cleanly separated and sanitized
      ///   tokens.  If false, this will return the more raw text extraction, with
      ///   its original punctuation, capitalization, spacing, etc.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="noteOnly"></param>
      /// <param name="tokenizeForIndexing"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteSearchText(AsyncCallback callback, object state, string authenticationToken, string guid, bool noteOnly, bool tokenizeForIndexing);
      string End_getNoteSearchText(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a block of the extracted plain text contents of the resource with
      /// the provided GUID.  This text can be indexed for search purposes by a light
      /// client that doesn't have capability to extract all of the searchable
      /// text content from a resource.
      /// 
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceSearchText(AsyncCallback callback, object state, string authenticationToken, string guid);
      string End_getResourceSearchText(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of the names of the tags for the note with the provided
      /// guid.  This can be used with authentication to get the tags for a
      /// user's own note, or can be used without valid authentication to retrieve
      /// the names of the tags for a note in a public notebook.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteTagNames(AsyncCallback callback, object state, string authenticationToken, string guid);
      List<string> End_getNoteTagNames(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to make a note with the provided set of information.
      /// 
      /// @param note
      ///   A Note object containing the desired fields to be populated on
      ///   the service.
      /// 
      /// @return
      ///   The newly created Note from the service.  The server-side
      ///   GUIDs for the Note and any Resources will be saved in this object.
      ///   The service will include the meta-data
      ///   for each resource in the note, but the binary contents of the resources
      ///   and their recognition data will be omitted (except Recognition Resource body,
      ///   for which the behavior is unspecified).
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      ///   </li>
      ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> LIMIT_REACHED "Note" - at max number per account
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.size" - total note size too large
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
      ///   </li>
      ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
      ///     of the specified tags had an invalid length or pattern
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
      ///     new tags would exceed the maximum number per account
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.notebookGuid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_createNote(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note);
      Evernote.EDAM.Type.Note End_createNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Submit a set of changes to a note to the service.  The provided data
      /// must include the note's guid field for identification. The note's
      /// title must also be set.
      /// 
      /// @param note
      ///   A Note object containing the desired fields to be populated on
      ///   the service. With the exception of the note's title and guid, fields
      ///   that are not being changed do not need to be set. If the content is not
      ///   being modified, note.content should be left unset. If the list of
      ///   resources is not being modified, note.resources should be left unset.
      /// 
      /// @return
      ///   The Note.sharedNotes field will not be set.
      ///   The service will include the meta-data
      ///   for each resource in the note, but the binary contents of the resources
      ///   and their recognition data will be omitted.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      ///   </li>
      ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.size" - total note size too large
      ///   </li>
      ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
      ///   </li>
      ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      ///   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
      ///     modify the note's tags. note.tags must be unset.
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
      ///     to modify the note's attributes. note.attributes must be unset.
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
      ///     of the specified tags had an invalid length or pattern
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
      ///     new tags would exceed the maximum number per account
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - note not found, by GUID
      ///   </li>
      ///   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateNote(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note);
      Evernote.EDAM.Type.Note End_updateNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Moves the note into the trash. The note may still be undeleted, unless it
      /// is expunged.  This is equivalent to calling updateNote() after setting
      /// Note.active = false
      /// 
      /// @param guid
      ///   The GUID of the note to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
      ///          update the note.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      ///   </li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_deleteNote(AsyncCallback callback, object state, string authenticationToken, string guid);
      int End_deleteNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Permanently removes a Note, and all of its Resources,
      /// from the service.
      /// <p/>
      /// NOTE: This function is not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the note to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_expungeNote(AsyncCallback callback, object state, string authenticationToken, string guid);
      int End_expungeNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
      /// the Notebook with the provided GUID 'toNotebookGuid'.
      /// The caller must be the owner of both the Note and the Notebook.
      /// This creates a new Note in the destination Notebook with new content and
      /// Resources that match all of the content and Resources from the original
      /// Note, but with new GUID identifiers.
      /// The original Note is not modified by this operation.
      /// The copied note is considered as an "upload" for the purpose of upload
      /// transfer limit calculation, so its size is added to the upload count for
      /// the owner.
      /// 
      /// If the original note has been shared and has SharedNote records, the shares
      /// are NOT copied.
      /// 
      /// @param noteGuid
      ///   The GUID of the Note to copy.
      /// 
      /// @param toNotebookGuid
      ///   The GUID of the Notebook that should receive the new Note.
      /// 
      /// @return
      ///   The metadata for the new Note that was created.  This will include the
      ///   new GUID for this Note (and any copied Resources), but will not include
      ///   the content body or the binary bodies of any Resources.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> LIMIT_REACHED "Note" - at max number per account
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't own
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="toNotebookGuid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_copyNote(AsyncCallback callback, object state, string authenticationToken, string noteGuid, string toNotebookGuid);
      Evernote.EDAM.Type.Note End_copyNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of the prior versions of a particular note that are
      /// saved within the service.  These prior versions are stored to provide a
      /// recovery from unintentional removal of content from a note. The identifiers
      /// that are returned by this call can be used with getNoteVersion to retrieve
      /// the previous note.
      /// The identifiers will be listed from the most recent versions to the oldest.
      /// This call is only available for notes in Premium accounts. (I.e. access
      /// to past versions of Notes is a Premium-only feature.)
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listNoteVersions(AsyncCallback callback, object state, string authenticationToken, string noteGuid);
      List<NoteVersionId> End_listNoteVersions(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// This can be used to retrieve a previous version of a Note after it has been
      /// updated within the service.  The caller must identify the note (via its
      /// guid) and the version (via the updateSequenceNumber of that version).
      /// to find a listing of the stored version USNs for a note, call
      /// listNoteVersions.
      /// This call is only available for notes in Premium accounts. (I.e. access
      /// to past versions of Notes is a Premium-only feature.)
      /// 
      /// @param noteGuid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param updateSequenceNum
      ///   The USN of the version of the note that is being retrieved
      /// 
      /// @param withResourcesData
      ///   If true, any Resource elements in this Note will include the binary
      ///   contents of their 'data' field's body.
      /// 
      /// @param withResourcesRecognition
      ///   If true, any Resource elements will include the binary contents of the
      ///   'recognition' field's body if recognition data is present.
      /// 
      /// @param withResourcesAlternateData
      ///   If true, any Resource elements in this Note will include the binary
      ///   contents of their 'alternateData' fields' body, if an alternate form
      ///   is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID.
      ///   </li>
      ///   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
      ///      the corresponding USN.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="updateSequenceNum"></param>
      /// <param name="withResourcesData"></param>
      /// <param name="withResourcesRecognition"></param>
      /// <param name="withResourcesAlternateData"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNoteVersion(AsyncCallback callback, object state, string authenticationToken, string noteGuid, int updateSequenceNum, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData);
      Evernote.EDAM.Type.Note End_getNoteVersion(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the current state of the resource in the service with the
      /// provided GUID.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).  Only the
      /// keys for the applicationData will be returned.
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @param withData
      ///   If true, the Resource will include the binary contents of the
      ///   'data' field's body.
      /// 
      /// @param withRecognition
      ///   If true, the Resource will include the binary contents of the
      ///   'recognition' field's body if recognition data is present.
      /// 
      /// @param withAttributes
      ///   If true, the Resource will include the attributes
      /// 
      /// @param withAlternateData
      ///   If true, the Resource will include the binary contents of the
      ///   'alternateData' field's body, if an alternate form is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="withData"></param>
      /// <param name="withRecognition"></param>
      /// <param name="withAttributes"></param>
      /// <param name="withAlternateData"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResource(AsyncCallback callback, object state, string authenticationToken, string guid, bool withData, bool withRecognition, bool withAttributes, bool withAlternateData);
      Evernote.EDAM.Type.Resource End_getResource(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get all of the application data for the Resource identified by GUID,
      /// with values returned within the LazyMap fullMap field.
      /// If there are no applicationData entries, then a LazyMap
      /// with an empty fullMap will be returned. If your application
      /// only needs to fetch its own applicationData entry, use
      /// getResourceApplicationDataEntry instead.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceApplicationData(AsyncCallback callback, object state, string authenticationToken, string guid);
      Evernote.EDAM.Type.LazyMap End_getResourceApplicationData(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Get the value of a single entry in the applicationData map
      /// for the Resource identified by GUID.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - Resource not found, by GUID</li>
      ///   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key);
      string End_getResourceApplicationDataEntry(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Update, or create, an entry in the applicationData map for
      /// the Resource identified by guid.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      /// <param name="value"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_setResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key, string @value);
      int End_setResourceApplicationDataEntry(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Remove an entry identified by 'key' from the applicationData map for
      /// the Resource identified by 'guid'.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_unsetResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key);
      int End_unsetResourceApplicationDataEntry(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Submit a set of changes to a resource to the service.  This can be used
      /// to update the meta-data about the resource, but cannot be used to change
      /// the binary contents of the resource (including the length and hash).  These
      /// cannot be changed directly without creating a new resource and removing the
      /// old one via updateNote.
      /// 
      /// @param resource
      ///   A Resource object containing the desired fields to be populated on
      ///   the service.  The service will attempt to update the resource with the
      ///   following fields from the client:
      ///   <ul>
      ///      <li>guid:  must be provided to identify the resource
      ///      </li>
      ///      <li>mime
      ///      </li>
      ///      <li>width
      ///      </li>
      ///      <li>height
      ///      </li>
      ///      <li>duration
      ///      </li>
      ///      <li>attributes:  optional.  if present, the set of attributes will
      ///           be replaced.
      ///      </li>
      ///   </ul>
      /// 
      /// @return
      ///   The Update Sequence Number of the resource after the changes have been
      ///   applied.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="resource"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateResource(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Resource resource);
      int End_updateResource(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns binary data of the resource with the provided GUID.  For
      /// example, if this were an image resource, this would contain the
      /// raw bits of the image.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceData(AsyncCallback callback, object state, string authenticationToken, string guid);
      byte[] End_getResourceData(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the current state of a resource, referenced by containing
      /// note GUID and resource content hash.
      /// 
      /// @param noteGuid
      ///   The GUID of the note that holds the resource to be retrieved.
      /// 
      /// @param contentHash
      ///   The MD5 checksum of the resource within that note. Note that
      ///   this is the binary checksum, for example from Resource.data.bodyHash,
      ///   and not the hex-encoded checksum that is used within an en-media
      ///   tag in a note body.
      /// 
      /// @param withData
      ///   If true, the Resource will include the binary contents of the
      ///   'data' field's body.
      /// 
      /// @param withRecognition
      ///   If true, the Resource will include the binary contents of the
      ///   'recognition' field's body.
      /// 
      /// @param withAlternateData
      ///   If true, the Resource will include the binary contents of the
      ///   'alternateData' field's body, if an alternate form is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note" - not found, by guid
      ///   </li>
      ///   <li> "Resource" - not found, by hash
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="contentHash"></param>
      /// <param name="withData"></param>
      /// <param name="withRecognition"></param>
      /// <param name="withAlternateData"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceByHash(AsyncCallback callback, object state, string authenticationToken, string noteGuid, byte[] contentHash, bool withData, bool withRecognition, bool withAlternateData);
      Evernote.EDAM.Type.Resource End_getResourceByHash(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the binary contents of the recognition index for the resource
      /// with the provided GUID.  If the caller asks about a resource that has
      /// no recognition data, this will throw EDAMNotFoundException.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource whose recognition data should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Resource.recognition" - resource has no recognition
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceRecognition(AsyncCallback callback, object state, string authenticationToken, string guid);
      byte[] End_getResourceRecognition(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// If the Resource with the provided GUID has an alternate data representation
      /// (indicated via the Resource.alternateData field), then this request can
      /// be used to retrieve the binary contents of that alternate data file.
      /// If the caller asks about a resource that has no alternate data form, this
      /// will throw EDAMNotFoundException.
      /// 
      /// @param guid
      ///    The GUID of the resource whose recognition data should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Resource.alternateData" - resource has no recognition
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceAlternateData(AsyncCallback callback, object state, string authenticationToken, string guid);
      byte[] End_getResourceAlternateData(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns the set of attributes for the Resource with the provided GUID.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource whose attributes should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getResourceAttributes(AsyncCallback callback, object state, string authenticationToken, string guid);
      Evernote.EDAM.Type.ResourceAttributes End_getResourceAttributes(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// <p>
      /// Looks for a user account with the provided userId on this NoteStore
      /// shard and determines whether that account contains a public notebook
      /// with the given URI.  If the account is not found, or no public notebook
      /// exists with this URI, this will throw an EDAMNotFoundException,
      /// otherwise this will return the information for that Notebook.
      /// </p>
      /// <p>
      /// If a notebook is visible on the web with a full URL like
      /// http://www.evernote.com/pub/sethdemo/api
      /// Then 'sethdemo' is the username that can be used to look up the userId,
      /// and 'api' is the publicUri.
      /// </p>
      /// 
      /// @param userId
      ///    The numeric identifier for the user who owns the public notebook.
      ///    To find this value based on a username string, you can invoke
      ///    UserStore.getPublicUserInfo
      /// 
      /// @param publicUri
      ///    The uri string for the public notebook, from Notebook.publishing.uri.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Publishing.uri" - not found, by URI</li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
      ///     taken down (for all requesters).</li>
      ///   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
      ///     down for the requester because of an IP-based country lookup.</li>
      /// </ul>
      /// </summary>
      /// <param name="userId"></param>
      /// <param name="publicUri"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getPublicNotebook(AsyncCallback callback, object state, int userId, string publicUri);
      Evernote.EDAM.Type.Notebook End_getPublicNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
      /// *
      /// * Share a notebook with an email address, and optionally to a specific
      /// * recipient. If an existing SharedNotebook associated with
      /// * sharedNotebook.notebookGuid is found by recipientUsername or email, then
      /// * the values of sharedNotebook will be used to update the existing record,
      /// * else a new record will be created.
      /// *
      /// * If recipientUsername is set and there is already a SharedNotebook
      /// * for that Notebook with that recipientUsername and the privileges on the
      /// * existing notebook are lower, than on this one, this will update the
      /// * privileges and sharerUserId. If there isn't an existing SharedNotebook for
      /// * recipientUsername, this will create and return a shared notebook for that
      /// * email and recipientUsername. If recipientUsername is not set and there
      /// * already is a SharedNotebook for a Notebook for that email address and the
      /// * privileges on the existing SharedNotebook are lower than on this one, this
      /// * will update the privileges and sharerUserId, and return the updated
      /// * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
      /// * the email address.
      /// *
      /// * If the authenticationToken is a Business auth token, recipientUsername is
      /// * set and the recipient is in the same business as the business auth token,
      /// * this method will also auto-join the business user to the SharedNotebook -
      /// * that is it will set serviceJoined on the SharedNotebook and create a
      /// * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
      /// * The LinkedNotebook creation happens out-of-band, so there will be a delay
      /// * on the order of half a minute between the SharedNotebook and LinkedNotebook
      /// * creation.
      /// *
      /// * Also handles sending an email to the email addresses: if a SharedNotebook
      /// * is being created, this will send the shared notebook invite email, and
      /// * if a SharedNotebook already exists, it will send the shared notebook
      /// * reminder email. Both these emails contain a link to join the notebook.
      /// * If the notebook is being auto-joined, it sends an email with that
      /// * information to the recipient.
      /// *
      /// * @param authenticationToken
      /// *   Must be an authentication token from the owner or a shared notebook
      /// *   authentication token or business authentication token with sufficient
      /// *   permissions to change invitations for a notebook.
      /// *
      /// * @param sharedNotebook
      /// *   A shared notebook object populated with the email address of the share
      /// *   recipient, the notebook guid and the access permissions. All other
      /// *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
      /// *   field must be explicitly set with either a true or false value.
      /// *
      /// * @param message
      /// *   The sharer-defined message to put in the email sent out.
      /// *
      /// * @return
      /// *   The fully populated SharedNotebook object including the server assigned
      /// *   globalId which can both be used to uniquely identify the SharedNotebook.
      /// *
      /// * @throws EDAMUserException <ul>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
      /// *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
      /// *       SharedNotebook.privilegeLevel was not set.</li>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
      /// *       set. requireLogin is deprecated.</li>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
      /// *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
      /// *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
      ///         owner's account is not confirmed.</li>
      /// *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
      /// *       recipientSettings is set in the sharedNotebook.  Only the recipient
      /// *       can set these values via the setSharedNotebookRecipientSettings
      /// *       method.</li>
      /// *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
      /// *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
      /// *   </ul>
      /// * @throws EDAMNotFoundException <ul>
      /// *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
      /// *   </li>
      /// *   </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="sharedNotebook"></param>
      /// <param name="message"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_shareNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook, string message);
      Evernote.EDAM.Type.SharedNotebook End_shareNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Share a notebook by a messaging thread ID or a list of contacts. This function is
      /// intended to be used in conjunction with Evernote messaging, and as such does not
      /// notify the recipient that a notebook has been shared with them.
      /// 
      /// Sharing with a subset of participants on a thread is accomplished by specifying both
      /// a thread ID and a list of contacts. This ensures that even if those contacts are
      /// on the thread under a deactivated identity, the correct user (the one who has the
      /// given contact on the thread) receives the share.
      /// 
      /// @param authenticationToken
      ///   An authentication token that grants the caller permission to share the notebook.
      ///   This should be an owner token if the notebook is owned by the caller.
      ///   If the notebook is a business notebook to which the caller has full access,
      ///   this should be their business authentication token. If the notebook is a shared
      ///   (non-business) notebook to which the caller has full access, this should be the
      ///   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
      /// 
      /// @param shareTemplate
      ///   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
      ///   should be shared, and the recipient information.
      /// 
      /// @return
      ///   A structure containing the USN of the Notebook after the change and a list of created
      ///   or updated SharedNotebooks.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
      ///   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
      ///     valid GUID</li>
      ///   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
      ///   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
      ///     specified</li>
      ///   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
      ///     is not allowed.</li>
      ///   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
      ///     specified, either by thread ID or as a list of contacts</li>
      ///   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
      ///     number of shares</li>
      /// </ul>
      /// 
      /// @throws EDAMInvalidContactsException <ul>
      ///   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
      ///     in shareTemplate.recipients was not syntactically valid, or if attempting to
      ///     share a notebook with an Evernote identity that the sharer does not have a
      ///     connection to. The exception will specify which recipients were invalid.</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
      ///   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
      ///     specified, but no thread with that ID exists</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="shareTemplate"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_createOrUpdateNotebookShares(AsyncCallback callback, object state, string authenticationToken, NotebookShareTemplate shareTemplate);
      CreateOrUpdateNotebookSharesResult End_createOrUpdateNotebookShares(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="sharedNotebook"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateSharedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook);
      int End_updateSharedNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Set values for the recipient settings associated with a notebook share. Only the
      /// recipient of the share can update their recipient settings.
      /// 
      /// If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
      /// you must leave that field unset in recipientSettings.
      /// This method will skip that field for updates and attempt to leave the existing value as
      /// it is.
      /// 
      /// If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
      /// will be either left as null or converted to false (if currently true).
      /// 
      /// To unset a notebook's stack, pass in the empty string for the stack field.
      /// 
      /// @param authenticationToken The owner authentication token for the recipient of the share.
      /// 
      /// @return The updated Notebook with the new recipient settings. Note that some of the
      /// recipient settings may differ from what was requested. Clients should update their state
      /// based on this return value.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
      ///       notebookGuid on the given shard.</li>
      ///   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
      ///       user and is also not published to their business.</li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
      ///       allowed to set recipient settings on the specified notebook.</li>
      ///   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
      ///       is allowed only for notebooks which belong to the same business as the user.</li>
      ///   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
      ///       to false and any of reminder* settings to true.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      /// <param name="recipientSettings"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_setNotebookRecipientSettings(AsyncCallback callback, object state, string authenticationToken, string notebookGuid, Evernote.EDAM.Type.NotebookRecipientSettings recipientSettings);
      Evernote.EDAM.Type.Notebook End_setNotebookRecipientSettings(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Lists the collection of shared notebooks for all notebooks in the
      /// users account.
      /// 
      /// @return
      ///  The list of all SharedNotebooks for the user
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listSharedNotebooks(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.SharedNotebook> End_listSharedNotebooks(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to make a linked notebook with the provided name, username
      /// of the owner and identifiers provided. A linked notebook can be either a
      /// link to a public notebook or to a private shared notebook.
      /// 
      /// @param linkedNotebook
      ///   The desired fields for the linked notebook must be provided on this
      ///   object.  The name of the linked notebook must be set. Either a username
      ///   uri or a shard id and share key must be provided otherwise a
      ///   EDAMUserException is thrown.
      /// 
      /// @return
      ///   The newly created LinkedNotebook.  The server-side id will be
      ///   saved in this object's 'id' field.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
      ///     if public notebook set but bad uri
      ///   </li>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
      ///     if private notebook but shard id not provided
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
      ///     if a bad global identifer was set on a private notebook
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_createLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook);
      Evernote.EDAM.Type.LinkedNotebook End_createLinkedNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// @param linkedNotebook
      ///   Updates the name of a linked notebook.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook);
      int End_updateLinkedNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Returns a list of linked notebooks
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_listLinkedNotebooks(AsyncCallback callback, object state, string authenticationToken);
      List<Evernote.EDAM.Type.LinkedNotebook> End_listLinkedNotebooks(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Permanently expunges the linked notebook from the account.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      ///   from the account.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_expungeLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, string guid);
      int End_expungeLinkedNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to produce an authentication token that can be used to
      /// access the contents of a shared notebook from someone else's account.
      /// This authenticationToken can be used with the various other NoteStore
      /// calls to find and retrieve notes, and if the permissions in the shared
      /// notebook are sufficient, to make changes to the contents of the notebook.
      /// 
      /// @param shareKeyOrGlobalId
      ///   May be one of the following:
      ///   <ul>
      ///     <li>A share key for a shared notebook that was granted to some recipient
      ///         Must be used if you are joining a notebook unless it was shared via
      ///         createOrUpdateNotebookShares. Share keys are delivered out-of-band
      ///         and are generally not available to clients. For security reasons,
      ///         share keys may be invalidated at the discretion of the service.
      ///     </li>
      ///     <li>The shared notebook global identifier. May be used to access a
      ///         notebook that is already joined.
      ///     </li>
      ///     <li>The Notebook GUID. May be used to access a notebook that was already
      ///         joined, or to access a notebook that was shared with the recipient
      ///         via createOrUpdateNotebookShares.
      ///     </li>
      ///   </ul>
      /// 
      /// @param authenticationToken
      ///   If a non-empty string is provided, this is the full user-based
      ///   authentication token that identifies the user who is currently logged in
      ///   and trying to access the shared notebook.
      ///   If this string is empty, the service will attempt to authenticate to the
      ///   shared notebook without any logged in user.
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
      ///   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
      ///          no valid authentication token was provided.
      ///   </li>
      ///   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
      ///          and another username has already been bound to this notebook.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="shareKeyOrGlobalId"></param>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_authenticateToSharedNotebook(AsyncCallback callback, object state, string shareKeyOrGlobalId, string authenticationToken);
      Evernote.EDAM.UserStore.AuthenticationResult End_authenticateToSharedNotebook(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// This function is used to retrieve extended information about a shared
      /// notebook by a guest who has already authenticated to access that notebook.
      /// This requires an 'authenticationToken' parameter which should be the
      /// resut of a call to authenticateToSharedNotebook(...).
      /// I.e. this is the token that gives access to the particular shared notebook
      /// in someone else's account -- it's not the authenticationToken for the
      /// owner of the notebook itself.
      /// 
      /// @param authenticationToken
      ///   Should be the authentication token retrieved from the reply of
      ///   authenticateToSharedNotebook(), proving access to a particular shared
      ///   notebook.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "authenticationToken" -
      ///          authentication token doesn't correspond to a valid shared notebook
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SharedNotebook.id" - the shared notebook no longer exists
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getSharedNotebookByAuth(AsyncCallback callback, object state, string authenticationToken);
      Evernote.EDAM.Type.SharedNotebook End_getSharedNotebookByAuth(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Attempts to send a single note to one or more email recipients.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param authenticationToken
      ///    The note will be sent as the user logged in via this token, using that
      ///    user's registered email address.  If the authenticated user doesn't
      ///    have permission to read that note, the emailing will fail.
      /// 
      /// @param parameters
      ///    The note must be specified either by GUID (in which case it will be
      ///    sent using the existing data in the service), or else the full Note
      ///    must be passed to this call.  This also specifies the additional
      ///    email fields that will be used in the email.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
      ///     The email can't be sent because this would exceed the user's daily
      ///     email limit.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "(email address)" -
      ///     email address malformed
      ///   </li>
      ///   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
      ///     if there are no To: or Cc: addresses provided.
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.title" -
      ///     if the caller provides a Note parameter with no title
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.content" -
      ///     if the caller provides a Note parameter with no content
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> DATA_REQUIRED "NoteEmailParameters.note" -
      ///     if no guid or note provided
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="parameters"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_emailNote(AsyncCallback callback, object state, string authenticationToken, NoteEmailParameters parameters);
      void End_emailNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// If this note is not already shared publicly (via its own direct URL), then this
      /// will start sharing that note.
      /// This will return the secret "Note Key" for this note that
      /// can currently be used in conjunction with the Note's GUID to gain direct
      /// read-only access to the Note.
      /// If the note is already shared, then this won't make any changes to the
      /// note, and the existing "Note Key" will be returned.  The only way to change
      /// the Note Key for an existing note is to stopSharingNote first, and then
      /// call this function.
      /// 
      /// @param guid
      ///   The GUID of the note to be shared.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_shareNote(AsyncCallback callback, object state, string authenticationToken, string guid);
      string End_shareNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// If this note is shared publicly then this will stop sharing that note
      /// and invalidate its "Note Key", so any existing URLs to access that Note
      /// will stop working.
      /// 
      /// If the Note is not shared, then this function will do nothing.
      /// 
      /// This function does not remove invididual shares for the note. To remove
      /// individual shares, see stopSharingNoteWithRecipients.
      /// 
      /// @param guid
      ///   The GUID of the note to be un-shared.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Note.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_stopSharingNote(AsyncCallback callback, object state, string authenticationToken, string guid);
      void End_stopSharingNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Asks the service to produce an authentication token that can be used to
      /// access the contents of a single Note which was individually shared
      /// from someone's account.
      /// This authenticationToken can be used with the various other NoteStore
      /// calls to find and retrieve the Note and its directly-referenced children.
      /// 
      /// @param guid
      ///   The GUID identifying this Note on this shard.
      /// 
      /// @param noteKey
      ///   The 'noteKey' identifier from the Note that was originally created via
      ///   a call to shareNote() and then given to a recipient to access.
      /// 
      /// @param authenticationToken
      ///   An optional authenticationToken that identifies the user accessing the
      ///   shared note. This parameter may be required to access some shared notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
      ///     shared, or the noteKey doesn't match the current key for this note
      ///   </li>
      ///   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
      ///     required to access this Note, but either no authentication token or a
      ///     "non-owner" authentication token was provided.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "guid" - the note with that GUID is not found
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
      ///     all requesters).
      ///   </li>
      ///   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
      ///     for the requester because of an IP-based country lookup.
      ///   </ul>
      /// </ul>
      /// </summary>
      /// <param name="guid"></param>
      /// <param name="noteKey"></param>
      /// <param name="authenticationToken"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_authenticateToSharedNote(AsyncCallback callback, object state, string guid, string noteKey, string authenticationToken);
      Evernote.EDAM.UserStore.AuthenticationResult End_authenticateToSharedNote(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Identify related entities on the service, such as notes,
      /// notebooks, tags and users in a business related to notes or content.
      /// 
      /// @param query
      ///   The information about which we are finding related entities.
      /// 
      /// @param resultSpec
      ///   Allows the client to indicate the type and quantity of
      ///   information to be returned, allowing a saving of time and
      ///   bandwidth.
      /// 
      /// @return
      ///   The result of the query, with information considered
      ///   to likely be relevantly related to the information
      ///   described by the query.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
      ///     a zero-length plain text value.
      ///   </li>
      ///   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
      ///     invalid Note GUID, that is, one that does not match the constraints
      ///     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      ///   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
      ///     the note identified by RelatedQuery.noteGuid.
      ///   </li>
      ///   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
      ///     findExperts in the context of a non business user (i.e. The authenticationToken
      ///     is not a business auth token).
      ///   </li>
      ///   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
      ///     in the result spec.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
      ///     found, if that field has been set in the query.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="query"></param>
      /// <param name="resultSpec"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_findRelated(AsyncCallback callback, object state, string authenticationToken, RelatedQuery query, RelatedResultSpec resultSpec);
      RelatedResult End_findRelated(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Perform the same operation as updateNote() would provided that the update
      /// sequence number on the parameter Note object matches the current update sequence
      /// number that the service has for the note.  If they do <i>not</i> match, then
      /// <i>no</i> update is performed and the return value will have the current server
      /// state in the note field and updated will be false.  If the update sequence
      /// numbers between the client and server do match, then the note will be updated
      /// and the note field of the return value will be returned as it would be for the
      /// updateNote method.  This method allows you to check for an update to the note
      /// on the service, by another client instance, from when you obtained the
      /// note state as a baseline for your edits and the time when you wish to save your
      /// edits.  If your client can merge the conflict, you can avoid overwriting changes
      /// that were saved to the service by the other client.
      /// 
      /// See the updateNote method for information on the exceptions and parameters for
      /// this method.  The only difference is that you must have an update sequence number
      /// defined on the note parameter (equal to the USN of the note as synched to the
      /// client), and the following additional exceptions might be thrown.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
      ///       not provided.  This includes a value that is set as 0.</li>
      ///   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
      ///       sequence number that is larger than the current server value, which should
      ///       not happen if your client is working correctly.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_updateNoteIfUsnMatches(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note);
      UpdateNoteIfUsnMatchesResult End_updateNoteIfUsnMatches(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Manage invitations and memberships associated with a given notebook.
      /// 
      /// <i>Note:</i> Beta method! This method is currently intended for
      /// limited use by Evernote clients that have discussed using this
      /// routine with the platform team.
      /// 
      /// @param parameters A structure containing all parameters for the updates.
      ///    See the structure documentation for details.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
      ///    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
      ///    shares.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="parameters"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_manageNotebookShares(AsyncCallback callback, object state, string authenticationToken, ManageNotebookSharesParameters parameters);
      ManageNotebookSharesResult End_manageNotebookShares(IAsyncResult asyncResult);
      #endif
      /// <summary>
      /// Return the share relationships for the given notebook, including
      /// both the invitations and the memberships.
      /// 
      /// <i>Note:</i> Beta method! This method is currently intended for
      /// limited use by Evernote clients that have discussed using this
      /// routine with the platform team.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      #if SILVERLIGHT
      IAsyncResult Begin_getNotebookShares(AsyncCallback callback, object state, string authenticationToken, string notebookGuid);
      ShareRelationships End_getNotebookShares(IAsyncResult asyncResult);
      #endif
    }

    /// <summary>
    /// Service:  NoteStore
    /// <p>
    /// The NoteStore service is used by EDAM clients to exchange information
    /// about the collection of notes in an account. This is primarily used for
    /// synchronization, but could also be used by a "thin" client without a full
    /// local cache.
    /// </p><p>
    /// Most functions take an "authenticationToken" parameter, which is the
    /// value returned by the UserStore which permits access to the account.
    /// </p>
    /// 
    /// Calls which require an authenticationToken may throw an EDAMUserException
    /// for the following reasons:
    ///  <ul>
    ///   <li>DATA_REQUIRED "authenticationToken" - token is empty</li>
    ///   <li>BAD_DATA_FORMAT "authenticationToken" - token is malformed</li>
    ///   <li>INVALID_AUTH "authenticationToken" - token signature is invalid</li>
    ///   <li>AUTH_EXPIRED "authenticationToken" - token has expired or been revoked</li>
    ///   <li>PERMISSION_DENIED "authenticationToken" - token does not grant permission
    ///       to perform the requested action</li>
    ///   <li>BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user is a member of a business
    ///       that requires single sign-on, and must complete SSO before accessing business
    ///       content.
    /// </ul>
    /// </summary>
    public class Client : IDisposable, Iface {
      public Client(TProtocol prot) : this(prot, prot)
      {
      }

      public Client(TProtocol iprot, TProtocol oprot)
      {
        iprot_ = iprot;
        oprot_ = oprot;
      }

      protected TProtocol iprot_;
      protected TProtocol oprot_;
      protected int seqid_;

      public TProtocol InputProtocol
      {
        get { return iprot_; }
      }
      public TProtocol OutputProtocol
      {
        get { return oprot_; }
      }


      #region " IDisposable Support "
      private bool _IsDisposed;

      // IDisposable
      public void Dispose()
      {
        Dispose(true);
      }
      

      protected virtual void Dispose(bool disposing)
      {
        if (!_IsDisposed)
        {
          if (disposing)
          {
            if (iprot_ != null)
            {
              ((IDisposable)iprot_).Dispose();
            }
            if (oprot_ != null)
            {
              ((IDisposable)oprot_).Dispose();
            }
          }
        }
        _IsDisposed = true;
      }
      #endregion


      
      #if SILVERLIGHT
      public IAsyncResult Begin_getSyncState(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_getSyncState(callback, state, authenticationToken);
      }

      public SyncState End_getSyncState(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getSyncState();
      }

      #endif

      /// <summary>
      /// Asks the NoteStore to provide information about the status of the user
      /// account corresponding to the provided authentication token.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public SyncState getSyncState(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_getSyncState(authenticationToken);
        return recv_getSyncState();

        #else
        var asyncResult = Begin_getSyncState(null, null, authenticationToken);
        return End_getSyncState(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getSyncState(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_getSyncState(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getSyncState", TMessageType.Call, seqid_));
        getSyncState_args args = new getSyncState_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public SyncState recv_getSyncState()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getSyncState_result result = new getSyncState_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getSyncState failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getFilteredSyncChunk(AsyncCallback callback, object state, string authenticationToken, int afterUSN, int maxEntries, SyncChunkFilter filter)
      {
        return send_getFilteredSyncChunk(callback, state, authenticationToken, afterUSN, maxEntries, filter);
      }

      public SyncChunk End_getFilteredSyncChunk(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getFilteredSyncChunk();
      }

      #endif

      /// <summary>
      /// Asks the NoteStore to provide the state of the account in order of
      /// last modification.  This request retrieves one block of the server's
      /// state so that a client can make several small requests against a large
      /// account rather than getting the entire state in one big message.
      /// This call gives fine-grained control of the data that will
      /// be received by a client by omitting data elements that a client doesn't
      /// need. This may reduce network traffic and sync times.
      /// 
      /// @param afterUSN
      ///   The client can pass this value to ask only for objects that
      ///   have been updated after a certain point.  This allows the client to
      ///   receive updates after its last checkpoint rather than doing a full
      ///   synchronization on every pass.  The default value of "0" indicates
      ///   that the client wants to get objects from the start of the account.
      /// 
      /// @param maxEntries
      ///   The maximum number of modified objects that should be
      ///   returned in the result SyncChunk.  This can be used to limit the size
      ///   of each individual message to be friendly for network transfer.
      /// 
      /// @param filter
      ///   The caller must set some of the flags in this structure to specify which
      ///   data types should be returned during the synchronization.  See
      ///   the SyncChunkFilter structure for information on each flag.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="afterUSN"></param>
      /// <param name="maxEntries"></param>
      /// <param name="filter"></param>
      public SyncChunk getFilteredSyncChunk(string authenticationToken, int afterUSN, int maxEntries, SyncChunkFilter filter)
      {
        #if !SILVERLIGHT
        send_getFilteredSyncChunk(authenticationToken, afterUSN, maxEntries, filter);
        return recv_getFilteredSyncChunk();

        #else
        var asyncResult = Begin_getFilteredSyncChunk(null, null, authenticationToken, afterUSN, maxEntries, filter);
        return End_getFilteredSyncChunk(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getFilteredSyncChunk(AsyncCallback callback, object state, string authenticationToken, int afterUSN, int maxEntries, SyncChunkFilter filter)
      #else
      public void send_getFilteredSyncChunk(string authenticationToken, int afterUSN, int maxEntries, SyncChunkFilter filter)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getFilteredSyncChunk", TMessageType.Call, seqid_));
        getFilteredSyncChunk_args args = new getFilteredSyncChunk_args();
        args.AuthenticationToken = authenticationToken;
        args.AfterUSN = afterUSN;
        args.MaxEntries = maxEntries;
        args.Filter = filter;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public SyncChunk recv_getFilteredSyncChunk()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getFilteredSyncChunk_result result = new getFilteredSyncChunk_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getFilteredSyncChunk failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getLinkedNotebookSyncState(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      {
        return send_getLinkedNotebookSyncState(callback, state, authenticationToken, linkedNotebook);
      }

      public SyncState End_getLinkedNotebookSyncState(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getLinkedNotebookSyncState();
      }

      #endif

      /// <summary>
      /// Asks the NoteStore to provide information about the status of a linked
      /// notebook that has been shared with the caller, or that is public to the
      /// world.
      /// This will return a result that is similar to getSyncState, but may omit
      /// SyncState.uploaded if the caller doesn't have permission to write to
      /// the linked notebook.
      /// 
      /// This function must be called on the shard that owns the referenced
      /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
      /// same as LinkedNotebook.shardId.)
      /// 
      /// @param authenticationToken
      ///   This should be an authenticationToken for the guest who has received
      ///   the invitation to the share.  (I.e. this should not be the result of
      ///   NoteStore.authenticateToSharedNotebook)
      /// 
      /// @param linkedNotebook
      ///   This structure should contain identifying information and permissions
      ///   to access the notebook in question.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "LinkedNotebook.username" - The username field must be
      ///       populated with the current username of the owner of the notebook for which
      ///       you are obtaining sync state.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"LinkedNotebook.username" - If the LinkedNotebook.username field does not
      ///       correspond to a current user on the service.
      ///   </li>
      /// </ul>
      /// 
      /// @throws SystemException <ul>
      ///   <li>SHARD_UNAVAILABLE - If the provided LinkedNotebook.username corresponds to a
      ///       user whose account is on a shard other than that on which this method was
      ///       invoked.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      public SyncState getLinkedNotebookSyncState(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      {
        #if !SILVERLIGHT
        send_getLinkedNotebookSyncState(authenticationToken, linkedNotebook);
        return recv_getLinkedNotebookSyncState();

        #else
        var asyncResult = Begin_getLinkedNotebookSyncState(null, null, authenticationToken, linkedNotebook);
        return End_getLinkedNotebookSyncState(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getLinkedNotebookSyncState(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      #else
      public void send_getLinkedNotebookSyncState(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getLinkedNotebookSyncState", TMessageType.Call, seqid_));
        getLinkedNotebookSyncState_args args = new getLinkedNotebookSyncState_args();
        args.AuthenticationToken = authenticationToken;
        args.LinkedNotebook = linkedNotebook;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public SyncState recv_getLinkedNotebookSyncState()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getLinkedNotebookSyncState_result result = new getLinkedNotebookSyncState_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getLinkedNotebookSyncState failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getLinkedNotebookSyncChunk(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook, int afterUSN, int maxEntries, bool fullSyncOnly)
      {
        return send_getLinkedNotebookSyncChunk(callback, state, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
      }

      public SyncChunk End_getLinkedNotebookSyncChunk(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getLinkedNotebookSyncChunk();
      }

      #endif

      /// <summary>
      /// Asks the NoteStore to provide information about the contents of a linked
      /// notebook that has been shared with the caller, or that is public to the
      /// world.
      /// This will return a result that is similar to getSyncChunk, but will only
      /// contain entries that are visible to the caller.  I.e. only that particular
      /// Notebook will be visible, along with its Notes, and Tags on those Notes.
      /// 
      /// This function must be called on the shard that owns the referenced
      /// notebook.  (I.e. the shardId in /shard/shardId/edam/note must be the
      /// same as LinkedNotebook.shardId.)
      /// 
      /// @param authenticationToken
      ///   This should be an authenticationToken for the guest who has received
      ///   the invitation to the share.  (I.e. this should not be the result of
      ///   NoteStore.authenticateToSharedNotebook)
      /// 
      /// @param linkedNotebook
      ///   This structure should contain identifying information and permissions
      ///   to access the notebook in question.  This must contain the valid fields
      ///   for either a shared notebook (e.g. shareKey)
      ///   or a public notebook (e.g. username, uri)
      /// 
      /// @param afterUSN
      ///   The client can pass this value to ask only for objects that
      ///   have been updated after a certain point.  This allows the client to
      ///   receive updates after its last checkpoint rather than doing a full
      ///   synchronization on every pass.  The default value of "0" indicates
      ///   that the client wants to get objects from the start of the account.
      /// 
      /// @param maxEntries
      ///   The maximum number of modified objects that should be
      ///   returned in the result SyncChunk.  This can be used to limit the size
      ///   of each individual message to be friendly for network transfer.
      ///   Applications should not request more than 256 objects at a time,
      ///   and must handle the case where the service returns less than the
      ///   requested number of objects in a given request even though more
      ///   objects are available on the service.
      /// 
      /// @param fullSyncOnly
      ///   If true, then the client only wants initial data for a full sync.
      ///   In this case, the service will not return any expunged objects,
      ///   and will not return any Resources, since these are also provided
      ///   in their corresponding Notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "afterUSN" - if negative
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxEntries" - if less than 1
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "LinkedNotebook" - if the provided information doesn't match any
      ///     valid notebook
      ///   </li>
      ///   <li> "LinkedNotebook.uri" - if the provided public URI doesn't match any
      ///     valid notebook
      ///   </li>
      ///   <li> "SharedNotebook.id" - if the provided information indicates a
      ///      shared notebook that no longer exists
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      /// <param name="afterUSN"></param>
      /// <param name="maxEntries"></param>
      /// <param name="fullSyncOnly"></param>
      public SyncChunk getLinkedNotebookSyncChunk(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook, int afterUSN, int maxEntries, bool fullSyncOnly)
      {
        #if !SILVERLIGHT
        send_getLinkedNotebookSyncChunk(authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
        return recv_getLinkedNotebookSyncChunk();

        #else
        var asyncResult = Begin_getLinkedNotebookSyncChunk(null, null, authenticationToken, linkedNotebook, afterUSN, maxEntries, fullSyncOnly);
        return End_getLinkedNotebookSyncChunk(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getLinkedNotebookSyncChunk(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook, int afterUSN, int maxEntries, bool fullSyncOnly)
      #else
      public void send_getLinkedNotebookSyncChunk(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook, int afterUSN, int maxEntries, bool fullSyncOnly)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getLinkedNotebookSyncChunk", TMessageType.Call, seqid_));
        getLinkedNotebookSyncChunk_args args = new getLinkedNotebookSyncChunk_args();
        args.AuthenticationToken = authenticationToken;
        args.LinkedNotebook = linkedNotebook;
        args.AfterUSN = afterUSN;
        args.MaxEntries = maxEntries;
        args.FullSyncOnly = fullSyncOnly;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public SyncChunk recv_getLinkedNotebookSyncChunk()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getLinkedNotebookSyncChunk_result result = new getLinkedNotebookSyncChunk_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getLinkedNotebookSyncChunk failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listNotebooks(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listNotebooks(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.Notebook> End_listNotebooks(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listNotebooks();
      }

      #endif

      /// <summary>
      /// Returns a list of all of the notebooks in the account.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.Notebook> listNotebooks(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listNotebooks(authenticationToken);
        return recv_listNotebooks();

        #else
        var asyncResult = Begin_listNotebooks(null, null, authenticationToken);
        return End_listNotebooks(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listNotebooks(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listNotebooks(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listNotebooks", TMessageType.Call, seqid_));
        listNotebooks_args args = new listNotebooks_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.Notebook> recv_listNotebooks()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listNotebooks_result result = new listNotebooks_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listNotebooks failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listAccessibleBusinessNotebooks(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listAccessibleBusinessNotebooks(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.Notebook> End_listAccessibleBusinessNotebooks(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listAccessibleBusinessNotebooks();
      }

      #endif

      /// <summary>
      /// Returns a list of all the notebooks in a business that the user has permission to access,
      /// regardless of whether the user has joined them. This includes notebooks that have been shared
      /// with the entire business as well as notebooks that have been shared directly with the user.
      /// 
      /// @param authenticationToken A business authentication token obtained by calling
      ///   UserStore.authenticateToBusiness.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> INVALID_AUTH "authenticationToken" - if the authentication token is not a
      ///     business auth token.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.Notebook> listAccessibleBusinessNotebooks(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listAccessibleBusinessNotebooks(authenticationToken);
        return recv_listAccessibleBusinessNotebooks();

        #else
        var asyncResult = Begin_listAccessibleBusinessNotebooks(null, null, authenticationToken);
        return End_listAccessibleBusinessNotebooks(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listAccessibleBusinessNotebooks(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listAccessibleBusinessNotebooks(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listAccessibleBusinessNotebooks", TMessageType.Call, seqid_));
        listAccessibleBusinessNotebooks_args args = new listAccessibleBusinessNotebooks_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.Notebook> recv_listAccessibleBusinessNotebooks()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listAccessibleBusinessNotebooks_result result = new listAccessibleBusinessNotebooks_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listAccessibleBusinessNotebooks failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNotebook(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getNotebook(callback, state, authenticationToken, guid);
      }

      public Evernote.EDAM.Type.Notebook End_getNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNotebook();
      }

      #endif

      /// <summary>
      /// Returns the current state of the notebook with the provided GUID.
      /// The notebook may be active or deleted (but not expunged).
      /// 
      /// @param guid
      ///   The GUID of the notebook to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public Evernote.EDAM.Type.Notebook getNotebook(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getNotebook(authenticationToken, guid);
        return recv_getNotebook();

        #else
        var asyncResult = Begin_getNotebook(null, null, authenticationToken, guid);
        return End_getNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNotebook(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getNotebook(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNotebook", TMessageType.Call, seqid_));
        getNotebook_args args = new getNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Notebook recv_getNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNotebook_result result = new getNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getDefaultNotebook(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_getDefaultNotebook(callback, state, authenticationToken);
      }

      public Evernote.EDAM.Type.Notebook End_getDefaultNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getDefaultNotebook();
      }

      #endif

      /// <summary>
      /// Returns the notebook that should be used to store new notes in the
      /// user's account when no other notebooks are specified.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public Evernote.EDAM.Type.Notebook getDefaultNotebook(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_getDefaultNotebook(authenticationToken);
        return recv_getDefaultNotebook();

        #else
        var asyncResult = Begin_getDefaultNotebook(null, null, authenticationToken);
        return End_getDefaultNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getDefaultNotebook(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_getDefaultNotebook(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getDefaultNotebook", TMessageType.Call, seqid_));
        getDefaultNotebook_args args = new getDefaultNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Notebook recv_getDefaultNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getDefaultNotebook_result result = new getDefaultNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getDefaultNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      {
        return send_createNotebook(callback, state, authenticationToken, notebook);
      }

      public Evernote.EDAM.Type.Notebook End_createNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_createNotebook();
      }

      #endif

      /// <summary>
      /// Asks the service to make a notebook with the provided name.
      /// 
      /// @param notebook
      ///   The desired fields for the notebook must be provided on this
      ///   object.  The name of the notebook must be set, and either the 'active'
      ///   or 'defaultNotebook' fields may be set by the client at creation.
      ///   If a notebook exists in the account with the same name (via
      ///   case-insensitive compare), this will throw an EDAMUserException.
      /// 
      /// @return
      ///   The newly created Notebook.  The server-side GUID will be
      ///   saved in this object's 'guid' field.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
      ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
      ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
      ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
      ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
      ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
      ///        is set to 'true' for a Notebook that is not owned by the user identified by
      ///        the passed authenticationToken.</li>
      ///   <li> LIMIT_REACHED "Notebook" - at max number of notebooks</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Workspace.guid" - if workspaceGuid set and no Workspace exists for the GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebook"></param>
      public Evernote.EDAM.Type.Notebook createNotebook(string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      {
        #if !SILVERLIGHT
        send_createNotebook(authenticationToken, notebook);
        return recv_createNotebook();

        #else
        var asyncResult = Begin_createNotebook(null, null, authenticationToken, notebook);
        return End_createNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      #else
      public void send_createNotebook(string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createNotebook", TMessageType.Call, seqid_));
        createNotebook_args args = new createNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.Notebook = notebook;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Notebook recv_createNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createNotebook_result result = new createNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "createNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      {
        return send_updateNotebook(callback, state, authenticationToken, notebook);
      }

      public int End_updateNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateNotebook();
      }

      #endif

      /// <summary>
      /// Submits notebook changes to the service. The provided data must include the
      /// notebook's guid field for identification.
      /// <p />
      /// The Notebook will be moved to the specified Workspace, if a non empty
      /// Notebook.workspaceGuid is provided. If an empty Notebook.workspaceGuid is set and the
      /// Notebook is in a Workspace, then it will be removed from the Workspace and a full
      /// access SharedNotebook record will be ensured for the caller. If the caller does not
      /// already have a full access share, either the privilege of an existing share will be
      /// upgraded or a new share will be created. It is illegal to set a
      /// Notebook.workspaceGuid on a Workspace backing Notebook.
      /// 
      /// @param notebook
      ///   The notebook object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.name" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Notebook.stack" - invalid length or pattern</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.uri" - if publishing set but bad uri</li>
      ///   <li> BAD_DATA_FORMAT "Publishing.publicDescription" - if too long</li>
      ///   <li> DATA_CONFLICT "Notebook.name" - name already in use</li>
      ///   <li> DATA_CONFLICT "Publishing.uri" - if URI already in use</li>
      ///   <li> DATA_REQUIRED "Publishing.uri" - if publishing set but uri missing</li>
      ///   <li> DATA_REQUIRED "Notebook" - notebook parameter was null</li>
      ///   <li> PERMISSION_DENIED "Notebook.defaultNotebook" - if the 'defaultNotebook' field
      ///        is set to 'true' for a Notebook that is not owned by the user identified by
      ///        the passed authenticationToken.</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID</li>
      ///   <li> "Workspace.guid" - if a non empty workspaceGuid set and no Workspace exists
      ///        for the GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebook"></param>
      public int updateNotebook(string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      {
        #if !SILVERLIGHT
        send_updateNotebook(authenticationToken, notebook);
        return recv_updateNotebook();

        #else
        var asyncResult = Begin_updateNotebook(null, null, authenticationToken, notebook);
        return End_updateNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      #else
      public void send_updateNotebook(string authenticationToken, Evernote.EDAM.Type.Notebook notebook)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateNotebook", TMessageType.Call, seqid_));
        updateNotebook_args args = new updateNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.Notebook = notebook;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_updateNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateNotebook_result result = new updateNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_expungeNotebook(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_expungeNotebook(callback, state, authenticationToken, guid);
      }

      public int End_expungeNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_expungeNotebook();
      }

      #endif

      /// <summary>
      /// Permanently removes the notebook from the user's account.
      /// After this action, the notebook is no longer available for undeletion, etc.
      /// If the notebook contains any Notes, they will be moved to the current
      /// default notebook and moved into the trash (i.e. Note.active=false).
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the notebook to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Notebook.guid" - if the parameter is missing
      ///   </li>
      ///   <li> LIMIT_REACHED "Notebook" - trying to expunge the last Notebook
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook" - private notebook, user doesn't own
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public int expungeNotebook(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_expungeNotebook(authenticationToken, guid);
        return recv_expungeNotebook();

        #else
        var asyncResult = Begin_expungeNotebook(null, null, authenticationToken, guid);
        return End_expungeNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_expungeNotebook(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_expungeNotebook(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("expungeNotebook", TMessageType.Call, seqid_));
        expungeNotebook_args args = new expungeNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_expungeNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        expungeNotebook_result result = new expungeNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "expungeNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listTags(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listTags(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.Tag> End_listTags(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listTags();
      }

      #endif

      /// <summary>
      /// Returns a list of the tags in the account.  Evernote does not support
      /// the undeletion of tags, so this will only include active tags.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.Tag> listTags(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listTags(authenticationToken);
        return recv_listTags();

        #else
        var asyncResult = Begin_listTags(null, null, authenticationToken);
        return End_listTags(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listTags(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listTags(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listTags", TMessageType.Call, seqid_));
        listTags_args args = new listTags_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.Tag> recv_listTags()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listTags_result result = new listTags_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listTags failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listTagsByNotebook(AsyncCallback callback, object state, string authenticationToken, string notebookGuid)
      {
        return send_listTagsByNotebook(callback, state, authenticationToken, notebookGuid);
      }

      public List<Evernote.EDAM.Type.Tag> End_listTagsByNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listTagsByNotebook();
      }

      #endif

      /// <summary>
      /// Returns a list of the tags that are applied to at least one note within
      /// the provided notebook.  If the notebook is public, the authenticationToken
      /// may be ignored.
      /// 
      /// @param notebookGuid
      ///    the GUID of the notebook to use to find tags
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - notebook not found by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      public List<Evernote.EDAM.Type.Tag> listTagsByNotebook(string authenticationToken, string notebookGuid)
      {
        #if !SILVERLIGHT
        send_listTagsByNotebook(authenticationToken, notebookGuid);
        return recv_listTagsByNotebook();

        #else
        var asyncResult = Begin_listTagsByNotebook(null, null, authenticationToken, notebookGuid);
        return End_listTagsByNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listTagsByNotebook(AsyncCallback callback, object state, string authenticationToken, string notebookGuid)
      #else
      public void send_listTagsByNotebook(string authenticationToken, string notebookGuid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listTagsByNotebook", TMessageType.Call, seqid_));
        listTagsByNotebook_args args = new listTagsByNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.NotebookGuid = notebookGuid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.Tag> recv_listTagsByNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listTagsByNotebook_result result = new listTagsByNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listTagsByNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getTag(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getTag(callback, state, authenticationToken, guid);
      }

      public Evernote.EDAM.Type.Tag End_getTag(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getTag();
      }

      #endif

      /// <summary>
      /// Returns the current state of the Tag with the provided GUID.
      /// 
      /// @param guid
      ///   The GUID of the tag to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - private Tag, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public Evernote.EDAM.Type.Tag getTag(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getTag(authenticationToken, guid);
        return recv_getTag();

        #else
        var asyncResult = Begin_getTag(null, null, authenticationToken, guid);
        return End_getTag(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getTag(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getTag(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getTag", TMessageType.Call, seqid_));
        getTag_args args = new getTag_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Tag recv_getTag()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getTag_result result = new getTag_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getTag failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createTag(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Tag tag)
      {
        return send_createTag(callback, state, authenticationToken, tag);
      }

      public Evernote.EDAM.Type.Tag End_createTag(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_createTag();
      }

      #endif

      /// <summary>
      /// Asks the service to make a tag with a set of information.
      /// 
      /// @param tag
      ///   The desired list of fields for the tag are specified in this
      ///   object.  The caller must specify the tag name, and may provide
      ///   the parentGUID.
      /// 
      /// @return
      ///   The newly created Tag.  The server-side GUID will be
      ///   saved in this object.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.name" - name already in use
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - at max number of tags
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.parentGuid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="tag"></param>
      public Evernote.EDAM.Type.Tag createTag(string authenticationToken, Evernote.EDAM.Type.Tag tag)
      {
        #if !SILVERLIGHT
        send_createTag(authenticationToken, tag);
        return recv_createTag();

        #else
        var asyncResult = Begin_createTag(null, null, authenticationToken, tag);
        return End_createTag(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createTag(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Tag tag)
      #else
      public void send_createTag(string authenticationToken, Evernote.EDAM.Type.Tag tag)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createTag", TMessageType.Call, seqid_));
        createTag_args args = new createTag_args();
        args.AuthenticationToken = authenticationToken;
        args.Tag = tag;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Tag recv_createTag()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createTag_result result = new createTag_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "createTag failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateTag(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Tag tag)
      {
        return send_updateTag(callback, state, authenticationToken, tag);
      }

      public int End_updateTag(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateTag();
      }

      #endif

      /// <summary>
      /// Submits tag changes to the service.  The provided data must include
      /// the tag's guid field for identification.  The service will apply
      /// updates to the following tag fields:  name, parentGuid
      /// 
      /// @param tag
      ///   The tag object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.parentGuid" - malformed GUID
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.name" - name already in use
      ///   </li>
      ///   <li> DATA_CONFLICT "Tag.parentGuid" - can't set parent: circular
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      ///   <li> "Tag.parentGuid" - parent not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="tag"></param>
      public int updateTag(string authenticationToken, Evernote.EDAM.Type.Tag tag)
      {
        #if !SILVERLIGHT
        send_updateTag(authenticationToken, tag);
        return recv_updateTag();

        #else
        var asyncResult = Begin_updateTag(null, null, authenticationToken, tag);
        return End_updateTag(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateTag(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Tag tag)
      #else
      public void send_updateTag(string authenticationToken, Evernote.EDAM.Type.Tag tag)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateTag", TMessageType.Call, seqid_));
        updateTag_args args = new updateTag_args();
        args.AuthenticationToken = authenticationToken;
        args.Tag = tag;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_updateTag()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateTag_result result = new updateTag_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateTag failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_untagAll(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_untagAll(callback, state, authenticationToken, guid);
      }

      public void End_untagAll(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_untagAll();
      }

      #endif

      /// <summary>
      /// Removes the provided tag from every note that is currently tagged with
      /// this tag.  If this operation is successful, the tag will still be in
      /// the account, but it will not be tagged on any notes.
      /// 
      /// This function is not indended for use by full synchronizing clients, since
      /// it does not provide enough result information to the client to reconcile
      /// the local state without performing a follow-up sync from the service.  This
      /// is intended for "thin clients" that need to efficiently support this as
      /// a UI operation.
      /// 
      /// @param guid
      ///   The GUID of the tag to remove from all notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public void untagAll(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_untagAll(authenticationToken, guid);
        recv_untagAll();

        #else
        var asyncResult = Begin_untagAll(null, null, authenticationToken, guid);
        End_untagAll(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_untagAll(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_untagAll(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("untagAll", TMessageType.Call, seqid_));
        untagAll_args args = new untagAll_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_untagAll()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        untagAll_result result = new untagAll_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_expungeTag(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_expungeTag(callback, state, authenticationToken, guid);
      }

      public int End_expungeTag(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_expungeTag();
      }

      #endif

      /// <summary>
      /// Permanently deletes the tag with the provided GUID, if present.
      /// <p/>
      /// NOTE: This function is not generally available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the tag to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Tag.guid" - if the guid parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Tag" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Tag.guid" - tag not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public int expungeTag(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_expungeTag(authenticationToken, guid);
        return recv_expungeTag();

        #else
        var asyncResult = Begin_expungeTag(null, null, authenticationToken, guid);
        return End_expungeTag(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_expungeTag(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_expungeTag(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("expungeTag", TMessageType.Call, seqid_));
        expungeTag_args args = new expungeTag_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_expungeTag()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        expungeTag_result result = new expungeTag_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "expungeTag failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listSearches(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listSearches(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.SavedSearch> End_listSearches(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listSearches();
      }

      #endif

      /// <summary>
      /// Returns a list of the searches in the account.  Evernote does not support
      /// the undeletion of searches, so this will only include active searches.
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.SavedSearch> listSearches(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listSearches(authenticationToken);
        return recv_listSearches();

        #else
        var asyncResult = Begin_listSearches(null, null, authenticationToken);
        return End_listSearches(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listSearches(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listSearches(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listSearches", TMessageType.Call, seqid_));
        listSearches_args args = new listSearches_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.SavedSearch> recv_listSearches()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listSearches_result result = new listSearches_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listSearches failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getSearch(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getSearch(callback, state, authenticationToken, guid);
      }

      public Evernote.EDAM.Type.SavedSearch End_getSearch(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getSearch();
      }

      #endif

      /// <summary>
      /// Returns the current state of the search with the provided GUID.
      /// 
      /// @param guid
      ///   The GUID of the search to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - private Tag, user doesn't own
      ///   </li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public Evernote.EDAM.Type.SavedSearch getSearch(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getSearch(authenticationToken, guid);
        return recv_getSearch();

        #else
        var asyncResult = Begin_getSearch(null, null, authenticationToken, guid);
        return End_getSearch(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getSearch(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getSearch(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getSearch", TMessageType.Call, seqid_));
        getSearch_args args = new getSearch_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.SavedSearch recv_getSearch()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getSearch_result result = new getSearch_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getSearch failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createSearch(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      {
        return send_createSearch(callback, state, authenticationToken, search);
      }

      public Evernote.EDAM.Type.SavedSearch End_createSearch(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_createSearch();
      }

      #endif

      /// <summary>
      /// Asks the service to make a saved search with a set of information.
      /// 
      /// @param search
      ///   The desired list of fields for the search are specified in this
      ///   object. The caller must specify the name and query for the
      ///   search, and may optionally specify a search scope.
      ///   The SavedSearch.format field is ignored by the service.
      /// 
      /// @return
      ///   The newly created SavedSearch.  The server-side GUID will be
      ///   saved in this object.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      ///   </li>
      ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      ///   </li>
      ///   <li> LIMIT_REACHED "SavedSearch" - at max number of searches
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="search"></param>
      public Evernote.EDAM.Type.SavedSearch createSearch(string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      {
        #if !SILVERLIGHT
        send_createSearch(authenticationToken, search);
        return recv_createSearch();

        #else
        var asyncResult = Begin_createSearch(null, null, authenticationToken, search);
        return End_createSearch(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createSearch(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      #else
      public void send_createSearch(string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createSearch", TMessageType.Call, seqid_));
        createSearch_args args = new createSearch_args();
        args.AuthenticationToken = authenticationToken;
        args.Search = search;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.SavedSearch recv_createSearch()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createSearch_result result = new createSearch_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "createSearch failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateSearch(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      {
        return send_updateSearch(callback, state, authenticationToken, search);
      }

      public int End_updateSearch(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateSearch();
      }

      #endif

      /// <summary>
      /// Submits search changes to the service. The provided data must include
      /// the search's guid field for identification. The service will apply
      /// updates to the following search fields: name, query, and scope.
      /// 
      /// @param search
      ///   The search object containing the requested changes.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.name" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.query" - invalid length
      ///   </li>
      ///   <li> DATA_CONFLICT "SavedSearch.name" - name already in use
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own tag
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="search"></param>
      public int updateSearch(string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      {
        #if !SILVERLIGHT
        send_updateSearch(authenticationToken, search);
        return recv_updateSearch();

        #else
        var asyncResult = Begin_updateSearch(null, null, authenticationToken, search);
        return End_updateSearch(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateSearch(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      #else
      public void send_updateSearch(string authenticationToken, Evernote.EDAM.Type.SavedSearch search)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateSearch", TMessageType.Call, seqid_));
        updateSearch_args args = new updateSearch_args();
        args.AuthenticationToken = authenticationToken;
        args.Search = search;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_updateSearch()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateSearch_result result = new updateSearch_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateSearch failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_expungeSearch(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_expungeSearch(callback, state, authenticationToken, guid);
      }

      public int End_expungeSearch(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_expungeSearch();
      }

      #endif

      /// <summary>
      /// Permanently deletes the saved search with the provided GUID, if present.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the search to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "SavedSearch.guid" - if the guid parameter is empty
      ///   </li>
      ///   <li> PERMISSION_DENIED "SavedSearch" - user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SavedSearch.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public int expungeSearch(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_expungeSearch(authenticationToken, guid);
        return recv_expungeSearch();

        #else
        var asyncResult = Begin_expungeSearch(null, null, authenticationToken, guid);
        return End_expungeSearch(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_expungeSearch(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_expungeSearch(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("expungeSearch", TMessageType.Call, seqid_));
        expungeSearch_args args = new expungeSearch_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_expungeSearch()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        expungeSearch_result result = new expungeSearch_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "expungeSearch failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_findNoteOffset(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, string guid)
      {
        return send_findNoteOffset(callback, state, authenticationToken, filter, guid);
      }

      public int End_findNoteOffset(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_findNoteOffset();
      }

      #endif

      /// <summary>
      /// Finds the position of a note within a sorted subset of all of the user's
      /// notes. This may be useful for thin clients that are displaying a paginated
      /// listing of a large account, which need to know where a particular note
      /// sits in the list without retrieving all notes first.
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The list of criteria that will constrain the notes to be returned.
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @return
      ///   If the note with the provided GUID is found within the matching note
      ///   list, this will return the offset of that note within that list (where
      ///   the first offset is 0).  If the note is not found within the set of
      ///   notes, this will return -1.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="guid"></param>
      public int findNoteOffset(string authenticationToken, NoteFilter filter, string guid)
      {
        #if !SILVERLIGHT
        send_findNoteOffset(authenticationToken, filter, guid);
        return recv_findNoteOffset();

        #else
        var asyncResult = Begin_findNoteOffset(null, null, authenticationToken, filter, guid);
        return End_findNoteOffset(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_findNoteOffset(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, string guid)
      #else
      public void send_findNoteOffset(string authenticationToken, NoteFilter filter, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("findNoteOffset", TMessageType.Call, seqid_));
        findNoteOffset_args args = new findNoteOffset_args();
        args.AuthenticationToken = authenticationToken;
        args.Filter = filter;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_findNoteOffset()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        findNoteOffset_result result = new findNoteOffset_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "findNoteOffset failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_findNotesMetadata(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, int offset, int maxNotes, NotesMetadataResultSpec resultSpec)
      {
        return send_findNotesMetadata(callback, state, authenticationToken, filter, offset, maxNotes, resultSpec);
      }

      public NotesMetadataList End_findNotesMetadata(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_findNotesMetadata();
      }

      #endif

      /// <summary>
      /// Used to find the high-level information about a set of the notes from a
      /// user's account based on various criteria specified via a NoteFilter object.
      /// <p/>
      /// Web applications that wish to periodically check for new content in a user's
      /// Evernote account should consider using webhooks instead of polling this API.
      /// See http://dev.evernote.com/documentation/cloud/chapters/polling_notification.php
      /// for more information.
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The list of criteria that will constrain the notes to be returned.
      /// 
      /// @param offset
      ///   The numeric index of the first note to show within the sorted
      ///   results.  The numbering scheme starts with "0".  This can be used for
      ///   pagination.
      /// 
      /// @param maxNotes
      ///   The maximum notes to return in this query.  The service will return a set
      ///   of notes that is no larger than this number, but may return fewer notes
      ///   if needed.  The NoteList.totalNotes field in the return value will
      ///   indicate whether there are more values available after the returned set.
      ///   Currently, the service will not return more than 250 notes in a single request,
      ///   but this number may change in the future.
      /// 
      /// @param resultSpec
      ///   This specifies which information should be returned for each matching
      ///   Note. The fields on this structure can be used to eliminate data that
      ///   the client doesn't need, which will reduce the time and bandwidth
      ///   to receive and process the reply.
      /// 
      /// @return
      ///   The list of notes that match the criteria.
      ///   The Notes.sharedNotes field will not be set.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "offset" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "maxNotes" - not between 0 and EDAM_USER_NOTES_MAX
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="offset"></param>
      /// <param name="maxNotes"></param>
      /// <param name="resultSpec"></param>
      public NotesMetadataList findNotesMetadata(string authenticationToken, NoteFilter filter, int offset, int maxNotes, NotesMetadataResultSpec resultSpec)
      {
        #if !SILVERLIGHT
        send_findNotesMetadata(authenticationToken, filter, offset, maxNotes, resultSpec);
        return recv_findNotesMetadata();

        #else
        var asyncResult = Begin_findNotesMetadata(null, null, authenticationToken, filter, offset, maxNotes, resultSpec);
        return End_findNotesMetadata(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_findNotesMetadata(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, int offset, int maxNotes, NotesMetadataResultSpec resultSpec)
      #else
      public void send_findNotesMetadata(string authenticationToken, NoteFilter filter, int offset, int maxNotes, NotesMetadataResultSpec resultSpec)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("findNotesMetadata", TMessageType.Call, seqid_));
        findNotesMetadata_args args = new findNotesMetadata_args();
        args.AuthenticationToken = authenticationToken;
        args.Filter = filter;
        args.Offset = offset;
        args.MaxNotes = maxNotes;
        args.ResultSpec = resultSpec;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public NotesMetadataList recv_findNotesMetadata()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        findNotesMetadata_result result = new findNotesMetadata_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "findNotesMetadata failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_findNoteCounts(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, bool withTrash)
      {
        return send_findNoteCounts(callback, state, authenticationToken, filter, withTrash);
      }

      public NoteCollectionCounts End_findNoteCounts(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_findNoteCounts();
      }

      #endif

      /// <summary>
      /// This function is used to determine how many notes are found for each
      /// notebook and tag in the user's account, given a current set of filter
      /// parameters that determine the current selection.  This function will
      /// return a structure that gives the note count for each notebook and tag
      /// that has at least one note under the requested filter.  Any notebook or
      /// tag that has zero notes in the filtered set will not be listed in the
      /// reply to this function (so they can be assumed to be 0).
      /// 
      /// @param authenticationToken
      ///   Must be a valid token for the user's account unless the NoteFilter
      ///   'notebookGuid' is the GUID of a public notebook.
      /// 
      /// @param filter
      ///   The note selection filter that is currently being applied.  The note
      ///   counts are to be calculated with this filter applied to the total set
      ///   of notes in the user's account.
      /// 
      /// @param withTrash
      ///   If true, then the NoteCollectionCounts.trashCount will be calculated
      ///   and supplied in the reply. Otherwise, the trash value will be omitted.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed</li>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.notebookGuids" - if any are malformed</li>
      ///   <li>BAD_DATA_FORMAT "NoteFilter.words" - if search string too long</li>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="filter"></param>
      /// <param name="withTrash"></param>
      public NoteCollectionCounts findNoteCounts(string authenticationToken, NoteFilter filter, bool withTrash)
      {
        #if !SILVERLIGHT
        send_findNoteCounts(authenticationToken, filter, withTrash);
        return recv_findNoteCounts();

        #else
        var asyncResult = Begin_findNoteCounts(null, null, authenticationToken, filter, withTrash);
        return End_findNoteCounts(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_findNoteCounts(AsyncCallback callback, object state, string authenticationToken, NoteFilter filter, bool withTrash)
      #else
      public void send_findNoteCounts(string authenticationToken, NoteFilter filter, bool withTrash)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("findNoteCounts", TMessageType.Call, seqid_));
        findNoteCounts_args args = new findNoteCounts_args();
        args.AuthenticationToken = authenticationToken;
        args.Filter = filter;
        args.WithTrash = withTrash;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public NoteCollectionCounts recv_findNoteCounts()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        findNoteCounts_result result = new findNoteCounts_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "findNoteCounts failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteWithResultSpec(AsyncCallback callback, object state, string authenticationToken, string guid, NoteResultSpec resultSpec)
      {
        return send_getNoteWithResultSpec(callback, state, authenticationToken, guid, resultSpec);
      }

      public Evernote.EDAM.Type.Note End_getNoteWithResultSpec(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteWithResultSpec();
      }

      #endif

      /// <summary>
      /// Returns the current state of the note in the service with the provided
      /// GUID.  The ENML contents of the note will only be provided if the
      /// 'withContent' parameter is true.  The service will include the meta-data
      /// for each resource in the note, but the binary content depends
      /// on whether it is explicitly requested in resultSpec parameter.
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).  The applicationData
      /// fields are returned as keysOnly.
      /// 
      /// @param authenticationToken
      ///   An authentication token that grants the caller access to the requested note.
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param resultSpec
      ///   A structure specifying the fields of the note that the caller would like to get.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="resultSpec"></param>
      public Evernote.EDAM.Type.Note getNoteWithResultSpec(string authenticationToken, string guid, NoteResultSpec resultSpec)
      {
        #if !SILVERLIGHT
        send_getNoteWithResultSpec(authenticationToken, guid, resultSpec);
        return recv_getNoteWithResultSpec();

        #else
        var asyncResult = Begin_getNoteWithResultSpec(null, null, authenticationToken, guid, resultSpec);
        return End_getNoteWithResultSpec(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteWithResultSpec(AsyncCallback callback, object state, string authenticationToken, string guid, NoteResultSpec resultSpec)
      #else
      public void send_getNoteWithResultSpec(string authenticationToken, string guid, NoteResultSpec resultSpec)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteWithResultSpec", TMessageType.Call, seqid_));
        getNoteWithResultSpec_args args = new getNoteWithResultSpec_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.ResultSpec = resultSpec;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Note recv_getNoteWithResultSpec()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteWithResultSpec_result result = new getNoteWithResultSpec_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteWithResultSpec failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNote(AsyncCallback callback, object state, string authenticationToken, string guid, bool withContent, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      {
        return send_getNote(callback, state, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
      }

      public Evernote.EDAM.Type.Note End_getNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNote();
      }

      #endif

      /// <summary>
      /// DEPRECATED. See getNoteWithResultSpec.
      /// 
      /// This function is equivalent to getNoteWithResultSpec, with each of the boolean parameters
      /// mapping to the equivalent field of a NoteResultSpec. The Note.sharedNotes field is never
      /// populated on the returned note. To get a note with its shares, use getNoteWithResultSpec.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="withContent"></param>
      /// <param name="withResourcesData"></param>
      /// <param name="withResourcesRecognition"></param>
      /// <param name="withResourcesAlternateData"></param>
      public Evernote.EDAM.Type.Note getNote(string authenticationToken, string guid, bool withContent, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      {
        #if !SILVERLIGHT
        send_getNote(authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
        return recv_getNote();

        #else
        var asyncResult = Begin_getNote(null, null, authenticationToken, guid, withContent, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
        return End_getNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNote(AsyncCallback callback, object state, string authenticationToken, string guid, bool withContent, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      #else
      public void send_getNote(string authenticationToken, string guid, bool withContent, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNote", TMessageType.Call, seqid_));
        getNote_args args = new getNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.WithContent = withContent;
        args.WithResourcesData = withResourcesData;
        args.WithResourcesRecognition = withResourcesRecognition;
        args.WithResourcesAlternateData = withResourcesAlternateData;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Note recv_getNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNote_result result = new getNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteApplicationData(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getNoteApplicationData(callback, state, authenticationToken, guid);
      }

      public Evernote.EDAM.Type.LazyMap End_getNoteApplicationData(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteApplicationData();
      }

      #endif

      /// <summary>
      /// Get all of the application data for the note identified by GUID,
      /// with values returned within the LazyMap fullMap field.
      /// If there are no applicationData entries, then a LazyMap
      /// with an empty fullMap will be returned. If your application
      /// only needs to fetch its own applicationData entry, use
      /// getNoteApplicationDataEntry instead.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public Evernote.EDAM.Type.LazyMap getNoteApplicationData(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getNoteApplicationData(authenticationToken, guid);
        return recv_getNoteApplicationData();

        #else
        var asyncResult = Begin_getNoteApplicationData(null, null, authenticationToken, guid);
        return End_getNoteApplicationData(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteApplicationData(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getNoteApplicationData(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteApplicationData", TMessageType.Call, seqid_));
        getNoteApplicationData_args args = new getNoteApplicationData_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.LazyMap recv_getNoteApplicationData()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteApplicationData_result result = new getNoteApplicationData_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteApplicationData failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      {
        return send_getNoteApplicationDataEntry(callback, state, authenticationToken, guid, key);
      }

      public string End_getNoteApplicationDataEntry(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteApplicationDataEntry();
      }

      #endif

      /// <summary>
      /// Get the value of a single entry in the applicationData map
      /// for the note identified by GUID.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - note not found, by GUID</li>
      ///   <li> "NoteAttributes.applicationData.key" - note not found, by key</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      public string getNoteApplicationDataEntry(string authenticationToken, string guid, string key)
      {
        #if !SILVERLIGHT
        send_getNoteApplicationDataEntry(authenticationToken, guid, key);
        return recv_getNoteApplicationDataEntry();

        #else
        var asyncResult = Begin_getNoteApplicationDataEntry(null, null, authenticationToken, guid, key);
        return End_getNoteApplicationDataEntry(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      #else
      public void send_getNoteApplicationDataEntry(string authenticationToken, string guid, string key)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteApplicationDataEntry", TMessageType.Call, seqid_));
        getNoteApplicationDataEntry_args args = new getNoteApplicationDataEntry_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Key = key;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_getNoteApplicationDataEntry()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteApplicationDataEntry_result result = new getNoteApplicationDataEntry_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteApplicationDataEntry failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_setNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key, string @value)
      {
        return send_setNoteApplicationDataEntry(callback, state, authenticationToken, guid, key, @value);
      }

      public int End_setNoteApplicationDataEntry(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_setNoteApplicationDataEntry();
      }

      #endif

      /// <summary>
      /// Update, or create, an entry in the applicationData map for
      /// the note identified by guid.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      /// <param name="value"></param>
      public int setNoteApplicationDataEntry(string authenticationToken, string guid, string key, string @value)
      {
        #if !SILVERLIGHT
        send_setNoteApplicationDataEntry(authenticationToken, guid, key, @value);
        return recv_setNoteApplicationDataEntry();

        #else
        var asyncResult = Begin_setNoteApplicationDataEntry(null, null, authenticationToken, guid, key, @value);
        return End_setNoteApplicationDataEntry(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_setNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key, string @value)
      #else
      public void send_setNoteApplicationDataEntry(string authenticationToken, string guid, string key, string @value)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("setNoteApplicationDataEntry", TMessageType.Call, seqid_));
        setNoteApplicationDataEntry_args args = new setNoteApplicationDataEntry_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Key = key;
        args.Value = @value;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_setNoteApplicationDataEntry()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        setNoteApplicationDataEntry_result result = new setNoteApplicationDataEntry_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "setNoteApplicationDataEntry failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_unsetNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      {
        return send_unsetNoteApplicationDataEntry(callback, state, authenticationToken, guid, key);
      }

      public int End_unsetNoteApplicationDataEntry(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_unsetNoteApplicationDataEntry();
      }

      #endif

      /// <summary>
      /// Remove an entry identified by 'key' from the applicationData map for
      /// the note identified by 'guid'. Silently ignores an unset of a
      /// non-existing key.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      public int unsetNoteApplicationDataEntry(string authenticationToken, string guid, string key)
      {
        #if !SILVERLIGHT
        send_unsetNoteApplicationDataEntry(authenticationToken, guid, key);
        return recv_unsetNoteApplicationDataEntry();

        #else
        var asyncResult = Begin_unsetNoteApplicationDataEntry(null, null, authenticationToken, guid, key);
        return End_unsetNoteApplicationDataEntry(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_unsetNoteApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      #else
      public void send_unsetNoteApplicationDataEntry(string authenticationToken, string guid, string key)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("unsetNoteApplicationDataEntry", TMessageType.Call, seqid_));
        unsetNoteApplicationDataEntry_args args = new unsetNoteApplicationDataEntry_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Key = key;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_unsetNoteApplicationDataEntry()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        unsetNoteApplicationDataEntry_result result = new unsetNoteApplicationDataEntry_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "unsetNoteApplicationDataEntry failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteContent(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getNoteContent(callback, state, authenticationToken, guid);
      }

      public string End_getNoteContent(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteContent();
      }

      #endif

      /// <summary>
      /// Returns XHTML contents of the note with the provided GUID.
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public string getNoteContent(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getNoteContent(authenticationToken, guid);
        return recv_getNoteContent();

        #else
        var asyncResult = Begin_getNoteContent(null, null, authenticationToken, guid);
        return End_getNoteContent(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteContent(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getNoteContent(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteContent", TMessageType.Call, seqid_));
        getNoteContent_args args = new getNoteContent_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_getNoteContent()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteContent_result result = new getNoteContent_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteContent failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteSearchText(AsyncCallback callback, object state, string authenticationToken, string guid, bool noteOnly, bool tokenizeForIndexing)
      {
        return send_getNoteSearchText(callback, state, authenticationToken, guid, noteOnly, tokenizeForIndexing);
      }

      public string End_getNoteSearchText(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteSearchText();
      }

      #endif

      /// <summary>
      /// Returns a block of the extracted plain text contents of the note with the
      /// provided GUID.  This text can be indexed for search purposes by a light
      /// client that doesn't have capabilities to extract all of the searchable
      /// text content from the note and its resources.
      /// 
      /// If the Note is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param noteOnly
      ///   If true, this will only return the text extracted from the ENML contents
      ///   of the note itself.  If false, this will also include the extracted text
      ///   from any text-bearing resources (PDF, recognized images)
      /// 
      /// @param tokenizeForIndexing
      ///   If true, this will break the text into cleanly separated and sanitized
      ///   tokens.  If false, this will return the more raw text extraction, with
      ///   its original punctuation, capitalization, spacing, etc.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="noteOnly"></param>
      /// <param name="tokenizeForIndexing"></param>
      public string getNoteSearchText(string authenticationToken, string guid, bool noteOnly, bool tokenizeForIndexing)
      {
        #if !SILVERLIGHT
        send_getNoteSearchText(authenticationToken, guid, noteOnly, tokenizeForIndexing);
        return recv_getNoteSearchText();

        #else
        var asyncResult = Begin_getNoteSearchText(null, null, authenticationToken, guid, noteOnly, tokenizeForIndexing);
        return End_getNoteSearchText(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteSearchText(AsyncCallback callback, object state, string authenticationToken, string guid, bool noteOnly, bool tokenizeForIndexing)
      #else
      public void send_getNoteSearchText(string authenticationToken, string guid, bool noteOnly, bool tokenizeForIndexing)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteSearchText", TMessageType.Call, seqid_));
        getNoteSearchText_args args = new getNoteSearchText_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.NoteOnly = noteOnly;
        args.TokenizeForIndexing = tokenizeForIndexing;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_getNoteSearchText()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteSearchText_result result = new getNoteSearchText_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteSearchText failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceSearchText(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getResourceSearchText(callback, state, authenticationToken, guid);
      }

      public string End_getResourceSearchText(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceSearchText();
      }

      #endif

      /// <summary>
      /// Returns a block of the extracted plain text contents of the resource with
      /// the provided GUID.  This text can be indexed for search purposes by a light
      /// client that doesn't have capability to extract all of the searchable
      /// text content from a resource.
      /// 
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public string getResourceSearchText(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getResourceSearchText(authenticationToken, guid);
        return recv_getResourceSearchText();

        #else
        var asyncResult = Begin_getResourceSearchText(null, null, authenticationToken, guid);
        return End_getResourceSearchText(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceSearchText(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getResourceSearchText(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceSearchText", TMessageType.Call, seqid_));
        getResourceSearchText_args args = new getResourceSearchText_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_getResourceSearchText()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceSearchText_result result = new getResourceSearchText_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceSearchText failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteTagNames(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getNoteTagNames(callback, state, authenticationToken, guid);
      }

      public List<string> End_getNoteTagNames(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteTagNames();
      }

      #endif

      /// <summary>
      /// Returns a list of the names of the tags for the note with the provided
      /// guid.  This can be used with authentication to get the tags for a
      /// user's own note, or can be used without valid authentication to retrieve
      /// the names of the tags for a note in a public notebook.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public List<string> getNoteTagNames(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getNoteTagNames(authenticationToken, guid);
        return recv_getNoteTagNames();

        #else
        var asyncResult = Begin_getNoteTagNames(null, null, authenticationToken, guid);
        return End_getNoteTagNames(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteTagNames(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getNoteTagNames(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteTagNames", TMessageType.Call, seqid_));
        getNoteTagNames_args args = new getNoteTagNames_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<string> recv_getNoteTagNames()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteTagNames_result result = new getNoteTagNames_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteTagNames failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createNote(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note)
      {
        return send_createNote(callback, state, authenticationToken, note);
      }

      public Evernote.EDAM.Type.Note End_createNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_createNote();
      }

      #endif

      /// <summary>
      /// Asks the service to make a note with the provided set of information.
      /// 
      /// @param note
      ///   A Note object containing the desired fields to be populated on
      ///   the service.
      /// 
      /// @return
      ///   The newly created Note from the service.  The server-side
      ///   GUIDs for the Note and any Resources will be saved in this object.
      ///   The service will include the meta-data
      ///   for each resource in the note, but the binary contents of the resources
      ///   and their recognition data will be omitted (except Recognition Resource body,
      ///   for which the behavior is unspecified).
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML content
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      ///   </li>
      ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> LIMIT_REACHED "Note" - at max number per account
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.size" - total note size too large
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
      ///   </li>
      ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.notebookGuid" - NB not owned by user
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
      ///     of the specified tags had an invalid length or pattern
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
      ///     new tags would exceed the maximum number per account
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.notebookGuid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      public Evernote.EDAM.Type.Note createNote(string authenticationToken, Evernote.EDAM.Type.Note note)
      {
        #if !SILVERLIGHT
        send_createNote(authenticationToken, note);
        return recv_createNote();

        #else
        var asyncResult = Begin_createNote(null, null, authenticationToken, note);
        return End_createNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createNote(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note)
      #else
      public void send_createNote(string authenticationToken, Evernote.EDAM.Type.Note note)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createNote", TMessageType.Call, seqid_));
        createNote_args args = new createNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Note = note;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Note recv_createNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createNote_result result = new createNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "createNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateNote(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note)
      {
        return send_updateNote(callback, state, authenticationToken, note);
      }

      public Evernote.EDAM.Type.Note End_updateNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateNote();
      }

      #endif

      /// <summary>
      /// Submit a set of changes to a note to the service.  The provided data
      /// must include the note's guid field for identification. The note's
      /// title must also be set.
      /// 
      /// @param note
      ///   A Note object containing the desired fields to be populated on
      ///   the service. With the exception of the note's title and guid, fields
      ///   that are not being changed do not need to be set. If the content is not
      ///   being modified, note.content should be left unset. If the list of
      ///   resources is not being modified, note.resources should be left unset.
      /// 
      /// @return
      ///   The Note.sharedNotes field will not be set.
      ///   The service will include the meta-data
      ///   for each resource in the note, but the binary contents of the resources
      ///   and their recognition data will be omitted.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.title" - invalid length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.content" - invalid length for ENML body
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> DATA_CONFLICT "Note.deleted" - deleted time set on active note
      ///   </li>
      ///   <li> DATA_REQUIRED "Resource.data" - resource data body missing
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.tagGuids" - too many Tags on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.resources" - too many resources on Note
      ///   </li>
      ///   <li> LIMIT_REACHED "Note.size" - total note size too large
      ///   </li>
      ///   <li> LIMIT_REACHED "Resource.data.size" - resource too large
      ///   </li>
      ///   <li> LIMIT_REACHED "NoteAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.notebookGuid" - user doesn't own destination
      ///   <li> PERMISSION_DENIED "Note.tags" - user doesn't have permission to
      ///     modify the note's tags. note.tags must be unset.
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note.attributes" - user doesn't have permission
      ///     to modify the note's attributes. note.attributes must be unset.
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Tag.name" - Note.tagNames was provided, and one
      ///     of the specified tags had an invalid length or pattern
      ///   </li>
      ///   <li> LIMIT_REACHED "Tag" - Note.tagNames was provided, and the required
      ///     new tags would exceed the maximum number per account
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - note not found, by GUID
      ///   </li>
      ///   <li> "Note.notebookGuid" - if notebookGuid provided, but not found
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      public Evernote.EDAM.Type.Note updateNote(string authenticationToken, Evernote.EDAM.Type.Note note)
      {
        #if !SILVERLIGHT
        send_updateNote(authenticationToken, note);
        return recv_updateNote();

        #else
        var asyncResult = Begin_updateNote(null, null, authenticationToken, note);
        return End_updateNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateNote(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note)
      #else
      public void send_updateNote(string authenticationToken, Evernote.EDAM.Type.Note note)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateNote", TMessageType.Call, seqid_));
        updateNote_args args = new updateNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Note = note;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Note recv_updateNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateNote_result result = new updateNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_deleteNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_deleteNote(callback, state, authenticationToken, guid);
      }

      public int End_deleteNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_deleteNote();
      }

      #endif

      /// <summary>
      /// Moves the note into the trash. The note may still be undeleted, unless it
      /// is expunged.  This is equivalent to calling updateNote() after setting
      /// Note.active = false
      /// 
      /// @param guid
      ///   The GUID of the note to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't have permission to
      ///          update the note.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_CONFLICT "Note.guid" - the note is already deleted
      ///   </li>
      /// </ul>
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public int deleteNote(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_deleteNote(authenticationToken, guid);
        return recv_deleteNote();

        #else
        var asyncResult = Begin_deleteNote(null, null, authenticationToken, guid);
        return End_deleteNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_deleteNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_deleteNote(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("deleteNote", TMessageType.Call, seqid_));
        deleteNote_args args = new deleteNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_deleteNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        deleteNote_result result = new deleteNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "deleteNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_expungeNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_expungeNote(callback, state, authenticationToken, guid);
      }

      public int End_expungeNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_expungeNote();
      }

      #endif

      /// <summary>
      /// Permanently removes a Note, and all of its Resources,
      /// from the service.
      /// <p/>
      /// NOTE: This function is not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The GUID of the note to delete.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public int expungeNote(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_expungeNote(authenticationToken, guid);
        return recv_expungeNote();

        #else
        var asyncResult = Begin_expungeNote(null, null, authenticationToken, guid);
        return End_expungeNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_expungeNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_expungeNote(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("expungeNote", TMessageType.Call, seqid_));
        expungeNote_args args = new expungeNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_expungeNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        expungeNote_result result = new expungeNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "expungeNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_copyNote(AsyncCallback callback, object state, string authenticationToken, string noteGuid, string toNotebookGuid)
      {
        return send_copyNote(callback, state, authenticationToken, noteGuid, toNotebookGuid);
      }

      public Evernote.EDAM.Type.Note End_copyNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_copyNote();
      }

      #endif

      /// <summary>
      /// Performs a deep copy of the Note with the provided GUID 'noteGuid' into
      /// the Notebook with the provided GUID 'toNotebookGuid'.
      /// The caller must be the owner of both the Note and the Notebook.
      /// This creates a new Note in the destination Notebook with new content and
      /// Resources that match all of the content and Resources from the original
      /// Note, but with new GUID identifiers.
      /// The original Note is not modified by this operation.
      /// The copied note is considered as an "upload" for the purpose of upload
      /// transfer limit calculation, so its size is added to the upload count for
      /// the owner.
      /// 
      /// If the original note has been shared and has SharedNote records, the shares
      /// are NOT copied.
      /// 
      /// @param noteGuid
      ///   The GUID of the Note to copy.
      /// 
      /// @param toNotebookGuid
      ///   The GUID of the Notebook that should receive the new Note.
      /// 
      /// @return
      ///   The metadata for the new Note that was created.  This will include the
      ///   new GUID for this Note (and any copied Resources), but will not include
      ///   the content body or the binary bodies of any Resources.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> LIMIT_REACHED "Note" - at max number per account
      ///   </li>
      ///   <li> PERMISSION_DENIED "Notebook.guid" - destination not owned by user
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - user doesn't own
      ///   </li>
      ///   <li> QUOTA_REACHED "Accounting.uploadLimit" - note exceeds upload quota
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Notebook.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="toNotebookGuid"></param>
      public Evernote.EDAM.Type.Note copyNote(string authenticationToken, string noteGuid, string toNotebookGuid)
      {
        #if !SILVERLIGHT
        send_copyNote(authenticationToken, noteGuid, toNotebookGuid);
        return recv_copyNote();

        #else
        var asyncResult = Begin_copyNote(null, null, authenticationToken, noteGuid, toNotebookGuid);
        return End_copyNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_copyNote(AsyncCallback callback, object state, string authenticationToken, string noteGuid, string toNotebookGuid)
      #else
      public void send_copyNote(string authenticationToken, string noteGuid, string toNotebookGuid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("copyNote", TMessageType.Call, seqid_));
        copyNote_args args = new copyNote_args();
        args.AuthenticationToken = authenticationToken;
        args.NoteGuid = noteGuid;
        args.ToNotebookGuid = toNotebookGuid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Note recv_copyNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        copyNote_result result = new copyNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "copyNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listNoteVersions(AsyncCallback callback, object state, string authenticationToken, string noteGuid)
      {
        return send_listNoteVersions(callback, state, authenticationToken, noteGuid);
      }

      public List<NoteVersionId> End_listNoteVersions(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listNoteVersions();
      }

      #endif

      /// <summary>
      /// Returns a list of the prior versions of a particular note that are
      /// saved within the service.  These prior versions are stored to provide a
      /// recovery from unintentional removal of content from a note. The identifiers
      /// that are returned by this call can be used with getNoteVersion to retrieve
      /// the previous note.
      /// The identifiers will be listed from the most recent versions to the oldest.
      /// This call is only available for notes in Premium accounts. (I.e. access
      /// to past versions of Notes is a Premium-only feature.)
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      public List<NoteVersionId> listNoteVersions(string authenticationToken, string noteGuid)
      {
        #if !SILVERLIGHT
        send_listNoteVersions(authenticationToken, noteGuid);
        return recv_listNoteVersions();

        #else
        var asyncResult = Begin_listNoteVersions(null, null, authenticationToken, noteGuid);
        return End_listNoteVersions(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listNoteVersions(AsyncCallback callback, object state, string authenticationToken, string noteGuid)
      #else
      public void send_listNoteVersions(string authenticationToken, string noteGuid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listNoteVersions", TMessageType.Call, seqid_));
        listNoteVersions_args args = new listNoteVersions_args();
        args.AuthenticationToken = authenticationToken;
        args.NoteGuid = noteGuid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<NoteVersionId> recv_listNoteVersions()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listNoteVersions_result result = new listNoteVersions_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listNoteVersions failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNoteVersion(AsyncCallback callback, object state, string authenticationToken, string noteGuid, int updateSequenceNum, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      {
        return send_getNoteVersion(callback, state, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
      }

      public Evernote.EDAM.Type.Note End_getNoteVersion(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNoteVersion();
      }

      #endif

      /// <summary>
      /// This can be used to retrieve a previous version of a Note after it has been
      /// updated within the service.  The caller must identify the note (via its
      /// guid) and the version (via the updateSequenceNumber of that version).
      /// to find a listing of the stored version USNs for a note, call
      /// listNoteVersions.
      /// This call is only available for notes in Premium accounts. (I.e. access
      /// to past versions of Notes is a Premium-only feature.)
      /// 
      /// @param noteGuid
      ///   The GUID of the note to be retrieved.
      /// 
      /// @param updateSequenceNum
      ///   The USN of the version of the note that is being retrieved
      /// 
      /// @param withResourcesData
      ///   If true, any Resource elements in this Note will include the binary
      ///   contents of their 'data' field's body.
      /// 
      /// @param withResourcesRecognition
      ///   If true, any Resource elements will include the binary contents of the
      ///   'recognition' field's body if recognition data is present.
      /// 
      /// @param withResourcesAlternateData
      ///   If true, any Resource elements in this Note will include the binary
      ///   contents of their 'alternateData' fields' body, if an alternate form
      ///   is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - if GUID is null or empty string.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if GUID is not of correct length.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID.
      ///   </li>
      ///   <li> "Note.updateSequenceNumber" - the Note doesn't have a version with
      ///      the corresponding USN.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="updateSequenceNum"></param>
      /// <param name="withResourcesData"></param>
      /// <param name="withResourcesRecognition"></param>
      /// <param name="withResourcesAlternateData"></param>
      public Evernote.EDAM.Type.Note getNoteVersion(string authenticationToken, string noteGuid, int updateSequenceNum, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      {
        #if !SILVERLIGHT
        send_getNoteVersion(authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
        return recv_getNoteVersion();

        #else
        var asyncResult = Begin_getNoteVersion(null, null, authenticationToken, noteGuid, updateSequenceNum, withResourcesData, withResourcesRecognition, withResourcesAlternateData);
        return End_getNoteVersion(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNoteVersion(AsyncCallback callback, object state, string authenticationToken, string noteGuid, int updateSequenceNum, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      #else
      public void send_getNoteVersion(string authenticationToken, string noteGuid, int updateSequenceNum, bool withResourcesData, bool withResourcesRecognition, bool withResourcesAlternateData)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNoteVersion", TMessageType.Call, seqid_));
        getNoteVersion_args args = new getNoteVersion_args();
        args.AuthenticationToken = authenticationToken;
        args.NoteGuid = noteGuid;
        args.UpdateSequenceNum = updateSequenceNum;
        args.WithResourcesData = withResourcesData;
        args.WithResourcesRecognition = withResourcesRecognition;
        args.WithResourcesAlternateData = withResourcesAlternateData;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Note recv_getNoteVersion()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNoteVersion_result result = new getNoteVersion_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNoteVersion failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResource(AsyncCallback callback, object state, string authenticationToken, string guid, bool withData, bool withRecognition, bool withAttributes, bool withAlternateData)
      {
        return send_getResource(callback, state, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
      }

      public Evernote.EDAM.Type.Resource End_getResource(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResource();
      }

      #endif

      /// <summary>
      /// Returns the current state of the resource in the service with the
      /// provided GUID.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).  Only the
      /// keys for the applicationData will be returned.
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @param withData
      ///   If true, the Resource will include the binary contents of the
      ///   'data' field's body.
      /// 
      /// @param withRecognition
      ///   If true, the Resource will include the binary contents of the
      ///   'recognition' field's body if recognition data is present.
      /// 
      /// @param withAttributes
      ///   If true, the Resource will include the attributes
      /// 
      /// @param withAlternateData
      ///   If true, the Resource will include the binary contents of the
      ///   'alternateData' field's body, if an alternate form is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="withData"></param>
      /// <param name="withRecognition"></param>
      /// <param name="withAttributes"></param>
      /// <param name="withAlternateData"></param>
      public Evernote.EDAM.Type.Resource getResource(string authenticationToken, string guid, bool withData, bool withRecognition, bool withAttributes, bool withAlternateData)
      {
        #if !SILVERLIGHT
        send_getResource(authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
        return recv_getResource();

        #else
        var asyncResult = Begin_getResource(null, null, authenticationToken, guid, withData, withRecognition, withAttributes, withAlternateData);
        return End_getResource(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResource(AsyncCallback callback, object state, string authenticationToken, string guid, bool withData, bool withRecognition, bool withAttributes, bool withAlternateData)
      #else
      public void send_getResource(string authenticationToken, string guid, bool withData, bool withRecognition, bool withAttributes, bool withAlternateData)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResource", TMessageType.Call, seqid_));
        getResource_args args = new getResource_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.WithData = withData;
        args.WithRecognition = withRecognition;
        args.WithAttributes = withAttributes;
        args.WithAlternateData = withAlternateData;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Resource recv_getResource()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResource_result result = new getResource_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResource failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceApplicationData(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getResourceApplicationData(callback, state, authenticationToken, guid);
      }

      public Evernote.EDAM.Type.LazyMap End_getResourceApplicationData(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceApplicationData();
      }

      #endif

      /// <summary>
      /// Get all of the application data for the Resource identified by GUID,
      /// with values returned within the LazyMap fullMap field.
      /// If there are no applicationData entries, then a LazyMap
      /// with an empty fullMap will be returned. If your application
      /// only needs to fetch its own applicationData entry, use
      /// getResourceApplicationDataEntry instead.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public Evernote.EDAM.Type.LazyMap getResourceApplicationData(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getResourceApplicationData(authenticationToken, guid);
        return recv_getResourceApplicationData();

        #else
        var asyncResult = Begin_getResourceApplicationData(null, null, authenticationToken, guid);
        return End_getResourceApplicationData(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceApplicationData(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getResourceApplicationData(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceApplicationData", TMessageType.Call, seqid_));
        getResourceApplicationData_args args = new getResourceApplicationData_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.LazyMap recv_getResourceApplicationData()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceApplicationData_result result = new getResourceApplicationData_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceApplicationData failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      {
        return send_getResourceApplicationDataEntry(callback, state, authenticationToken, guid, key);
      }

      public string End_getResourceApplicationDataEntry(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceApplicationDataEntry();
      }

      #endif

      /// <summary>
      /// Get the value of a single entry in the applicationData map
      /// for the Resource identified by GUID.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - Resource not found, by GUID</li>
      ///   <li> "ResourceAttributes.applicationData.key" - Resource not found, by key</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      public string getResourceApplicationDataEntry(string authenticationToken, string guid, string key)
      {
        #if !SILVERLIGHT
        send_getResourceApplicationDataEntry(authenticationToken, guid, key);
        return recv_getResourceApplicationDataEntry();

        #else
        var asyncResult = Begin_getResourceApplicationDataEntry(null, null, authenticationToken, guid, key);
        return End_getResourceApplicationDataEntry(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      #else
      public void send_getResourceApplicationDataEntry(string authenticationToken, string guid, string key)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceApplicationDataEntry", TMessageType.Call, seqid_));
        getResourceApplicationDataEntry_args args = new getResourceApplicationDataEntry_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Key = key;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_getResourceApplicationDataEntry()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceApplicationDataEntry_result result = new getResourceApplicationDataEntry_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceApplicationDataEntry failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_setResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key, string @value)
      {
        return send_setResourceApplicationDataEntry(callback, state, authenticationToken, guid, key, @value);
      }

      public int End_setResourceApplicationDataEntry(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_setResourceApplicationDataEntry();
      }

      #endif

      /// <summary>
      /// Update, or create, an entry in the applicationData map for
      /// the Resource identified by guid.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      /// <param name="value"></param>
      public int setResourceApplicationDataEntry(string authenticationToken, string guid, string key, string @value)
      {
        #if !SILVERLIGHT
        send_setResourceApplicationDataEntry(authenticationToken, guid, key, @value);
        return recv_setResourceApplicationDataEntry();

        #else
        var asyncResult = Begin_setResourceApplicationDataEntry(null, null, authenticationToken, guid, key, @value);
        return End_setResourceApplicationDataEntry(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_setResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key, string @value)
      #else
      public void send_setResourceApplicationDataEntry(string authenticationToken, string guid, string key, string @value)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("setResourceApplicationDataEntry", TMessageType.Call, seqid_));
        setResourceApplicationDataEntry_args args = new setResourceApplicationDataEntry_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Key = key;
        args.Value = @value;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_setResourceApplicationDataEntry()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        setResourceApplicationDataEntry_result result = new setResourceApplicationDataEntry_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "setResourceApplicationDataEntry failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_unsetResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      {
        return send_unsetResourceApplicationDataEntry(callback, state, authenticationToken, guid, key);
      }

      public int End_unsetResourceApplicationDataEntry(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_unsetResourceApplicationDataEntry();
      }

      #endif

      /// <summary>
      /// Remove an entry identified by 'key' from the applicationData map for
      /// the Resource identified by 'guid'.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      /// <param name="key"></param>
      public int unsetResourceApplicationDataEntry(string authenticationToken, string guid, string key)
      {
        #if !SILVERLIGHT
        send_unsetResourceApplicationDataEntry(authenticationToken, guid, key);
        return recv_unsetResourceApplicationDataEntry();

        #else
        var asyncResult = Begin_unsetResourceApplicationDataEntry(null, null, authenticationToken, guid, key);
        return End_unsetResourceApplicationDataEntry(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_unsetResourceApplicationDataEntry(AsyncCallback callback, object state, string authenticationToken, string guid, string key)
      #else
      public void send_unsetResourceApplicationDataEntry(string authenticationToken, string guid, string key)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("unsetResourceApplicationDataEntry", TMessageType.Call, seqid_));
        unsetResourceApplicationDataEntry_args args = new unsetResourceApplicationDataEntry_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Key = key;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_unsetResourceApplicationDataEntry()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        unsetResourceApplicationDataEntry_result result = new unsetResourceApplicationDataEntry_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "unsetResourceApplicationDataEntry failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateResource(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Resource resource)
      {
        return send_updateResource(callback, state, authenticationToken, resource);
      }

      public int End_updateResource(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateResource();
      }

      #endif

      /// <summary>
      /// Submit a set of changes to a resource to the service.  This can be used
      /// to update the meta-data about the resource, but cannot be used to change
      /// the binary contents of the resource (including the length and hash).  These
      /// cannot be changed directly without creating a new resource and removing the
      /// old one via updateNote.
      /// 
      /// @param resource
      ///   A Resource object containing the desired fields to be populated on
      ///   the service.  The service will attempt to update the resource with the
      ///   following fields from the client:
      ///   <ul>
      ///      <li>guid:  must be provided to identify the resource
      ///      </li>
      ///      <li>mime
      ///      </li>
      ///      <li>width
      ///      </li>
      ///      <li>height
      ///      </li>
      ///      <li>duration
      ///      </li>
      ///      <li>attributes:  optional.  if present, the set of attributes will
      ///           be replaced.
      ///      </li>
      ///   </ul>
      /// 
      /// @return
      ///   The Update Sequence Number of the resource after the changes have been
      ///   applied.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "Resource.mime" - invalid resource MIME type
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "ResourceAttributes.*" - bad resource string
      ///   </li>
      ///   <li> LIMIT_REACHED "ResourceAttribute.*" - attribute string too long
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="resource"></param>
      public int updateResource(string authenticationToken, Evernote.EDAM.Type.Resource resource)
      {
        #if !SILVERLIGHT
        send_updateResource(authenticationToken, resource);
        return recv_updateResource();

        #else
        var asyncResult = Begin_updateResource(null, null, authenticationToken, resource);
        return End_updateResource(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateResource(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Resource resource)
      #else
      public void send_updateResource(string authenticationToken, Evernote.EDAM.Type.Resource resource)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateResource", TMessageType.Call, seqid_));
        updateResource_args args = new updateResource_args();
        args.AuthenticationToken = authenticationToken;
        args.Resource = resource;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_updateResource()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateResource_result result = new updateResource_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateResource failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceData(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getResourceData(callback, state, authenticationToken, guid);
      }

      public byte[] End_getResourceData(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceData();
      }

      #endif

      /// <summary>
      /// Returns binary data of the resource with the provided GUID.  For
      /// example, if this were an image resource, this would contain the
      /// raw bits of the image.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource to be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public byte[] getResourceData(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getResourceData(authenticationToken, guid);
        return recv_getResourceData();

        #else
        var asyncResult = Begin_getResourceData(null, null, authenticationToken, guid);
        return End_getResourceData(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceData(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getResourceData(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceData", TMessageType.Call, seqid_));
        getResourceData_args args = new getResourceData_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public byte[] recv_getResourceData()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceData_result result = new getResourceData_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceData failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceByHash(AsyncCallback callback, object state, string authenticationToken, string noteGuid, byte[] contentHash, bool withData, bool withRecognition, bool withAlternateData)
      {
        return send_getResourceByHash(callback, state, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
      }

      public Evernote.EDAM.Type.Resource End_getResourceByHash(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceByHash();
      }

      #endif

      /// <summary>
      /// Returns the current state of a resource, referenced by containing
      /// note GUID and resource content hash.
      /// 
      /// @param noteGuid
      ///   The GUID of the note that holds the resource to be retrieved.
      /// 
      /// @param contentHash
      ///   The MD5 checksum of the resource within that note. Note that
      ///   this is the binary checksum, for example from Resource.data.bodyHash,
      ///   and not the hex-encoded checksum that is used within an en-media
      ///   tag in a note body.
      /// 
      /// @param withData
      ///   If true, the Resource will include the binary contents of the
      ///   'data' field's body.
      /// 
      /// @param withRecognition
      ///   If true, the Resource will include the binary contents of the
      ///   'recognition' field's body.
      /// 
      /// @param withAlternateData
      ///   If true, the Resource will include the binary contents of the
      ///   'alternateData' field's body, if an alternate form is present.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "Note.guid" - noteGuid param missing
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.contentHash" - contentHash param missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note" - not found, by guid
      ///   </li>
      ///   <li> "Resource" - not found, by hash
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="noteGuid"></param>
      /// <param name="contentHash"></param>
      /// <param name="withData"></param>
      /// <param name="withRecognition"></param>
      /// <param name="withAlternateData"></param>
      public Evernote.EDAM.Type.Resource getResourceByHash(string authenticationToken, string noteGuid, byte[] contentHash, bool withData, bool withRecognition, bool withAlternateData)
      {
        #if !SILVERLIGHT
        send_getResourceByHash(authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
        return recv_getResourceByHash();

        #else
        var asyncResult = Begin_getResourceByHash(null, null, authenticationToken, noteGuid, contentHash, withData, withRecognition, withAlternateData);
        return End_getResourceByHash(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceByHash(AsyncCallback callback, object state, string authenticationToken, string noteGuid, byte[] contentHash, bool withData, bool withRecognition, bool withAlternateData)
      #else
      public void send_getResourceByHash(string authenticationToken, string noteGuid, byte[] contentHash, bool withData, bool withRecognition, bool withAlternateData)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceByHash", TMessageType.Call, seqid_));
        getResourceByHash_args args = new getResourceByHash_args();
        args.AuthenticationToken = authenticationToken;
        args.NoteGuid = noteGuid;
        args.ContentHash = contentHash;
        args.WithData = withData;
        args.WithRecognition = withRecognition;
        args.WithAlternateData = withAlternateData;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Resource recv_getResourceByHash()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceByHash_result result = new getResourceByHash_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceByHash failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceRecognition(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getResourceRecognition(callback, state, authenticationToken, guid);
      }

      public byte[] End_getResourceRecognition(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceRecognition();
      }

      #endif

      /// <summary>
      /// Returns the binary contents of the recognition index for the resource
      /// with the provided GUID.  If the caller asks about a resource that has
      /// no recognition data, this will throw EDAMNotFoundException.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource whose recognition data should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Resource.recognition" - resource has no recognition
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public byte[] getResourceRecognition(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getResourceRecognition(authenticationToken, guid);
        return recv_getResourceRecognition();

        #else
        var asyncResult = Begin_getResourceRecognition(null, null, authenticationToken, guid);
        return End_getResourceRecognition(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceRecognition(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getResourceRecognition(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceRecognition", TMessageType.Call, seqid_));
        getResourceRecognition_args args = new getResourceRecognition_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public byte[] recv_getResourceRecognition()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceRecognition_result result = new getResourceRecognition_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceRecognition failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceAlternateData(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getResourceAlternateData(callback, state, authenticationToken, guid);
      }

      public byte[] End_getResourceAlternateData(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceAlternateData();
      }

      #endif

      /// <summary>
      /// If the Resource with the provided GUID has an alternate data representation
      /// (indicated via the Resource.alternateData field), then this request can
      /// be used to retrieve the binary contents of that alternate data file.
      /// If the caller asks about a resource that has no alternate data form, this
      /// will throw EDAMNotFoundException.
      /// 
      /// @param guid
      ///    The GUID of the resource whose recognition data should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      ///   <li> "Resource.alternateData" - resource has no recognition
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public byte[] getResourceAlternateData(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getResourceAlternateData(authenticationToken, guid);
        return recv_getResourceAlternateData();

        #else
        var asyncResult = Begin_getResourceAlternateData(null, null, authenticationToken, guid);
        return End_getResourceAlternateData(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceAlternateData(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getResourceAlternateData(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceAlternateData", TMessageType.Call, seqid_));
        getResourceAlternateData_args args = new getResourceAlternateData_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public byte[] recv_getResourceAlternateData()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceAlternateData_result result = new getResourceAlternateData_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceAlternateData failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getResourceAttributes(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_getResourceAttributes(callback, state, authenticationToken, guid);
      }

      public Evernote.EDAM.Type.ResourceAttributes End_getResourceAttributes(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getResourceAttributes();
      }

      #endif

      /// <summary>
      /// Returns the set of attributes for the Resource with the provided GUID.
      /// If the Resource is found in a public notebook, the authenticationToken
      /// will be ignored (so it could be an empty string).
      /// 
      /// @param guid
      ///   The GUID of the resource whose attributes should be retrieved.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Resource.guid" - if the parameter is missing
      ///   </li>
      ///   <li> PERMISSION_DENIED "Resource" - private resource, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Resource.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public Evernote.EDAM.Type.ResourceAttributes getResourceAttributes(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_getResourceAttributes(authenticationToken, guid);
        return recv_getResourceAttributes();

        #else
        var asyncResult = Begin_getResourceAttributes(null, null, authenticationToken, guid);
        return End_getResourceAttributes(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getResourceAttributes(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_getResourceAttributes(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getResourceAttributes", TMessageType.Call, seqid_));
        getResourceAttributes_args args = new getResourceAttributes_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.ResourceAttributes recv_getResourceAttributes()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getResourceAttributes_result result = new getResourceAttributes_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getResourceAttributes failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getPublicNotebook(AsyncCallback callback, object state, int userId, string publicUri)
      {
        return send_getPublicNotebook(callback, state, userId, publicUri);
      }

      public Evernote.EDAM.Type.Notebook End_getPublicNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getPublicNotebook();
      }

      #endif

      /// <summary>
      /// <p>
      /// Looks for a user account with the provided userId on this NoteStore
      /// shard and determines whether that account contains a public notebook
      /// with the given URI.  If the account is not found, or no public notebook
      /// exists with this URI, this will throw an EDAMNotFoundException,
      /// otherwise this will return the information for that Notebook.
      /// </p>
      /// <p>
      /// If a notebook is visible on the web with a full URL like
      /// http://www.evernote.com/pub/sethdemo/api
      /// Then 'sethdemo' is the username that can be used to look up the userId,
      /// and 'api' is the publicUri.
      /// </p>
      /// 
      /// @param userId
      ///    The numeric identifier for the user who owns the public notebook.
      ///    To find this value based on a username string, you can invoke
      ///    UserStore.getPublicUserInfo
      /// 
      /// @param publicUri
      ///    The uri string for the public notebook, from Notebook.publishing.uri.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Publishing.uri" - not found, by URI</li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> TAKEN_DOWN "PublicNotebook" - The specified public notebook is
      ///     taken down (for all requesters).</li>
      ///   <li> TAKEN_DOWN "Country" - The specified public notebook is taken
      ///     down for the requester because of an IP-based country lookup.</li>
      /// </ul>
      /// </summary>
      /// <param name="userId"></param>
      /// <param name="publicUri"></param>
      public Evernote.EDAM.Type.Notebook getPublicNotebook(int userId, string publicUri)
      {
        #if !SILVERLIGHT
        send_getPublicNotebook(userId, publicUri);
        return recv_getPublicNotebook();

        #else
        var asyncResult = Begin_getPublicNotebook(null, null, userId, publicUri);
        return End_getPublicNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getPublicNotebook(AsyncCallback callback, object state, int userId, string publicUri)
      #else
      public void send_getPublicNotebook(int userId, string publicUri)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getPublicNotebook", TMessageType.Call, seqid_));
        getPublicNotebook_args args = new getPublicNotebook_args();
        args.UserId = userId;
        args.PublicUri = publicUri;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Notebook recv_getPublicNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getPublicNotebook_result result = new getPublicNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getPublicNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_shareNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook, string message)
      {
        return send_shareNotebook(callback, state, authenticationToken, sharedNotebook, message);
      }

      public Evernote.EDAM.Type.SharedNotebook End_shareNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_shareNotebook();
      }

      #endif

      /// <summary>
      /// * @Deprecated for first-party clients. See createOrUpdateNotebookShares.
      /// *
      /// * Share a notebook with an email address, and optionally to a specific
      /// * recipient. If an existing SharedNotebook associated with
      /// * sharedNotebook.notebookGuid is found by recipientUsername or email, then
      /// * the values of sharedNotebook will be used to update the existing record,
      /// * else a new record will be created.
      /// *
      /// * If recipientUsername is set and there is already a SharedNotebook
      /// * for that Notebook with that recipientUsername and the privileges on the
      /// * existing notebook are lower, than on this one, this will update the
      /// * privileges and sharerUserId. If there isn't an existing SharedNotebook for
      /// * recipientUsername, this will create and return a shared notebook for that
      /// * email and recipientUsername. If recipientUsername is not set and there
      /// * already is a SharedNotebook for a Notebook for that email address and the
      /// * privileges on the existing SharedNotebook are lower than on this one, this
      /// * will update the privileges and sharerUserId, and return the updated
      /// * SharedNotebook. Otherwise, this will create and return a SharedNotebook for
      /// * the email address.
      /// *
      /// * If the authenticationToken is a Business auth token, recipientUsername is
      /// * set and the recipient is in the same business as the business auth token,
      /// * this method will also auto-join the business user to the SharedNotebook -
      /// * that is it will set serviceJoined on the SharedNotebook and create a
      /// * LinkedNotebook on the recipient's account pointing to the SharedNotebook.
      /// * The LinkedNotebook creation happens out-of-band, so there will be a delay
      /// * on the order of half a minute between the SharedNotebook and LinkedNotebook
      /// * creation.
      /// *
      /// * Also handles sending an email to the email addresses: if a SharedNotebook
      /// * is being created, this will send the shared notebook invite email, and
      /// * if a SharedNotebook already exists, it will send the shared notebook
      /// * reminder email. Both these emails contain a link to join the notebook.
      /// * If the notebook is being auto-joined, it sends an email with that
      /// * information to the recipient.
      /// *
      /// * @param authenticationToken
      /// *   Must be an authentication token from the owner or a shared notebook
      /// *   authentication token or business authentication token with sufficient
      /// *   permissions to change invitations for a notebook.
      /// *
      /// * @param sharedNotebook
      /// *   A shared notebook object populated with the email address of the share
      /// *   recipient, the notebook guid and the access permissions. All other
      /// *   attributes of the shared object are ignored. The SharedNotebook.allowPreview
      /// *   field must be explicitly set with either a true or false value.
      /// *
      /// * @param message
      /// *   The sharer-defined message to put in the email sent out.
      /// *
      /// * @return
      /// *   The fully populated SharedNotebook object including the server assigned
      /// *   globalId which can both be used to uniquely identify the SharedNotebook.
      /// *
      /// * @throws EDAMUserException <ul>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.email" - if the email was not valid</li>
      /// *   <li>DATA_REQUIRED "SharedNotebook.privilege" - if the
      /// *       SharedNotebook.privilegeLevel was not set.</li>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.requireLogin" - if requireLogin was
      /// *       set. requireLogin is deprecated.</li>
      /// *   <li>BAD_DATA_FORMAT "SharedNotebook.privilegeLevel" - if the
      /// *       SharedNotebook.privilegeLevel field was unset or set to GROUP.</li>
      /// *   <li>PERMISSION_DENIED "user" - if the email address on the authenticationToken's
      ///         owner's account is not confirmed.</li>
      /// *   <li>PERMISSION_DENIED "SharedNotebook.recipientSettings" - if
      /// *       recipientSettings is set in the sharedNotebook.  Only the recipient
      /// *       can set these values via the setSharedNotebookRecipientSettings
      /// *       method.</li>
      /// *   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - The notebook already has
      /// *       EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX shares.</li>
      /// *   </ul>
      /// * @throws EDAMNotFoundException <ul>
      /// *   <li>Notebook.guid - if the notebookGuid is not a valid GUID for the user.
      /// *   </li>
      /// *   </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="sharedNotebook"></param>
      /// <param name="message"></param>
      public Evernote.EDAM.Type.SharedNotebook shareNotebook(string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook, string message)
      {
        #if !SILVERLIGHT
        send_shareNotebook(authenticationToken, sharedNotebook, message);
        return recv_shareNotebook();

        #else
        var asyncResult = Begin_shareNotebook(null, null, authenticationToken, sharedNotebook, message);
        return End_shareNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_shareNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook, string message)
      #else
      public void send_shareNotebook(string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook, string message)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("shareNotebook", TMessageType.Call, seqid_));
        shareNotebook_args args = new shareNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.SharedNotebook = sharedNotebook;
        args.Message = message;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.SharedNotebook recv_shareNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        shareNotebook_result result = new shareNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "shareNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createOrUpdateNotebookShares(AsyncCallback callback, object state, string authenticationToken, NotebookShareTemplate shareTemplate)
      {
        return send_createOrUpdateNotebookShares(callback, state, authenticationToken, shareTemplate);
      }

      public CreateOrUpdateNotebookSharesResult End_createOrUpdateNotebookShares(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_createOrUpdateNotebookShares();
      }

      #endif

      /// <summary>
      /// Share a notebook by a messaging thread ID or a list of contacts. This function is
      /// intended to be used in conjunction with Evernote messaging, and as such does not
      /// notify the recipient that a notebook has been shared with them.
      /// 
      /// Sharing with a subset of participants on a thread is accomplished by specifying both
      /// a thread ID and a list of contacts. This ensures that even if those contacts are
      /// on the thread under a deactivated identity, the correct user (the one who has the
      /// given contact on the thread) receives the share.
      /// 
      /// @param authenticationToken
      ///   An authentication token that grants the caller permission to share the notebook.
      ///   This should be an owner token if the notebook is owned by the caller.
      ///   If the notebook is a business notebook to which the caller has full access,
      ///   this should be their business authentication token. If the notebook is a shared
      ///   (non-business) notebook to which the caller has full access, this should be the
      ///   shared notebook authentication token returned by NoteStore.authenticateToNotebook.
      /// 
      /// @param shareTemplate
      ///   Specifies the GUID of the notebook to be shared, the privilege at which the notebook
      ///   should be shared, and the recipient information.
      /// 
      /// @return
      ///   A structure containing the USN of the Notebook after the change and a list of created
      ///   or updated SharedNotebooks.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "Notebook.guid" - if no notebook GUID was specified</li>
      ///   <li>BAD_DATA_FORMAT "Notebook.guid" - if shareTemplate.notebookGuid is not a
      ///     valid GUID</li>
      ///   <li>DATA_REQUIRED "shareTemplate" - if the shareTemplate parameter was missing</li>
      ///   <li>DATA_REQUIRED "NotebookShareTemplate.privilege" - if no privilege was
      ///     specified</li>
      ///   <li>DATA_CONFLICT "NotebookShareTemplate.privilege" - if the specified privilege
      ///     is not allowed.</li>
      ///   <li>DATA_REQUIRED "NotebookShareTemplate.recipients" - if no recipients were
      ///     specified, either by thread ID or as a list of contacts</li>
      ///   <li>LIMIT_REACHED "SharedNotebook" - if the notebook has reached its maximum
      ///     number of shares</li>
      /// </ul>
      /// 
      /// @throws EDAMInvalidContactsException <ul>
      ///   <li>"NotebookShareTemplate.recipients" - if one or more of the recipients specified
      ///     in shareTemplate.recipients was not syntactically valid, or if attempting to
      ///     share a notebook with an Evernote identity that the sharer does not have a
      ///     connection to. The exception will specify which recipients were invalid.</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Notebook.guid" - if no notebook with the specified GUID was found</li>
      ///   <li>"NotebookShareTemplate.recipientThreadId" - if the recipient thread ID was
      ///     specified, but no thread with that ID exists</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="shareTemplate"></param>
      public CreateOrUpdateNotebookSharesResult createOrUpdateNotebookShares(string authenticationToken, NotebookShareTemplate shareTemplate)
      {
        #if !SILVERLIGHT
        send_createOrUpdateNotebookShares(authenticationToken, shareTemplate);
        return recv_createOrUpdateNotebookShares();

        #else
        var asyncResult = Begin_createOrUpdateNotebookShares(null, null, authenticationToken, shareTemplate);
        return End_createOrUpdateNotebookShares(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createOrUpdateNotebookShares(AsyncCallback callback, object state, string authenticationToken, NotebookShareTemplate shareTemplate)
      #else
      public void send_createOrUpdateNotebookShares(string authenticationToken, NotebookShareTemplate shareTemplate)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createOrUpdateNotebookShares", TMessageType.Call, seqid_));
        createOrUpdateNotebookShares_args args = new createOrUpdateNotebookShares_args();
        args.AuthenticationToken = authenticationToken;
        args.ShareTemplate = shareTemplate;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public CreateOrUpdateNotebookSharesResult recv_createOrUpdateNotebookShares()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createOrUpdateNotebookShares_result result = new createOrUpdateNotebookShares_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.invalidContactsException) {
          throw result.InvalidContactsException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "createOrUpdateNotebookShares failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateSharedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook)
      {
        return send_updateSharedNotebook(callback, state, authenticationToken, sharedNotebook);
      }

      public int End_updateSharedNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateSharedNotebook();
      }

      #endif

      /// <summary>
      /// @Deprecated See createOrUpdateNotebookShares and manageNotebookShares.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="sharedNotebook"></param>
      public int updateSharedNotebook(string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook)
      {
        #if !SILVERLIGHT
        send_updateSharedNotebook(authenticationToken, sharedNotebook);
        return recv_updateSharedNotebook();

        #else
        var asyncResult = Begin_updateSharedNotebook(null, null, authenticationToken, sharedNotebook);
        return End_updateSharedNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateSharedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook)
      #else
      public void send_updateSharedNotebook(string authenticationToken, Evernote.EDAM.Type.SharedNotebook sharedNotebook)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateSharedNotebook", TMessageType.Call, seqid_));
        updateSharedNotebook_args args = new updateSharedNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.SharedNotebook = sharedNotebook;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_updateSharedNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateSharedNotebook_result result = new updateSharedNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateSharedNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_setNotebookRecipientSettings(AsyncCallback callback, object state, string authenticationToken, string notebookGuid, Evernote.EDAM.Type.NotebookRecipientSettings recipientSettings)
      {
        return send_setNotebookRecipientSettings(callback, state, authenticationToken, notebookGuid, recipientSettings);
      }

      public Evernote.EDAM.Type.Notebook End_setNotebookRecipientSettings(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_setNotebookRecipientSettings();
      }

      #endif

      /// <summary>
      /// Set values for the recipient settings associated with a notebook share. Only the
      /// recipient of the share can update their recipient settings.
      /// 
      /// If you do <i>not</i> wish to, or cannot, change one of the recipient settings fields,
      /// you must leave that field unset in recipientSettings.
      /// This method will skip that field for updates and attempt to leave the existing value as
      /// it is.
      /// 
      /// If recipientSettings.inMyList is false, both reminderNotifyInApp and reminderNotifyEmail
      /// will be either left as null or converted to false (if currently true).
      /// 
      /// To unset a notebook's stack, pass in the empty string for the stack field.
      /// 
      /// @param authenticationToken The owner authentication token for the recipient of the share.
      /// 
      /// @return The updated Notebook with the new recipient settings. Note that some of the
      /// recipient settings may differ from what was requested. Clients should update their state
      /// based on this return value.
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>Notebook.guid - Thrown if the service does not have a notebook record with the
      ///       notebookGuid on the given shard.</li>
      ///   <li>Publishing.publishState - Thrown if the business notebook is not shared with the
      ///       user and is also not published to their business.</li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>PEMISSION_DENIED "authenticationToken" - If the owner of the given token is not
      ///       allowed to set recipient settings on the specified notebook.</li>
      ///   <li>DATA_CONFLICT "recipientSettings.reminderNotifyEmail" - Setting reminderNotifyEmail
      ///       is allowed only for notebooks which belong to the same business as the user.</li>
      ///   <li>DATA_CONFLICT "recipientSettings.inMyList" - If the request is setting inMyList
      ///       to false and any of reminder* settings to true.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      /// <param name="recipientSettings"></param>
      public Evernote.EDAM.Type.Notebook setNotebookRecipientSettings(string authenticationToken, string notebookGuid, Evernote.EDAM.Type.NotebookRecipientSettings recipientSettings)
      {
        #if !SILVERLIGHT
        send_setNotebookRecipientSettings(authenticationToken, notebookGuid, recipientSettings);
        return recv_setNotebookRecipientSettings();

        #else
        var asyncResult = Begin_setNotebookRecipientSettings(null, null, authenticationToken, notebookGuid, recipientSettings);
        return End_setNotebookRecipientSettings(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_setNotebookRecipientSettings(AsyncCallback callback, object state, string authenticationToken, string notebookGuid, Evernote.EDAM.Type.NotebookRecipientSettings recipientSettings)
      #else
      public void send_setNotebookRecipientSettings(string authenticationToken, string notebookGuid, Evernote.EDAM.Type.NotebookRecipientSettings recipientSettings)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("setNotebookRecipientSettings", TMessageType.Call, seqid_));
        setNotebookRecipientSettings_args args = new setNotebookRecipientSettings_args();
        args.AuthenticationToken = authenticationToken;
        args.NotebookGuid = notebookGuid;
        args.RecipientSettings = recipientSettings;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.Notebook recv_setNotebookRecipientSettings()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        setNotebookRecipientSettings_result result = new setNotebookRecipientSettings_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "setNotebookRecipientSettings failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listSharedNotebooks(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listSharedNotebooks(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.SharedNotebook> End_listSharedNotebooks(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listSharedNotebooks();
      }

      #endif

      /// <summary>
      /// Lists the collection of shared notebooks for all notebooks in the
      /// users account.
      /// 
      /// @return
      ///  The list of all SharedNotebooks for the user
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.SharedNotebook> listSharedNotebooks(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listSharedNotebooks(authenticationToken);
        return recv_listSharedNotebooks();

        #else
        var asyncResult = Begin_listSharedNotebooks(null, null, authenticationToken);
        return End_listSharedNotebooks(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listSharedNotebooks(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listSharedNotebooks(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listSharedNotebooks", TMessageType.Call, seqid_));
        listSharedNotebooks_args args = new listSharedNotebooks_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.SharedNotebook> recv_listSharedNotebooks()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listSharedNotebooks_result result = new listSharedNotebooks_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listSharedNotebooks failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_createLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      {
        return send_createLinkedNotebook(callback, state, authenticationToken, linkedNotebook);
      }

      public Evernote.EDAM.Type.LinkedNotebook End_createLinkedNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_createLinkedNotebook();
      }

      #endif

      /// <summary>
      /// Asks the service to make a linked notebook with the provided name, username
      /// of the owner and identifiers provided. A linked notebook can be either a
      /// link to a public notebook or to a private shared notebook.
      /// 
      /// @param linkedNotebook
      ///   The desired fields for the linked notebook must be provided on this
      ///   object.  The name of the linked notebook must be set. Either a username
      ///   uri or a shard id and share key must be provided otherwise a
      ///   EDAMUserException is thrown.
      /// 
      /// @return
      ///   The newly created LinkedNotebook.  The server-side id will be
      ///   saved in this object's 'id' field.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.name" - invalid shareName length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.username" - bad username format
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.uri" -
      ///     if public notebook set but bad uri
      ///   </li>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shardId" -
      ///     if private notebook but shard id not provided
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.sharedNotebookGlobalId" -
      ///     if a bad global identifer was set on a private notebook
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      public Evernote.EDAM.Type.LinkedNotebook createLinkedNotebook(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      {
        #if !SILVERLIGHT
        send_createLinkedNotebook(authenticationToken, linkedNotebook);
        return recv_createLinkedNotebook();

        #else
        var asyncResult = Begin_createLinkedNotebook(null, null, authenticationToken, linkedNotebook);
        return End_createLinkedNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_createLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      #else
      public void send_createLinkedNotebook(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("createLinkedNotebook", TMessageType.Call, seqid_));
        createLinkedNotebook_args args = new createLinkedNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.LinkedNotebook = linkedNotebook;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.LinkedNotebook recv_createLinkedNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        createLinkedNotebook_result result = new createLinkedNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "createLinkedNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      {
        return send_updateLinkedNotebook(callback, state, authenticationToken, linkedNotebook);
      }

      public int End_updateLinkedNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateLinkedNotebook();
      }

      #endif

      /// <summary>
      /// @param linkedNotebook
      ///   Updates the name of a linked notebook.
      /// 
      /// @return
      ///   The Update Sequence Number for this change within the account.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "LinkedNotebook.shareName" - missing shareName
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.shareName" - invalid shareName length or pattern
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "LinkedNotebook.stack" - invalid stack name length or pattern
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="linkedNotebook"></param>
      public int updateLinkedNotebook(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      {
        #if !SILVERLIGHT
        send_updateLinkedNotebook(authenticationToken, linkedNotebook);
        return recv_updateLinkedNotebook();

        #else
        var asyncResult = Begin_updateLinkedNotebook(null, null, authenticationToken, linkedNotebook);
        return End_updateLinkedNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      #else
      public void send_updateLinkedNotebook(string authenticationToken, Evernote.EDAM.Type.LinkedNotebook linkedNotebook)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateLinkedNotebook", TMessageType.Call, seqid_));
        updateLinkedNotebook_args args = new updateLinkedNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.LinkedNotebook = linkedNotebook;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_updateLinkedNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateLinkedNotebook_result result = new updateLinkedNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateLinkedNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_listLinkedNotebooks(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_listLinkedNotebooks(callback, state, authenticationToken);
      }

      public List<Evernote.EDAM.Type.LinkedNotebook> End_listLinkedNotebooks(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_listLinkedNotebooks();
      }

      #endif

      /// <summary>
      /// Returns a list of linked notebooks
      /// </summary>
      /// <param name="authenticationToken"></param>
      public List<Evernote.EDAM.Type.LinkedNotebook> listLinkedNotebooks(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_listLinkedNotebooks(authenticationToken);
        return recv_listLinkedNotebooks();

        #else
        var asyncResult = Begin_listLinkedNotebooks(null, null, authenticationToken);
        return End_listLinkedNotebooks(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_listLinkedNotebooks(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_listLinkedNotebooks(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("listLinkedNotebooks", TMessageType.Call, seqid_));
        listLinkedNotebooks_args args = new listLinkedNotebooks_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public List<Evernote.EDAM.Type.LinkedNotebook> recv_listLinkedNotebooks()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        listLinkedNotebooks_result result = new listLinkedNotebooks_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "listLinkedNotebooks failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_expungeLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_expungeLinkedNotebook(callback, state, authenticationToken, guid);
      }

      public int End_expungeLinkedNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_expungeLinkedNotebook();
      }

      #endif

      /// <summary>
      /// Permanently expunges the linked notebook from the account.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param guid
      ///   The LinkedNotebook.guid field of the LinkedNotebook to permanently remove
      ///   from the account.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public int expungeLinkedNotebook(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_expungeLinkedNotebook(authenticationToken, guid);
        return recv_expungeLinkedNotebook();

        #else
        var asyncResult = Begin_expungeLinkedNotebook(null, null, authenticationToken, guid);
        return End_expungeLinkedNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_expungeLinkedNotebook(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_expungeLinkedNotebook(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("expungeLinkedNotebook", TMessageType.Call, seqid_));
        expungeLinkedNotebook_args args = new expungeLinkedNotebook_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public int recv_expungeLinkedNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        expungeLinkedNotebook_result result = new expungeLinkedNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "expungeLinkedNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_authenticateToSharedNotebook(AsyncCallback callback, object state, string shareKeyOrGlobalId, string authenticationToken)
      {
        return send_authenticateToSharedNotebook(callback, state, shareKeyOrGlobalId, authenticationToken);
      }

      public Evernote.EDAM.UserStore.AuthenticationResult End_authenticateToSharedNotebook(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_authenticateToSharedNotebook();
      }

      #endif

      /// <summary>
      /// Asks the service to produce an authentication token that can be used to
      /// access the contents of a shared notebook from someone else's account.
      /// This authenticationToken can be used with the various other NoteStore
      /// calls to find and retrieve notes, and if the permissions in the shared
      /// notebook are sufficient, to make changes to the contents of the notebook.
      /// 
      /// @param shareKeyOrGlobalId
      ///   May be one of the following:
      ///   <ul>
      ///     <li>A share key for a shared notebook that was granted to some recipient
      ///         Must be used if you are joining a notebook unless it was shared via
      ///         createOrUpdateNotebookShares. Share keys are delivered out-of-band
      ///         and are generally not available to clients. For security reasons,
      ///         share keys may be invalidated at the discretion of the service.
      ///     </li>
      ///     <li>The shared notebook global identifier. May be used to access a
      ///         notebook that is already joined.
      ///     </li>
      ///     <li>The Notebook GUID. May be used to access a notebook that was already
      ///         joined, or to access a notebook that was shared with the recipient
      ///         via createOrUpdateNotebookShares.
      ///     </li>
      ///   </ul>
      /// 
      /// @param authenticationToken
      ///   If a non-empty string is provided, this is the full user-based
      ///   authentication token that identifies the user who is currently logged in
      ///   and trying to access the shared notebook.
      ///   If this string is empty, the service will attempt to authenticate to the
      ///   shared notebook without any logged in user.
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> BAD_DATA_FORMAT "shareKey" - invalid shareKey string</li>
      ///   <li> INVALID_AUTH "shareKey" - bad signature on shareKey string</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SharedNotebook.id" - the shared notebook no longer exists</li>
      /// </ul>
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> DATA_REQUIRED "authenticationToken" - the share requires login, and
      ///          no valid authentication token was provided.
      ///   </li>
      ///   <li> PERMISSION_DENIED "SharedNotebook.username" - share requires login,
      ///          and another username has already been bound to this notebook.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="shareKeyOrGlobalId"></param>
      /// <param name="authenticationToken"></param>
      public Evernote.EDAM.UserStore.AuthenticationResult authenticateToSharedNotebook(string shareKeyOrGlobalId, string authenticationToken)
      {
        #if !SILVERLIGHT
        send_authenticateToSharedNotebook(shareKeyOrGlobalId, authenticationToken);
        return recv_authenticateToSharedNotebook();

        #else
        var asyncResult = Begin_authenticateToSharedNotebook(null, null, shareKeyOrGlobalId, authenticationToken);
        return End_authenticateToSharedNotebook(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_authenticateToSharedNotebook(AsyncCallback callback, object state, string shareKeyOrGlobalId, string authenticationToken)
      #else
      public void send_authenticateToSharedNotebook(string shareKeyOrGlobalId, string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("authenticateToSharedNotebook", TMessageType.Call, seqid_));
        authenticateToSharedNotebook_args args = new authenticateToSharedNotebook_args();
        args.ShareKeyOrGlobalId = shareKeyOrGlobalId;
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.UserStore.AuthenticationResult recv_authenticateToSharedNotebook()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        authenticateToSharedNotebook_result result = new authenticateToSharedNotebook_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "authenticateToSharedNotebook failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getSharedNotebookByAuth(AsyncCallback callback, object state, string authenticationToken)
      {
        return send_getSharedNotebookByAuth(callback, state, authenticationToken);
      }

      public Evernote.EDAM.Type.SharedNotebook End_getSharedNotebookByAuth(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getSharedNotebookByAuth();
      }

      #endif

      /// <summary>
      /// This function is used to retrieve extended information about a shared
      /// notebook by a guest who has already authenticated to access that notebook.
      /// This requires an 'authenticationToken' parameter which should be the
      /// resut of a call to authenticateToSharedNotebook(...).
      /// I.e. this is the token that gives access to the particular shared notebook
      /// in someone else's account -- it's not the authenticationToken for the
      /// owner of the notebook itself.
      /// 
      /// @param authenticationToken
      ///   Should be the authentication token retrieved from the reply of
      ///   authenticateToSharedNotebook(), proving access to a particular shared
      ///   notebook.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "authenticationToken" -
      ///          authentication token doesn't correspond to a valid shared notebook
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "SharedNotebook.id" - the shared notebook no longer exists
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      public Evernote.EDAM.Type.SharedNotebook getSharedNotebookByAuth(string authenticationToken)
      {
        #if !SILVERLIGHT
        send_getSharedNotebookByAuth(authenticationToken);
        return recv_getSharedNotebookByAuth();

        #else
        var asyncResult = Begin_getSharedNotebookByAuth(null, null, authenticationToken);
        return End_getSharedNotebookByAuth(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getSharedNotebookByAuth(AsyncCallback callback, object state, string authenticationToken)
      #else
      public void send_getSharedNotebookByAuth(string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getSharedNotebookByAuth", TMessageType.Call, seqid_));
        getSharedNotebookByAuth_args args = new getSharedNotebookByAuth_args();
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.Type.SharedNotebook recv_getSharedNotebookByAuth()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getSharedNotebookByAuth_result result = new getSharedNotebookByAuth_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getSharedNotebookByAuth failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_emailNote(AsyncCallback callback, object state, string authenticationToken, NoteEmailParameters parameters)
      {
        return send_emailNote(callback, state, authenticationToken, parameters);
      }

      public void End_emailNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_emailNote();
      }

      #endif

      /// <summary>
      /// Attempts to send a single note to one or more email recipients.
      /// <p/>
      /// NOTE: This function is generally not available to third party applications.
      /// Calls will result in an EDAMUserException with the error code
      /// PERMISSION_DENIED.
      /// 
      /// @param authenticationToken
      ///    The note will be sent as the user logged in via this token, using that
      ///    user's registered email address.  If the authenticated user doesn't
      ///    have permission to read that note, the emailing will fail.
      /// 
      /// @param parameters
      ///    The note must be specified either by GUID (in which case it will be
      ///    sent using the existing data in the service), or else the full Note
      ///    must be passed to this call.  This also specifies the additional
      ///    email fields that will be used in the email.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> LIMIT_REACHED "NoteEmailParameters.toAddresses" -
      ///     The email can't be sent because this would exceed the user's daily
      ///     email limit.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "(email address)" -
      ///     email address malformed
      ///   </li>
      ///   <li> DATA_REQUIRED "NoteEmailParameters.toAddresses" -
      ///     if there are no To: or Cc: addresses provided.
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.title" -
      ///     if the caller provides a Note parameter with no title
      ///   </li>
      ///   <li> DATA_REQUIRED "Note.content" -
      ///     if the caller provides a Note parameter with no content
      ///   </li>
      ///   <li> ENML_VALIDATION "*" - note content doesn't validate against DTD
      ///   </li>
      ///   <li> DATA_REQUIRED "NoteEmailParameters.note" -
      ///     if no guid or note provided
      ///   </li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="parameters"></param>
      public void emailNote(string authenticationToken, NoteEmailParameters parameters)
      {
        #if !SILVERLIGHT
        send_emailNote(authenticationToken, parameters);
        recv_emailNote();

        #else
        var asyncResult = Begin_emailNote(null, null, authenticationToken, parameters);
        End_emailNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_emailNote(AsyncCallback callback, object state, string authenticationToken, NoteEmailParameters parameters)
      #else
      public void send_emailNote(string authenticationToken, NoteEmailParameters parameters)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("emailNote", TMessageType.Call, seqid_));
        emailNote_args args = new emailNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Parameters = parameters;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_emailNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        emailNote_result result = new emailNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_shareNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_shareNote(callback, state, authenticationToken, guid);
      }

      public string End_shareNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_shareNote();
      }

      #endif

      /// <summary>
      /// If this note is not already shared publicly (via its own direct URL), then this
      /// will start sharing that note.
      /// This will return the secret "Note Key" for this note that
      /// can currently be used in conjunction with the Note's GUID to gain direct
      /// read-only access to the Note.
      /// If the note is already shared, then this won't make any changes to the
      /// note, and the existing "Note Key" will be returned.  The only way to change
      /// the Note Key for an existing note is to stopSharingNote first, and then
      /// call this function.
      /// 
      /// @param guid
      ///   The GUID of the note to be shared.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "Note.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public string shareNote(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_shareNote(authenticationToken, guid);
        return recv_shareNote();

        #else
        var asyncResult = Begin_shareNote(null, null, authenticationToken, guid);
        return End_shareNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_shareNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_shareNote(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("shareNote", TMessageType.Call, seqid_));
        shareNote_args args = new shareNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public string recv_shareNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        shareNote_result result = new shareNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "shareNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_stopSharingNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      {
        return send_stopSharingNote(callback, state, authenticationToken, guid);
      }

      public void End_stopSharingNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        recv_stopSharingNote();
      }

      #endif

      /// <summary>
      /// If this note is shared publicly then this will stop sharing that note
      /// and invalidate its "Note Key", so any existing URLs to access that Note
      /// will stop working.
      /// 
      /// If the Note is not shared, then this function will do nothing.
      /// 
      /// This function does not remove invididual shares for the note. To remove
      /// individual shares, see stopSharingNoteWithRecipients.
      /// 
      /// @param guid
      ///   The GUID of the note to be un-shared.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> BAD_DATA_FORMAT "Note.guid" - if the parameter is missing</li>
      ///   <li> PERMISSION_DENIED "Note" - private note, user doesn't own</li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"Note.guid" - not found, by GUID</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="guid"></param>
      public void stopSharingNote(string authenticationToken, string guid)
      {
        #if !SILVERLIGHT
        send_stopSharingNote(authenticationToken, guid);
        recv_stopSharingNote();

        #else
        var asyncResult = Begin_stopSharingNote(null, null, authenticationToken, guid);
        End_stopSharingNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_stopSharingNote(AsyncCallback callback, object state, string authenticationToken, string guid)
      #else
      public void send_stopSharingNote(string authenticationToken, string guid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("stopSharingNote", TMessageType.Call, seqid_));
        stopSharingNote_args args = new stopSharingNote_args();
        args.AuthenticationToken = authenticationToken;
        args.Guid = guid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public void recv_stopSharingNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        stopSharingNote_result result = new stopSharingNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        return;
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_authenticateToSharedNote(AsyncCallback callback, object state, string guid, string noteKey, string authenticationToken)
      {
        return send_authenticateToSharedNote(callback, state, guid, noteKey, authenticationToken);
      }

      public Evernote.EDAM.UserStore.AuthenticationResult End_authenticateToSharedNote(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_authenticateToSharedNote();
      }

      #endif

      /// <summary>
      /// Asks the service to produce an authentication token that can be used to
      /// access the contents of a single Note which was individually shared
      /// from someone's account.
      /// This authenticationToken can be used with the various other NoteStore
      /// calls to find and retrieve the Note and its directly-referenced children.
      /// 
      /// @param guid
      ///   The GUID identifying this Note on this shard.
      /// 
      /// @param noteKey
      ///   The 'noteKey' identifier from the Note that was originally created via
      ///   a call to shareNote() and then given to a recipient to access.
      /// 
      /// @param authenticationToken
      ///   An optional authenticationToken that identifies the user accessing the
      ///   shared note. This parameter may be required to access some shared notes.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li> PERMISSION_DENIED "Note" - the Note with that GUID is either not
      ///     shared, or the noteKey doesn't match the current key for this note
      ///   </li>
      ///   <li> PERMISSION_DENIED "authenticationToken" - an authentication token is
      ///     required to access this Note, but either no authentication token or a
      ///     "non-owner" authentication token was provided.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li> "guid" - the note with that GUID is not found
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMSystemException <ul>
      ///   <li> TAKEN_DOWN "Note" - The specified shared note is taken down (for
      ///     all requesters).
      ///   </li>
      ///   <li> TAKEN_DOWN "Country" - The specified shared note is taken down
      ///     for the requester because of an IP-based country lookup.
      ///   </ul>
      /// </ul>
      /// </summary>
      /// <param name="guid"></param>
      /// <param name="noteKey"></param>
      /// <param name="authenticationToken"></param>
      public Evernote.EDAM.UserStore.AuthenticationResult authenticateToSharedNote(string guid, string noteKey, string authenticationToken)
      {
        #if !SILVERLIGHT
        send_authenticateToSharedNote(guid, noteKey, authenticationToken);
        return recv_authenticateToSharedNote();

        #else
        var asyncResult = Begin_authenticateToSharedNote(null, null, guid, noteKey, authenticationToken);
        return End_authenticateToSharedNote(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_authenticateToSharedNote(AsyncCallback callback, object state, string guid, string noteKey, string authenticationToken)
      #else
      public void send_authenticateToSharedNote(string guid, string noteKey, string authenticationToken)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("authenticateToSharedNote", TMessageType.Call, seqid_));
        authenticateToSharedNote_args args = new authenticateToSharedNote_args();
        args.Guid = guid;
        args.NoteKey = noteKey;
        args.AuthenticationToken = authenticationToken;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public Evernote.EDAM.UserStore.AuthenticationResult recv_authenticateToSharedNote()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        authenticateToSharedNote_result result = new authenticateToSharedNote_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "authenticateToSharedNote failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_findRelated(AsyncCallback callback, object state, string authenticationToken, RelatedQuery query, RelatedResultSpec resultSpec)
      {
        return send_findRelated(callback, state, authenticationToken, query, resultSpec);
      }

      public RelatedResult End_findRelated(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_findRelated();
      }

      #endif

      /// <summary>
      /// Identify related entities on the service, such as notes,
      /// notebooks, tags and users in a business related to notes or content.
      /// 
      /// @param query
      ///   The information about which we are finding related entities.
      /// 
      /// @param resultSpec
      ///   Allows the client to indicate the type and quantity of
      ///   information to be returned, allowing a saving of time and
      ///   bandwidth.
      /// 
      /// @return
      ///   The result of the query, with information considered
      ///   to likely be relevantly related to the information
      ///   described by the query.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>BAD_DATA_FORMAT "RelatedQuery.plainText" - If you provided a
      ///     a zero-length plain text value.
      ///   </li>
      ///   <li>BAD_DATA_FORMAT "RelatedQuery.noteGuid" - If you provided an
      ///     invalid Note GUID, that is, one that does not match the constraints
      ///     defined by EDAM_GUID_LEN_MIN, EDAM_GUID_LEN_MAX, EDAM_GUID_REGEX.
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.notebookGuid" - if malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.tagGuids" - if any are malformed
      ///   </li>
      ///   <li> BAD_DATA_FORMAT "NoteFilter.words" - if search string too long
      ///   </li>
      ///   <li>PERMISSION_DENIED "Note" - If the caller does not have access to
      ///     the note identified by RelatedQuery.noteGuid.
      ///   </li>
      ///   <li>PERMISSION_DENIED "authenticationToken" - If the caller has requested to
      ///     findExperts in the context of a non business user (i.e. The authenticationToken
      ///     is not a business auth token).
      ///   </li>
      ///   <li>DATA_REQUIRED "RelatedResultSpec" - If you did not not set any values
      ///     in the result spec.
      ///   </li>
      /// </ul>
      /// 
      /// @throws EDAMNotFoundException <ul>
      ///   <li>"RelatedQuery.noteGuid" - the note with that GUID is not
      ///     found, if that field has been set in the query.
      ///   </li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="query"></param>
      /// <param name="resultSpec"></param>
      public RelatedResult findRelated(string authenticationToken, RelatedQuery query, RelatedResultSpec resultSpec)
      {
        #if !SILVERLIGHT
        send_findRelated(authenticationToken, query, resultSpec);
        return recv_findRelated();

        #else
        var asyncResult = Begin_findRelated(null, null, authenticationToken, query, resultSpec);
        return End_findRelated(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_findRelated(AsyncCallback callback, object state, string authenticationToken, RelatedQuery query, RelatedResultSpec resultSpec)
      #else
      public void send_findRelated(string authenticationToken, RelatedQuery query, RelatedResultSpec resultSpec)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("findRelated", TMessageType.Call, seqid_));
        findRelated_args args = new findRelated_args();
        args.AuthenticationToken = authenticationToken;
        args.Query = query;
        args.ResultSpec = resultSpec;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public RelatedResult recv_findRelated()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        findRelated_result result = new findRelated_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "findRelated failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_updateNoteIfUsnMatches(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note)
      {
        return send_updateNoteIfUsnMatches(callback, state, authenticationToken, note);
      }

      public UpdateNoteIfUsnMatchesResult End_updateNoteIfUsnMatches(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_updateNoteIfUsnMatches();
      }

      #endif

      /// <summary>
      /// Perform the same operation as updateNote() would provided that the update
      /// sequence number on the parameter Note object matches the current update sequence
      /// number that the service has for the note.  If they do <i>not</i> match, then
      /// <i>no</i> update is performed and the return value will have the current server
      /// state in the note field and updated will be false.  If the update sequence
      /// numbers between the client and server do match, then the note will be updated
      /// and the note field of the return value will be returned as it would be for the
      /// updateNote method.  This method allows you to check for an update to the note
      /// on the service, by another client instance, from when you obtained the
      /// note state as a baseline for your edits and the time when you wish to save your
      /// edits.  If your client can merge the conflict, you can avoid overwriting changes
      /// that were saved to the service by the other client.
      /// 
      /// See the updateNote method for information on the exceptions and parameters for
      /// this method.  The only difference is that you must have an update sequence number
      /// defined on the note parameter (equal to the USN of the note as synched to the
      /// client), and the following additional exceptions might be thrown.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>DATA_REQUIRED "Note.updateSequenceNum" - If the update sequence number was
      ///       not provided.  This includes a value that is set as 0.</li>
      ///   <li>BAD_DATA_FORMAT "Note.updateSequenceNum" - If the note has an update
      ///       sequence number that is larger than the current server value, which should
      ///       not happen if your client is working correctly.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="note"></param>
      public UpdateNoteIfUsnMatchesResult updateNoteIfUsnMatches(string authenticationToken, Evernote.EDAM.Type.Note note)
      {
        #if !SILVERLIGHT
        send_updateNoteIfUsnMatches(authenticationToken, note);
        return recv_updateNoteIfUsnMatches();

        #else
        var asyncResult = Begin_updateNoteIfUsnMatches(null, null, authenticationToken, note);
        return End_updateNoteIfUsnMatches(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_updateNoteIfUsnMatches(AsyncCallback callback, object state, string authenticationToken, Evernote.EDAM.Type.Note note)
      #else
      public void send_updateNoteIfUsnMatches(string authenticationToken, Evernote.EDAM.Type.Note note)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("updateNoteIfUsnMatches", TMessageType.Call, seqid_));
        updateNoteIfUsnMatches_args args = new updateNoteIfUsnMatches_args();
        args.AuthenticationToken = authenticationToken;
        args.Note = note;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public UpdateNoteIfUsnMatchesResult recv_updateNoteIfUsnMatches()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        updateNoteIfUsnMatches_result result = new updateNoteIfUsnMatches_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "updateNoteIfUsnMatches failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_manageNotebookShares(AsyncCallback callback, object state, string authenticationToken, ManageNotebookSharesParameters parameters)
      {
        return send_manageNotebookShares(callback, state, authenticationToken, parameters);
      }

      public ManageNotebookSharesResult End_manageNotebookShares(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_manageNotebookShares();
      }

      #endif

      /// <summary>
      /// Manage invitations and memberships associated with a given notebook.
      /// 
      /// <i>Note:</i> Beta method! This method is currently intended for
      /// limited use by Evernote clients that have discussed using this
      /// routine with the platform team.
      /// 
      /// @param parameters A structure containing all parameters for the updates.
      ///    See the structure documentation for details.
      /// 
      /// @throws EDAMUserException <ul>
      ///   <li>EDAMErrorCode.LIMIT_REACHED "SharedNotebook" - Trying to share a
      ///    notebook while the notebook already has EDAM_NOTEBOOK_SHARED_NOTEBOOK_MAX
      ///    shares.</li>
      /// </ul>
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="parameters"></param>
      public ManageNotebookSharesResult manageNotebookShares(string authenticationToken, ManageNotebookSharesParameters parameters)
      {
        #if !SILVERLIGHT
        send_manageNotebookShares(authenticationToken, parameters);
        return recv_manageNotebookShares();

        #else
        var asyncResult = Begin_manageNotebookShares(null, null, authenticationToken, parameters);
        return End_manageNotebookShares(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_manageNotebookShares(AsyncCallback callback, object state, string authenticationToken, ManageNotebookSharesParameters parameters)
      #else
      public void send_manageNotebookShares(string authenticationToken, ManageNotebookSharesParameters parameters)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("manageNotebookShares", TMessageType.Call, seqid_));
        manageNotebookShares_args args = new manageNotebookShares_args();
        args.AuthenticationToken = authenticationToken;
        args.Parameters = parameters;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public ManageNotebookSharesResult recv_manageNotebookShares()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        manageNotebookShares_result result = new manageNotebookShares_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "manageNotebookShares failed: unknown result");
      }

      
      #if SILVERLIGHT
      public IAsyncResult Begin_getNotebookShares(AsyncCallback callback, object state, string authenticationToken, string notebookGuid)
      {
        return send_getNotebookShares(callback, state, authenticationToken, notebookGuid);
      }

      public ShareRelationships End_getNotebookShares(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_getNotebookShares();
      }

      #endif

      /// <summary>
      /// Return the share relationships for the given notebook, including
      /// both the invitations and the memberships.
      /// 
      /// <i>Note:</i> Beta method! This method is currently intended for
      /// limited use by Evernote clients that have discussed using this
      /// routine with the platform team.
      /// </summary>
      /// <param name="authenticationToken"></param>
      /// <param name="notebookGuid"></param>
      public ShareRelationships getNotebookShares(string authenticationToken, string notebookGuid)
      {
        #if !SILVERLIGHT
        send_getNotebookShares(authenticationToken, notebookGuid);
        return recv_getNotebookShares();

        #else
        var asyncResult = Begin_getNotebookShares(null, null, authenticationToken, notebookGuid);
        return End_getNotebookShares(asyncResult);

        #endif
      }
      #if SILVERLIGHT
      public IAsyncResult send_getNotebookShares(AsyncCallback callback, object state, string authenticationToken, string notebookGuid)
      #else
      public void send_getNotebookShares(string authenticationToken, string notebookGuid)
      #endif
      {
        oprot_.WriteMessageBegin(new TMessage("getNotebookShares", TMessageType.Call, seqid_));
        getNotebookShares_args args = new getNotebookShares_args();
        args.AuthenticationToken = authenticationToken;
        args.NotebookGuid = notebookGuid;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        #if SILVERLIGHT
        return oprot_.Transport.BeginFlush(callback, state);
        #else
        oprot_.Transport.Flush();
        #endif
      }

      public ShareRelationships recv_getNotebookShares()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        getNotebookShares_result result = new getNotebookShares_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        if (result.__isset.userException) {
          throw result.UserException;
        }
        if (result.__isset.notFoundException) {
          throw result.NotFoundException;
        }
        if (result.__isset.systemException) {
          throw result.SystemException;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "getNotebookShares failed: unknown result");
      }

    }
    public class Processor : TProcessor {
      public Processor(ISync iface)
      {
        iface_ = iface;
        processMap_["getSyncState"] = getSyncState_Process;
        processMap_["getFilteredSyncChunk"] = getFilteredSyncChunk_Process;
        processMap_["getLinkedNotebookSyncState"] = getLinkedNotebookSyncState_Process;
        processMap_["getLinkedNotebookSyncChunk"] = getLinkedNotebookSyncChunk_Process;
        processMap_["listNotebooks"] = listNotebooks_Process;
        processMap_["listAccessibleBusinessNotebooks"] = listAccessibleBusinessNotebooks_Process;
        processMap_["getNotebook"] = getNotebook_Process;
        processMap_["getDefaultNotebook"] = getDefaultNotebook_Process;
        processMap_["createNotebook"] = createNotebook_Process;
        processMap_["updateNotebook"] = updateNotebook_Process;
        processMap_["expungeNotebook"] = expungeNotebook_Process;
        processMap_["listTags"] = listTags_Process;
        processMap_["listTagsByNotebook"] = listTagsByNotebook_Process;
        processMap_["getTag"] = getTag_Process;
        processMap_["createTag"] = createTag_Process;
        processMap_["updateTag"] = updateTag_Process;
        processMap_["untagAll"] = untagAll_Process;
        processMap_["expungeTag"] = expungeTag_Process;
        processMap_["listSearches"] = listSearches_Process;
        processMap_["getSearch"] = getSearch_Process;
        processMap_["createSearch"] = createSearch_Process;
        processMap_["updateSearch"] = updateSearch_Process;
        processMap_["expungeSearch"] = expungeSearch_Process;
        processMap_["findNoteOffset"] = findNoteOffset_Process;
        processMap_["findNotesMetadata"] = findNotesMetadata_Process;
        processMap_["findNoteCounts"] = findNoteCounts_Process;
        processMap_["getNoteWithResultSpec"] = getNoteWithResultSpec_Process;
        processMap_["getNote"] = getNote_Process;
        processMap_["getNoteApplicationData"] = getNoteApplicationData_Process;
        processMap_["getNoteApplicationDataEntry"] = getNoteApplicationDataEntry_Process;
        processMap_["setNoteApplicationDataEntry"] = setNoteApplicationDataEntry_Process;
        processMap_["unsetNoteApplicationDataEntry"] = unsetNoteApplicationDataEntry_Process;
        processMap_["getNoteContent"] = getNoteContent_Process;
        processMap_["getNoteSearchText"] = getNoteSearchText_Process;
        processMap_["getResourceSearchText"] = getResourceSearchText_Process;
        processMap_["getNoteTagNames"] = getNoteTagNames_Process;
        processMap_["createNote"] = createNote_Process;
        processMap_["updateNote"] = updateNote_Process;
        processMap_["deleteNote"] = deleteNote_Process;
        processMap_["expungeNote"] = expungeNote_Process;
        processMap_["copyNote"] = copyNote_Process;
        processMap_["listNoteVersions"] = listNoteVersions_Process;
        processMap_["getNoteVersion"] = getNoteVersion_Process;
        processMap_["getResource"] = getResource_Process;
        processMap_["getResourceApplicationData"] = getResourceApplicationData_Process;
        processMap_["getResourceApplicationDataEntry"] = getResourceApplicationDataEntry_Process;
        processMap_["setResourceApplicationDataEntry"] = setResourceApplicationDataEntry_Process;
        processMap_["unsetResourceApplicationDataEntry"] = unsetResourceApplicationDataEntry_Process;
        processMap_["updateResource"] = updateResource_Process;
        processMap_["getResourceData"] = getResourceData_Process;
        processMap_["getResourceByHash"] = getResourceByHash_Process;
        processMap_["getResourceRecognition"] = getResourceRecognition_Process;
        processMap_["getResourceAlternateData"] = getResourceAlternateData_Process;
        processMap_["getResourceAttributes"] = getResourceAttributes_Process;
        processMap_["getPublicNotebook"] = getPublicNotebook_Process;
        processMap_["shareNotebook"] = shareNotebook_Process;
        processMap_["createOrUpdateNotebookShares"] = createOrUpdateNotebookShares_Process;
        processMap_["updateSharedNotebook"] = updateSharedNotebook_Process;
        processMap_["setNotebookRecipientSettings"] = setNotebookRecipientSettings_Process;
        processMap_["listSharedNotebooks"] = listSharedNotebooks_Process;
        processMap_["createLinkedNotebook"] = createLinkedNotebook_Process;
        processMap_["updateLinkedNotebook"] = updateLinkedNotebook_Process;
        processMap_["listLinkedNotebooks"] = listLinkedNotebooks_Process;
        processMap_["expungeLinkedNotebook"] = expungeLinkedNotebook_Process;
        processMap_["authenticateToSharedNotebook"] = authenticateToSharedNotebook_Process;
        processMap_["getSharedNotebookByAuth"] = getSharedNotebookByAuth_Process;
        processMap_["emailNote"] = emailNote_Process;
        processMap_["shareNote"] = shareNote_Process;
        processMap_["stopSharingNote"] = stopSharingNote_Process;
        processMap_["authenticateToSharedNote"] = authenticateToSharedNote_Process;
        processMap_["findRelated"] = findRelated_Process;
        processMap_["updateNoteIfUsnMatches"] = updateNoteIfUsnMatches_Process;
        processMap_["manageNotebookShares"] = manageNotebookShares_Process;
        processMap_["getNotebookShares"] = getNotebookShares_Process;
      }

      protected delegate void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private ISync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public bool Process(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public void getSyncState_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getSyncState_args args = new getSyncState_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getSyncState_result result = new getSyncState_result();
        try
        {
          try
          {
            result.Success = iface_.getSyncState(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getSyncState", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getSyncState", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getFilteredSyncChunk_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getFilteredSyncChunk_args args = new getFilteredSyncChunk_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getFilteredSyncChunk_result result = new getFilteredSyncChunk_result();
        try
        {
          try
          {
            result.Success = iface_.getFilteredSyncChunk(args.AuthenticationToken, args.AfterUSN, args.MaxEntries, args.Filter);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getFilteredSyncChunk", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getFilteredSyncChunk", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getLinkedNotebookSyncState_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getLinkedNotebookSyncState_args args = new getLinkedNotebookSyncState_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getLinkedNotebookSyncState_result result = new getLinkedNotebookSyncState_result();
        try
        {
          try
          {
            result.Success = iface_.getLinkedNotebookSyncState(args.AuthenticationToken, args.LinkedNotebook);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getLinkedNotebookSyncState", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getLinkedNotebookSyncState", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getLinkedNotebookSyncChunk_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getLinkedNotebookSyncChunk_args args = new getLinkedNotebookSyncChunk_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getLinkedNotebookSyncChunk_result result = new getLinkedNotebookSyncChunk_result();
        try
        {
          try
          {
            result.Success = iface_.getLinkedNotebookSyncChunk(args.AuthenticationToken, args.LinkedNotebook, args.AfterUSN, args.MaxEntries, args.FullSyncOnly);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getLinkedNotebookSyncChunk", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getLinkedNotebookSyncChunk", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listNotebooks_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listNotebooks_args args = new listNotebooks_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listNotebooks_result result = new listNotebooks_result();
        try
        {
          try
          {
            result.Success = iface_.listNotebooks(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listNotebooks", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listNotebooks", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listAccessibleBusinessNotebooks_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listAccessibleBusinessNotebooks_args args = new listAccessibleBusinessNotebooks_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listAccessibleBusinessNotebooks_result result = new listAccessibleBusinessNotebooks_result();
        try
        {
          try
          {
            result.Success = iface_.listAccessibleBusinessNotebooks(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listAccessibleBusinessNotebooks", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listAccessibleBusinessNotebooks", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNotebook_args args = new getNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNotebook_result result = new getNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.getNotebook(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getDefaultNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getDefaultNotebook_args args = new getDefaultNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getDefaultNotebook_result result = new getDefaultNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.getDefaultNotebook(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getDefaultNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getDefaultNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createNotebook_args args = new createNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createNotebook_result result = new createNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.createNotebook(args.AuthenticationToken, args.Notebook);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("createNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateNotebook_args args = new updateNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateNotebook_result result = new updateNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.updateNotebook(args.AuthenticationToken, args.Notebook);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("updateNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void expungeNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        expungeNotebook_args args = new expungeNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        expungeNotebook_result result = new expungeNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.expungeNotebook(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("expungeNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("expungeNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listTags_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listTags_args args = new listTags_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listTags_result result = new listTags_result();
        try
        {
          try
          {
            result.Success = iface_.listTags(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listTags", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listTags", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listTagsByNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listTagsByNotebook_args args = new listTagsByNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listTagsByNotebook_result result = new listTagsByNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.listTagsByNotebook(args.AuthenticationToken, args.NotebookGuid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("listTagsByNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listTagsByNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getTag_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getTag_args args = new getTag_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getTag_result result = new getTag_result();
        try
        {
          try
          {
            result.Success = iface_.getTag(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getTag", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getTag", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createTag_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createTag_args args = new createTag_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createTag_result result = new createTag_result();
        try
        {
          try
          {
            result.Success = iface_.createTag(args.AuthenticationToken, args.Tag);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("createTag", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createTag", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateTag_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateTag_args args = new updateTag_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateTag_result result = new updateTag_result();
        try
        {
          try
          {
            result.Success = iface_.updateTag(args.AuthenticationToken, args.Tag);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("updateTag", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateTag", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void untagAll_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        untagAll_args args = new untagAll_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        untagAll_result result = new untagAll_result();
        try
        {
          try
          {
            iface_.untagAll(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("untagAll", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("untagAll", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void expungeTag_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        expungeTag_args args = new expungeTag_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        expungeTag_result result = new expungeTag_result();
        try
        {
          try
          {
            result.Success = iface_.expungeTag(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("expungeTag", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("expungeTag", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listSearches_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listSearches_args args = new listSearches_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listSearches_result result = new listSearches_result();
        try
        {
          try
          {
            result.Success = iface_.listSearches(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listSearches", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listSearches", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getSearch_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getSearch_args args = new getSearch_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getSearch_result result = new getSearch_result();
        try
        {
          try
          {
            result.Success = iface_.getSearch(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getSearch", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getSearch", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createSearch_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createSearch_args args = new createSearch_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createSearch_result result = new createSearch_result();
        try
        {
          try
          {
            result.Success = iface_.createSearch(args.AuthenticationToken, args.Search);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("createSearch", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createSearch", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateSearch_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateSearch_args args = new updateSearch_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateSearch_result result = new updateSearch_result();
        try
        {
          try
          {
            result.Success = iface_.updateSearch(args.AuthenticationToken, args.Search);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("updateSearch", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateSearch", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void expungeSearch_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        expungeSearch_args args = new expungeSearch_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        expungeSearch_result result = new expungeSearch_result();
        try
        {
          try
          {
            result.Success = iface_.expungeSearch(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("expungeSearch", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("expungeSearch", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void findNoteOffset_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        findNoteOffset_args args = new findNoteOffset_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        findNoteOffset_result result = new findNoteOffset_result();
        try
        {
          try
          {
            result.Success = iface_.findNoteOffset(args.AuthenticationToken, args.Filter, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("findNoteOffset", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("findNoteOffset", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void findNotesMetadata_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        findNotesMetadata_args args = new findNotesMetadata_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        findNotesMetadata_result result = new findNotesMetadata_result();
        try
        {
          try
          {
            result.Success = iface_.findNotesMetadata(args.AuthenticationToken, args.Filter, args.Offset, args.MaxNotes, args.ResultSpec);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("findNotesMetadata", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("findNotesMetadata", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void findNoteCounts_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        findNoteCounts_args args = new findNoteCounts_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        findNoteCounts_result result = new findNoteCounts_result();
        try
        {
          try
          {
            result.Success = iface_.findNoteCounts(args.AuthenticationToken, args.Filter, args.WithTrash);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("findNoteCounts", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("findNoteCounts", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteWithResultSpec_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteWithResultSpec_args args = new getNoteWithResultSpec_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteWithResultSpec_result result = new getNoteWithResultSpec_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteWithResultSpec(args.AuthenticationToken, args.Guid, args.ResultSpec);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteWithResultSpec", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteWithResultSpec", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNote_args args = new getNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNote_result result = new getNote_result();
        try
        {
          try
          {
            result.Success = iface_.getNote(args.AuthenticationToken, args.Guid, args.WithContent, args.WithResourcesData, args.WithResourcesRecognition, args.WithResourcesAlternateData);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteApplicationData_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteApplicationData_args args = new getNoteApplicationData_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteApplicationData_result result = new getNoteApplicationData_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteApplicationData(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteApplicationData", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteApplicationData", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteApplicationDataEntry_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteApplicationDataEntry_args args = new getNoteApplicationDataEntry_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteApplicationDataEntry_result result = new getNoteApplicationDataEntry_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteApplicationDataEntry(args.AuthenticationToken, args.Guid, args.Key);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteApplicationDataEntry", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteApplicationDataEntry", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void setNoteApplicationDataEntry_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        setNoteApplicationDataEntry_args args = new setNoteApplicationDataEntry_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        setNoteApplicationDataEntry_result result = new setNoteApplicationDataEntry_result();
        try
        {
          try
          {
            result.Success = iface_.setNoteApplicationDataEntry(args.AuthenticationToken, args.Guid, args.Key, args.Value);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("setNoteApplicationDataEntry", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("setNoteApplicationDataEntry", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void unsetNoteApplicationDataEntry_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        unsetNoteApplicationDataEntry_args args = new unsetNoteApplicationDataEntry_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        unsetNoteApplicationDataEntry_result result = new unsetNoteApplicationDataEntry_result();
        try
        {
          try
          {
            result.Success = iface_.unsetNoteApplicationDataEntry(args.AuthenticationToken, args.Guid, args.Key);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("unsetNoteApplicationDataEntry", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("unsetNoteApplicationDataEntry", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteContent_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteContent_args args = new getNoteContent_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteContent_result result = new getNoteContent_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteContent(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteContent", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteContent", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteSearchText_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteSearchText_args args = new getNoteSearchText_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteSearchText_result result = new getNoteSearchText_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteSearchText(args.AuthenticationToken, args.Guid, args.NoteOnly, args.TokenizeForIndexing);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteSearchText", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteSearchText", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceSearchText_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceSearchText_args args = new getResourceSearchText_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceSearchText_result result = new getResourceSearchText_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceSearchText(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceSearchText", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceSearchText", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteTagNames_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteTagNames_args args = new getNoteTagNames_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteTagNames_result result = new getNoteTagNames_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteTagNames(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteTagNames", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteTagNames", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createNote_args args = new createNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createNote_result result = new createNote_result();
        try
        {
          try
          {
            result.Success = iface_.createNote(args.AuthenticationToken, args.Note);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("createNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateNote_args args = new updateNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateNote_result result = new updateNote_result();
        try
        {
          try
          {
            result.Success = iface_.updateNote(args.AuthenticationToken, args.Note);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("updateNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void deleteNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        deleteNote_args args = new deleteNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        deleteNote_result result = new deleteNote_result();
        try
        {
          try
          {
            result.Success = iface_.deleteNote(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("deleteNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("deleteNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void expungeNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        expungeNote_args args = new expungeNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        expungeNote_result result = new expungeNote_result();
        try
        {
          try
          {
            result.Success = iface_.expungeNote(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("expungeNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("expungeNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void copyNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        copyNote_args args = new copyNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        copyNote_result result = new copyNote_result();
        try
        {
          try
          {
            result.Success = iface_.copyNote(args.AuthenticationToken, args.NoteGuid, args.ToNotebookGuid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("copyNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("copyNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listNoteVersions_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listNoteVersions_args args = new listNoteVersions_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listNoteVersions_result result = new listNoteVersions_result();
        try
        {
          try
          {
            result.Success = iface_.listNoteVersions(args.AuthenticationToken, args.NoteGuid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("listNoteVersions", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listNoteVersions", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNoteVersion_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNoteVersion_args args = new getNoteVersion_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNoteVersion_result result = new getNoteVersion_result();
        try
        {
          try
          {
            result.Success = iface_.getNoteVersion(args.AuthenticationToken, args.NoteGuid, args.UpdateSequenceNum, args.WithResourcesData, args.WithResourcesRecognition, args.WithResourcesAlternateData);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getNoteVersion", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNoteVersion", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResource_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResource_args args = new getResource_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResource_result result = new getResource_result();
        try
        {
          try
          {
            result.Success = iface_.getResource(args.AuthenticationToken, args.Guid, args.WithData, args.WithRecognition, args.WithAttributes, args.WithAlternateData);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResource", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResource", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceApplicationData_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceApplicationData_args args = new getResourceApplicationData_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceApplicationData_result result = new getResourceApplicationData_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceApplicationData(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceApplicationData", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceApplicationData", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceApplicationDataEntry_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceApplicationDataEntry_args args = new getResourceApplicationDataEntry_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceApplicationDataEntry_result result = new getResourceApplicationDataEntry_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceApplicationDataEntry(args.AuthenticationToken, args.Guid, args.Key);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceApplicationDataEntry", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceApplicationDataEntry", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void setResourceApplicationDataEntry_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        setResourceApplicationDataEntry_args args = new setResourceApplicationDataEntry_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        setResourceApplicationDataEntry_result result = new setResourceApplicationDataEntry_result();
        try
        {
          try
          {
            result.Success = iface_.setResourceApplicationDataEntry(args.AuthenticationToken, args.Guid, args.Key, args.Value);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("setResourceApplicationDataEntry", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("setResourceApplicationDataEntry", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void unsetResourceApplicationDataEntry_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        unsetResourceApplicationDataEntry_args args = new unsetResourceApplicationDataEntry_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        unsetResourceApplicationDataEntry_result result = new unsetResourceApplicationDataEntry_result();
        try
        {
          try
          {
            result.Success = iface_.unsetResourceApplicationDataEntry(args.AuthenticationToken, args.Guid, args.Key);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("unsetResourceApplicationDataEntry", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("unsetResourceApplicationDataEntry", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateResource_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateResource_args args = new updateResource_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateResource_result result = new updateResource_result();
        try
        {
          try
          {
            result.Success = iface_.updateResource(args.AuthenticationToken, args.Resource);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("updateResource", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateResource", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceData_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceData_args args = new getResourceData_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceData_result result = new getResourceData_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceData(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceData", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceData", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceByHash_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceByHash_args args = new getResourceByHash_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceByHash_result result = new getResourceByHash_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceByHash(args.AuthenticationToken, args.NoteGuid, args.ContentHash, args.WithData, args.WithRecognition, args.WithAlternateData);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceByHash", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceByHash", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceRecognition_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceRecognition_args args = new getResourceRecognition_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceRecognition_result result = new getResourceRecognition_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceRecognition(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceRecognition", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceRecognition", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceAlternateData_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceAlternateData_args args = new getResourceAlternateData_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceAlternateData_result result = new getResourceAlternateData_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceAlternateData(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceAlternateData", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceAlternateData", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getResourceAttributes_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getResourceAttributes_args args = new getResourceAttributes_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getResourceAttributes_result result = new getResourceAttributes_result();
        try
        {
          try
          {
            result.Success = iface_.getResourceAttributes(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getResourceAttributes", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getResourceAttributes", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getPublicNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getPublicNotebook_args args = new getPublicNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getPublicNotebook_result result = new getPublicNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.getPublicNotebook(args.UserId, args.PublicUri);
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("getPublicNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getPublicNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void shareNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        shareNotebook_args args = new shareNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        shareNotebook_result result = new shareNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.shareNotebook(args.AuthenticationToken, args.SharedNotebook, args.Message);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("shareNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("shareNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createOrUpdateNotebookShares_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createOrUpdateNotebookShares_args args = new createOrUpdateNotebookShares_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createOrUpdateNotebookShares_result result = new createOrUpdateNotebookShares_result();
        try
        {
          try
          {
            result.Success = iface_.createOrUpdateNotebookShares(args.AuthenticationToken, args.ShareTemplate);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMInvalidContactsException invalidContactsException)
          {
            result.InvalidContactsException = invalidContactsException;
          }
          oprot.WriteMessageBegin(new TMessage("createOrUpdateNotebookShares", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createOrUpdateNotebookShares", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateSharedNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateSharedNotebook_args args = new updateSharedNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateSharedNotebook_result result = new updateSharedNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.updateSharedNotebook(args.AuthenticationToken, args.SharedNotebook);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("updateSharedNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateSharedNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void setNotebookRecipientSettings_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        setNotebookRecipientSettings_args args = new setNotebookRecipientSettings_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        setNotebookRecipientSettings_result result = new setNotebookRecipientSettings_result();
        try
        {
          try
          {
            result.Success = iface_.setNotebookRecipientSettings(args.AuthenticationToken, args.NotebookGuid, args.RecipientSettings);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("setNotebookRecipientSettings", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("setNotebookRecipientSettings", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listSharedNotebooks_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listSharedNotebooks_args args = new listSharedNotebooks_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listSharedNotebooks_result result = new listSharedNotebooks_result();
        try
        {
          try
          {
            result.Success = iface_.listSharedNotebooks(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listSharedNotebooks", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listSharedNotebooks", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void createLinkedNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        createLinkedNotebook_args args = new createLinkedNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        createLinkedNotebook_result result = new createLinkedNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.createLinkedNotebook(args.AuthenticationToken, args.LinkedNotebook);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("createLinkedNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("createLinkedNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateLinkedNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateLinkedNotebook_args args = new updateLinkedNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateLinkedNotebook_result result = new updateLinkedNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.updateLinkedNotebook(args.AuthenticationToken, args.LinkedNotebook);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("updateLinkedNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateLinkedNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void listLinkedNotebooks_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        listLinkedNotebooks_args args = new listLinkedNotebooks_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        listLinkedNotebooks_result result = new listLinkedNotebooks_result();
        try
        {
          try
          {
            result.Success = iface_.listLinkedNotebooks(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("listLinkedNotebooks", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("listLinkedNotebooks", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void expungeLinkedNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        expungeLinkedNotebook_args args = new expungeLinkedNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        expungeLinkedNotebook_result result = new expungeLinkedNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.expungeLinkedNotebook(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("expungeLinkedNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("expungeLinkedNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void authenticateToSharedNotebook_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        authenticateToSharedNotebook_args args = new authenticateToSharedNotebook_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        authenticateToSharedNotebook_result result = new authenticateToSharedNotebook_result();
        try
        {
          try
          {
            result.Success = iface_.authenticateToSharedNotebook(args.ShareKeyOrGlobalId, args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("authenticateToSharedNotebook", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("authenticateToSharedNotebook", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getSharedNotebookByAuth_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getSharedNotebookByAuth_args args = new getSharedNotebookByAuth_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getSharedNotebookByAuth_result result = new getSharedNotebookByAuth_result();
        try
        {
          try
          {
            result.Success = iface_.getSharedNotebookByAuth(args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getSharedNotebookByAuth", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getSharedNotebookByAuth", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void emailNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        emailNote_args args = new emailNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        emailNote_result result = new emailNote_result();
        try
        {
          try
          {
            iface_.emailNote(args.AuthenticationToken, args.Parameters);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("emailNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("emailNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void shareNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        shareNote_args args = new shareNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        shareNote_result result = new shareNote_result();
        try
        {
          try
          {
            result.Success = iface_.shareNote(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("shareNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("shareNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void stopSharingNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        stopSharingNote_args args = new stopSharingNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        stopSharingNote_result result = new stopSharingNote_result();
        try
        {
          try
          {
            iface_.stopSharingNote(args.AuthenticationToken, args.Guid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("stopSharingNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("stopSharingNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void authenticateToSharedNote_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        authenticateToSharedNote_args args = new authenticateToSharedNote_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        authenticateToSharedNote_result result = new authenticateToSharedNote_result();
        try
        {
          try
          {
            result.Success = iface_.authenticateToSharedNote(args.Guid, args.NoteKey, args.AuthenticationToken);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("authenticateToSharedNote", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("authenticateToSharedNote", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void findRelated_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        findRelated_args args = new findRelated_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        findRelated_result result = new findRelated_result();
        try
        {
          try
          {
            result.Success = iface_.findRelated(args.AuthenticationToken, args.Query, args.ResultSpec);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          oprot.WriteMessageBegin(new TMessage("findRelated", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("findRelated", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void updateNoteIfUsnMatches_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        updateNoteIfUsnMatches_args args = new updateNoteIfUsnMatches_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        updateNoteIfUsnMatches_result result = new updateNoteIfUsnMatches_result();
        try
        {
          try
          {
            result.Success = iface_.updateNoteIfUsnMatches(args.AuthenticationToken, args.Note);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("updateNoteIfUsnMatches", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("updateNoteIfUsnMatches", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void manageNotebookShares_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        manageNotebookShares_args args = new manageNotebookShares_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        manageNotebookShares_result result = new manageNotebookShares_result();
        try
        {
          try
          {
            result.Success = iface_.manageNotebookShares(args.AuthenticationToken, args.Parameters);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("manageNotebookShares", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("manageNotebookShares", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void getNotebookShares_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        getNotebookShares_args args = new getNotebookShares_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        getNotebookShares_result result = new getNotebookShares_result();
        try
        {
          try
          {
            result.Success = iface_.getNotebookShares(args.AuthenticationToken, args.NotebookGuid);
          }
          catch (Evernote.EDAM.Error.EDAMUserException userException)
          {
            result.UserException = userException;
          }
          catch (Evernote.EDAM.Error.EDAMNotFoundException notFoundException)
          {
            result.NotFoundException = notFoundException;
          }
          catch (Evernote.EDAM.Error.EDAMSystemException systemException)
          {
            result.SystemException = systemException;
          }
          oprot.WriteMessageBegin(new TMessage("getNotebookShares", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("getNotebookShares", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getSyncState_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public getSyncState_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getSyncState_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getSyncState_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getSyncState_result : TBase
    {
      private SyncState _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public SyncState Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public getSyncState_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new SyncState();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getSyncState_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getSyncState_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getFilteredSyncChunk_args : TBase
    {
      private string _authenticationToken;
      private int _afterUSN;
      private int _maxEntries;
      private SyncChunkFilter _filter;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public int AfterUSN
      {
        get
        {
          return _afterUSN;
        }
        set
        {
          __isset.afterUSN = true;
          this._afterUSN = value;
        }
      }

      public int MaxEntries
      {
        get
        {
          return _maxEntries;
        }
        set
        {
          __isset.maxEntries = true;
          this._maxEntries = value;
        }
      }

      public SyncChunkFilter Filter
      {
        get
        {
          return _filter;
        }
        set
        {
          __isset.filter = true;
          this._filter = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool afterUSN;
        public bool maxEntries;
        public bool filter;
      }

      public getFilteredSyncChunk_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.I32) {
                  AfterUSN = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  MaxEntries = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Struct) {
                  Filter = new SyncChunkFilter();
                  Filter.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getFilteredSyncChunk_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (__isset.afterUSN) {
            field.Name = "afterUSN";
            field.Type = TType.I32;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(AfterUSN);
            oprot.WriteFieldEnd();
          }
          if (__isset.maxEntries) {
            field.Name = "maxEntries";
            field.Type = TType.I32;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(MaxEntries);
            oprot.WriteFieldEnd();
          }
          if (Filter != null && __isset.filter) {
            field.Name = "filter";
            field.Type = TType.Struct;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            Filter.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getFilteredSyncChunk_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (__isset.afterUSN) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AfterUSN: ");
          __sb.Append(AfterUSN);
        }
        if (__isset.maxEntries) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("MaxEntries: ");
          __sb.Append(MaxEntries);
        }
        if (Filter != null && __isset.filter) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Filter: ");
          __sb.Append(Filter== null ? "<null>" : Filter.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getFilteredSyncChunk_result : TBase
    {
      private SyncChunk _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public SyncChunk Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public getFilteredSyncChunk_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new SyncChunk();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getFilteredSyncChunk_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getFilteredSyncChunk_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getLinkedNotebookSyncState_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.LinkedNotebook _linkedNotebook;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.LinkedNotebook LinkedNotebook
      {
        get
        {
          return _linkedNotebook;
        }
        set
        {
          __isset.linkedNotebook = true;
          this._linkedNotebook = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool linkedNotebook;
      }

      public getLinkedNotebookSyncState_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  LinkedNotebook = new Evernote.EDAM.Type.LinkedNotebook();
                  LinkedNotebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getLinkedNotebookSyncState_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (LinkedNotebook != null && __isset.linkedNotebook) {
            field.Name = "linkedNotebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            LinkedNotebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getLinkedNotebookSyncState_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (LinkedNotebook != null && __isset.linkedNotebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("LinkedNotebook: ");
          __sb.Append(LinkedNotebook== null ? "<null>" : LinkedNotebook.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getLinkedNotebookSyncState_result : TBase
    {
      private SyncState _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public SyncState Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getLinkedNotebookSyncState_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new SyncState();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getLinkedNotebookSyncState_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getLinkedNotebookSyncState_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getLinkedNotebookSyncChunk_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.LinkedNotebook _linkedNotebook;
      private int _afterUSN;
      private int _maxEntries;
      private bool _fullSyncOnly;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.LinkedNotebook LinkedNotebook
      {
        get
        {
          return _linkedNotebook;
        }
        set
        {
          __isset.linkedNotebook = true;
          this._linkedNotebook = value;
        }
      }

      public int AfterUSN
      {
        get
        {
          return _afterUSN;
        }
        set
        {
          __isset.afterUSN = true;
          this._afterUSN = value;
        }
      }

      public int MaxEntries
      {
        get
        {
          return _maxEntries;
        }
        set
        {
          __isset.maxEntries = true;
          this._maxEntries = value;
        }
      }

      public bool FullSyncOnly
      {
        get
        {
          return _fullSyncOnly;
        }
        set
        {
          __isset.fullSyncOnly = true;
          this._fullSyncOnly = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool linkedNotebook;
        public bool afterUSN;
        public bool maxEntries;
        public bool fullSyncOnly;
      }

      public getLinkedNotebookSyncChunk_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  LinkedNotebook = new Evernote.EDAM.Type.LinkedNotebook();
                  LinkedNotebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  AfterUSN = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  MaxEntries = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Bool) {
                  FullSyncOnly = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getLinkedNotebookSyncChunk_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (LinkedNotebook != null && __isset.linkedNotebook) {
            field.Name = "linkedNotebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            LinkedNotebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (__isset.afterUSN) {
            field.Name = "afterUSN";
            field.Type = TType.I32;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(AfterUSN);
            oprot.WriteFieldEnd();
          }
          if (__isset.maxEntries) {
            field.Name = "maxEntries";
            field.Type = TType.I32;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(MaxEntries);
            oprot.WriteFieldEnd();
          }
          if (__isset.fullSyncOnly) {
            field.Name = "fullSyncOnly";
            field.Type = TType.Bool;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(FullSyncOnly);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getLinkedNotebookSyncChunk_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (LinkedNotebook != null && __isset.linkedNotebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("LinkedNotebook: ");
          __sb.Append(LinkedNotebook== null ? "<null>" : LinkedNotebook.ToString());
        }
        if (__isset.afterUSN) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AfterUSN: ");
          __sb.Append(AfterUSN);
        }
        if (__isset.maxEntries) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("MaxEntries: ");
          __sb.Append(MaxEntries);
        }
        if (__isset.fullSyncOnly) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("FullSyncOnly: ");
          __sb.Append(FullSyncOnly);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getLinkedNotebookSyncChunk_result : TBase
    {
      private SyncChunk _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public SyncChunk Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getLinkedNotebookSyncChunk_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new SyncChunk();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getLinkedNotebookSyncChunk_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getLinkedNotebookSyncChunk_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listNotebooks_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listNotebooks_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listNotebooks_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listNotebooks_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listNotebooks_result : TBase
    {
      private List<Evernote.EDAM.Type.Notebook> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.Notebook> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public listNotebooks_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.Notebook>();
                    TList _list190 = iprot.ReadListBegin();
                    for( int _i191 = 0; _i191 < _list190.Count; ++_i191)
                    {
                      Evernote.EDAM.Type.Notebook _elem192;
                      _elem192 = new Evernote.EDAM.Type.Notebook();
                      _elem192.Read(iprot);
                      Success.Add(_elem192);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listNotebooks_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.Notebook _iter193 in Success)
                {
                  _iter193.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listNotebooks_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listAccessibleBusinessNotebooks_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listAccessibleBusinessNotebooks_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listAccessibleBusinessNotebooks_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listAccessibleBusinessNotebooks_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listAccessibleBusinessNotebooks_result : TBase
    {
      private List<Evernote.EDAM.Type.Notebook> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.Notebook> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public listAccessibleBusinessNotebooks_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.Notebook>();
                    TList _list194 = iprot.ReadListBegin();
                    for( int _i195 = 0; _i195 < _list194.Count; ++_i195)
                    {
                      Evernote.EDAM.Type.Notebook _elem196;
                      _elem196 = new Evernote.EDAM.Type.Notebook();
                      _elem196.Read(iprot);
                      Success.Add(_elem196);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listAccessibleBusinessNotebooks_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.Notebook _iter197 in Success)
                {
                  _iter197.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listAccessibleBusinessNotebooks_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNotebook_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNotebook_result : TBase
    {
      private Evernote.EDAM.Type.Notebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Notebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Notebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getDefaultNotebook_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public getDefaultNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getDefaultNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getDefaultNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getDefaultNotebook_result : TBase
    {
      private Evernote.EDAM.Type.Notebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.Notebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public getDefaultNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Notebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getDefaultNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getDefaultNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createNotebook_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Notebook _notebook;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Notebook Notebook
      {
        get
        {
          return _notebook;
        }
        set
        {
          __isset.notebook = true;
          this._notebook = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool notebook;
      }

      public createNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Notebook = new Evernote.EDAM.Type.Notebook();
                  Notebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Notebook != null && __isset.notebook) {
            field.Name = "notebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Notebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Notebook != null && __isset.notebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Notebook: ");
          __sb.Append(Notebook== null ? "<null>" : Notebook.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createNotebook_result : TBase
    {
      private Evernote.EDAM.Type.Notebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Notebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public createNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Notebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateNotebook_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Notebook _notebook;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Notebook Notebook
      {
        get
        {
          return _notebook;
        }
        set
        {
          __isset.notebook = true;
          this._notebook = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool notebook;
      }

      public updateNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Notebook = new Evernote.EDAM.Type.Notebook();
                  Notebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Notebook != null && __isset.notebook) {
            field.Name = "notebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Notebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Notebook != null && __isset.notebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Notebook: ");
          __sb.Append(Notebook== null ? "<null>" : Notebook.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateNotebook_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public updateNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateNotebook_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeNotebook_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public expungeNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeNotebook_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public expungeNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeNotebook_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listTags_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listTags_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listTags_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listTags_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listTags_result : TBase
    {
      private List<Evernote.EDAM.Type.Tag> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.Tag> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public listTags_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.Tag>();
                    TList _list198 = iprot.ReadListBegin();
                    for( int _i199 = 0; _i199 < _list198.Count; ++_i199)
                    {
                      Evernote.EDAM.Type.Tag _elem200;
                      _elem200 = new Evernote.EDAM.Type.Tag();
                      _elem200.Read(iprot);
                      Success.Add(_elem200);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listTags_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.Tag _iter201 in Success)
                {
                  _iter201.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listTags_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listTagsByNotebook_args : TBase
    {
      private string _authenticationToken;
      private string _notebookGuid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NotebookGuid
      {
        get
        {
          return _notebookGuid;
        }
        set
        {
          __isset.notebookGuid = true;
          this._notebookGuid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool notebookGuid;
      }

      public listTagsByNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NotebookGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listTagsByNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NotebookGuid != null && __isset.notebookGuid) {
            field.Name = "notebookGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NotebookGuid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listTagsByNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NotebookGuid != null && __isset.notebookGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotebookGuid: ");
          __sb.Append(NotebookGuid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listTagsByNotebook_result : TBase
    {
      private List<Evernote.EDAM.Type.Tag> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public List<Evernote.EDAM.Type.Tag> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public listTagsByNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.Tag>();
                    TList _list202 = iprot.ReadListBegin();
                    for( int _i203 = 0; _i203 < _list202.Count; ++_i203)
                    {
                      Evernote.EDAM.Type.Tag _elem204;
                      _elem204 = new Evernote.EDAM.Type.Tag();
                      _elem204.Read(iprot);
                      Success.Add(_elem204);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listTagsByNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.Tag _iter205 in Success)
                {
                  _iter205.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listTagsByNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getTag_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getTag_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getTag_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getTag_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getTag_result : TBase
    {
      private Evernote.EDAM.Type.Tag _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Tag Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getTag_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Tag();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getTag_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getTag_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createTag_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Tag _tag;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Tag Tag
      {
        get
        {
          return _tag;
        }
        set
        {
          __isset.tag = true;
          this._tag = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool tag;
      }

      public createTag_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tag = new Evernote.EDAM.Type.Tag();
                  Tag.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createTag_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Tag != null && __isset.tag) {
            field.Name = "tag";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Tag.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createTag_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Tag != null && __isset.tag) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Tag: ");
          __sb.Append(Tag== null ? "<null>" : Tag.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createTag_result : TBase
    {
      private Evernote.EDAM.Type.Tag _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Tag Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public createTag_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Tag();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createTag_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createTag_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateTag_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Tag _tag;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Tag Tag
      {
        get
        {
          return _tag;
        }
        set
        {
          __isset.tag = true;
          this._tag = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool tag;
      }

      public updateTag_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Tag = new Evernote.EDAM.Type.Tag();
                  Tag.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateTag_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Tag != null && __isset.tag) {
            field.Name = "tag";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Tag.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateTag_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Tag != null && __isset.tag) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Tag: ");
          __sb.Append(Tag== null ? "<null>" : Tag.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateTag_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public updateTag_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateTag_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateTag_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class untagAll_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public untagAll_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("untagAll_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("untagAll_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class untagAll_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public untagAll_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("untagAll_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("untagAll_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeTag_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public expungeTag_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeTag_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeTag_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeTag_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public expungeTag_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeTag_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeTag_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listSearches_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listSearches_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listSearches_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listSearches_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listSearches_result : TBase
    {
      private List<Evernote.EDAM.Type.SavedSearch> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.SavedSearch> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public listSearches_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.SavedSearch>();
                    TList _list206 = iprot.ReadListBegin();
                    for( int _i207 = 0; _i207 < _list206.Count; ++_i207)
                    {
                      Evernote.EDAM.Type.SavedSearch _elem208;
                      _elem208 = new Evernote.EDAM.Type.SavedSearch();
                      _elem208.Read(iprot);
                      Success.Add(_elem208);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listSearches_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.SavedSearch _iter209 in Success)
                {
                  _iter209.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listSearches_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getSearch_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getSearch_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getSearch_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getSearch_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getSearch_result : TBase
    {
      private Evernote.EDAM.Type.SavedSearch _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.SavedSearch Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getSearch_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.SavedSearch();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getSearch_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getSearch_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createSearch_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.SavedSearch _search;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.SavedSearch Search
      {
        get
        {
          return _search;
        }
        set
        {
          __isset.search = true;
          this._search = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool search;
      }

      public createSearch_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Search = new Evernote.EDAM.Type.SavedSearch();
                  Search.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createSearch_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Search != null && __isset.search) {
            field.Name = "search";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Search.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createSearch_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Search != null && __isset.search) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Search: ");
          __sb.Append(Search== null ? "<null>" : Search.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createSearch_result : TBase
    {
      private Evernote.EDAM.Type.SavedSearch _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.SavedSearch Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
      }

      public createSearch_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.SavedSearch();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createSearch_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createSearch_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateSearch_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.SavedSearch _search;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.SavedSearch Search
      {
        get
        {
          return _search;
        }
        set
        {
          __isset.search = true;
          this._search = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool search;
      }

      public updateSearch_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Search = new Evernote.EDAM.Type.SavedSearch();
                  Search.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateSearch_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Search != null && __isset.search) {
            field.Name = "search";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Search.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateSearch_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Search != null && __isset.search) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Search: ");
          __sb.Append(Search== null ? "<null>" : Search.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateSearch_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public updateSearch_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateSearch_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateSearch_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeSearch_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public expungeSearch_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeSearch_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeSearch_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeSearch_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public expungeSearch_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeSearch_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeSearch_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findNoteOffset_args : TBase
    {
      private string _authenticationToken;
      private NoteFilter _filter;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public NoteFilter Filter
      {
        get
        {
          return _filter;
        }
        set
        {
          __isset.filter = true;
          this._filter = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool filter;
        public bool guid;
      }

      public findNoteOffset_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Filter = new NoteFilter();
                  Filter.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findNoteOffset_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Filter != null && __isset.filter) {
            field.Name = "filter";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Filter.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findNoteOffset_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Filter != null && __isset.filter) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Filter: ");
          __sb.Append(Filter== null ? "<null>" : Filter.ToString());
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findNoteOffset_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public findNoteOffset_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findNoteOffset_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findNoteOffset_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findNotesMetadata_args : TBase
    {
      private string _authenticationToken;
      private NoteFilter _filter;
      private int _offset;
      private int _maxNotes;
      private NotesMetadataResultSpec _resultSpec;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public NoteFilter Filter
      {
        get
        {
          return _filter;
        }
        set
        {
          __isset.filter = true;
          this._filter = value;
        }
      }

      public int Offset
      {
        get
        {
          return _offset;
        }
        set
        {
          __isset.offset = true;
          this._offset = value;
        }
      }

      public int MaxNotes
      {
        get
        {
          return _maxNotes;
        }
        set
        {
          __isset.maxNotes = true;
          this._maxNotes = value;
        }
      }

      public NotesMetadataResultSpec ResultSpec
      {
        get
        {
          return _resultSpec;
        }
        set
        {
          __isset.resultSpec = true;
          this._resultSpec = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool filter;
        public bool offset;
        public bool maxNotes;
        public bool resultSpec;
      }

      public findNotesMetadata_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Filter = new NoteFilter();
                  Filter.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  Offset = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.I32) {
                  MaxNotes = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Struct) {
                  ResultSpec = new NotesMetadataResultSpec();
                  ResultSpec.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findNotesMetadata_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Filter != null && __isset.filter) {
            field.Name = "filter";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Filter.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (__isset.offset) {
            field.Name = "offset";
            field.Type = TType.I32;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Offset);
            oprot.WriteFieldEnd();
          }
          if (__isset.maxNotes) {
            field.Name = "maxNotes";
            field.Type = TType.I32;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(MaxNotes);
            oprot.WriteFieldEnd();
          }
          if (ResultSpec != null && __isset.resultSpec) {
            field.Name = "resultSpec";
            field.Type = TType.Struct;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            ResultSpec.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findNotesMetadata_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Filter != null && __isset.filter) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Filter: ");
          __sb.Append(Filter== null ? "<null>" : Filter.ToString());
        }
        if (__isset.offset) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Offset: ");
          __sb.Append(Offset);
        }
        if (__isset.maxNotes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("MaxNotes: ");
          __sb.Append(MaxNotes);
        }
        if (ResultSpec != null && __isset.resultSpec) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ResultSpec: ");
          __sb.Append(ResultSpec== null ? "<null>" : ResultSpec.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findNotesMetadata_result : TBase
    {
      private NotesMetadataList _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public NotesMetadataList Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public findNotesMetadata_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new NotesMetadataList();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findNotesMetadata_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findNotesMetadata_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findNoteCounts_args : TBase
    {
      private string _authenticationToken;
      private NoteFilter _filter;
      private bool _withTrash;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public NoteFilter Filter
      {
        get
        {
          return _filter;
        }
        set
        {
          __isset.filter = true;
          this._filter = value;
        }
      }

      public bool WithTrash
      {
        get
        {
          return _withTrash;
        }
        set
        {
          __isset.withTrash = true;
          this._withTrash = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool filter;
        public bool withTrash;
      }

      public findNoteCounts_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Filter = new NoteFilter();
                  Filter.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Bool) {
                  WithTrash = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findNoteCounts_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Filter != null && __isset.filter) {
            field.Name = "filter";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Filter.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (__isset.withTrash) {
            field.Name = "withTrash";
            field.Type = TType.Bool;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithTrash);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findNoteCounts_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Filter != null && __isset.filter) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Filter: ");
          __sb.Append(Filter== null ? "<null>" : Filter.ToString());
        }
        if (__isset.withTrash) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithTrash: ");
          __sb.Append(WithTrash);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findNoteCounts_result : TBase
    {
      private NoteCollectionCounts _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public NoteCollectionCounts Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public findNoteCounts_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new NoteCollectionCounts();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findNoteCounts_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findNoteCounts_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteWithResultSpec_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private NoteResultSpec _resultSpec;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public NoteResultSpec ResultSpec
      {
        get
        {
          return _resultSpec;
        }
        set
        {
          __isset.resultSpec = true;
          this._resultSpec = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool resultSpec;
      }

      public getNoteWithResultSpec_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  ResultSpec = new NoteResultSpec();
                  ResultSpec.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteWithResultSpec_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (ResultSpec != null && __isset.resultSpec) {
            field.Name = "resultSpec";
            field.Type = TType.Struct;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            ResultSpec.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteWithResultSpec_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (ResultSpec != null && __isset.resultSpec) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ResultSpec: ");
          __sb.Append(ResultSpec== null ? "<null>" : ResultSpec.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteWithResultSpec_result : TBase
    {
      private Evernote.EDAM.Type.Note _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Note Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteWithResultSpec_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Note();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteWithResultSpec_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteWithResultSpec_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNote_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private bool _withContent;
      private bool _withResourcesData;
      private bool _withResourcesRecognition;
      private bool _withResourcesAlternateData;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public bool WithContent
      {
        get
        {
          return _withContent;
        }
        set
        {
          __isset.withContent = true;
          this._withContent = value;
        }
      }

      public bool WithResourcesData
      {
        get
        {
          return _withResourcesData;
        }
        set
        {
          __isset.withResourcesData = true;
          this._withResourcesData = value;
        }
      }

      public bool WithResourcesRecognition
      {
        get
        {
          return _withResourcesRecognition;
        }
        set
        {
          __isset.withResourcesRecognition = true;
          this._withResourcesRecognition = value;
        }
      }

      public bool WithResourcesAlternateData
      {
        get
        {
          return _withResourcesAlternateData;
        }
        set
        {
          __isset.withResourcesAlternateData = true;
          this._withResourcesAlternateData = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool withContent;
        public bool withResourcesData;
        public bool withResourcesRecognition;
        public bool withResourcesAlternateData;
      }

      public getNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Bool) {
                  WithContent = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Bool) {
                  WithResourcesData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Bool) {
                  WithResourcesRecognition = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Bool) {
                  WithResourcesAlternateData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (__isset.withContent) {
            field.Name = "withContent";
            field.Type = TType.Bool;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithContent);
            oprot.WriteFieldEnd();
          }
          if (__isset.withResourcesData) {
            field.Name = "withResourcesData";
            field.Type = TType.Bool;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithResourcesData);
            oprot.WriteFieldEnd();
          }
          if (__isset.withResourcesRecognition) {
            field.Name = "withResourcesRecognition";
            field.Type = TType.Bool;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithResourcesRecognition);
            oprot.WriteFieldEnd();
          }
          if (__isset.withResourcesAlternateData) {
            field.Name = "withResourcesAlternateData";
            field.Type = TType.Bool;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithResourcesAlternateData);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (__isset.withContent) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithContent: ");
          __sb.Append(WithContent);
        }
        if (__isset.withResourcesData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithResourcesData: ");
          __sb.Append(WithResourcesData);
        }
        if (__isset.withResourcesRecognition) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithResourcesRecognition: ");
          __sb.Append(WithResourcesRecognition);
        }
        if (__isset.withResourcesAlternateData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithResourcesAlternateData: ");
          __sb.Append(WithResourcesAlternateData);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNote_result : TBase
    {
      private Evernote.EDAM.Type.Note _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Note Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Note();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNote_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteApplicationData_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getNoteApplicationData_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteApplicationData_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteApplicationData_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteApplicationData_result : TBase
    {
      private Evernote.EDAM.Type.LazyMap _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.LazyMap Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteApplicationData_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.LazyMap();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteApplicationData_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteApplicationData_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteApplicationDataEntry_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private string _key;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool key;
      }

      public getNoteApplicationDataEntry_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteApplicationDataEntry_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteApplicationDataEntry_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteApplicationDataEntry_result : TBase
    {
      private string _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteApplicationDataEntry_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteApplicationDataEntry_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteApplicationDataEntry_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class setNoteApplicationDataEntry_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private string _key;
      private string _value;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }

      public string Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool key;
        public bool @value;
      }

      public setNoteApplicationDataEntry_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  Value = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("setNoteApplicationDataEntry_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          if (Value != null && __isset.@value) {
            field.Name = "value";
            field.Type = TType.String;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Value);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("setNoteApplicationDataEntry_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        if (Value != null && __isset.@value) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Value: ");
          __sb.Append(Value);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class setNoteApplicationDataEntry_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public setNoteApplicationDataEntry_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("setNoteApplicationDataEntry_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("setNoteApplicationDataEntry_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class unsetNoteApplicationDataEntry_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private string _key;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool key;
      }

      public unsetNoteApplicationDataEntry_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("unsetNoteApplicationDataEntry_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("unsetNoteApplicationDataEntry_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class unsetNoteApplicationDataEntry_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public unsetNoteApplicationDataEntry_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("unsetNoteApplicationDataEntry_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("unsetNoteApplicationDataEntry_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteContent_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getNoteContent_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteContent_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteContent_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteContent_result : TBase
    {
      private string _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteContent_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteContent_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteContent_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteSearchText_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private bool _noteOnly;
      private bool _tokenizeForIndexing;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public bool NoteOnly
      {
        get
        {
          return _noteOnly;
        }
        set
        {
          __isset.noteOnly = true;
          this._noteOnly = value;
        }
      }

      public bool TokenizeForIndexing
      {
        get
        {
          return _tokenizeForIndexing;
        }
        set
        {
          __isset.tokenizeForIndexing = true;
          this._tokenizeForIndexing = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool noteOnly;
        public bool tokenizeForIndexing;
      }

      public getNoteSearchText_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Bool) {
                  NoteOnly = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Bool) {
                  TokenizeForIndexing = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteSearchText_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (__isset.noteOnly) {
            field.Name = "noteOnly";
            field.Type = TType.Bool;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(NoteOnly);
            oprot.WriteFieldEnd();
          }
          if (__isset.tokenizeForIndexing) {
            field.Name = "tokenizeForIndexing";
            field.Type = TType.Bool;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(TokenizeForIndexing);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteSearchText_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (__isset.noteOnly) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NoteOnly: ");
          __sb.Append(NoteOnly);
        }
        if (__isset.tokenizeForIndexing) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("TokenizeForIndexing: ");
          __sb.Append(TokenizeForIndexing);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteSearchText_result : TBase
    {
      private string _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteSearchText_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteSearchText_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteSearchText_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceSearchText_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getResourceSearchText_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceSearchText_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceSearchText_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceSearchText_result : TBase
    {
      private string _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceSearchText_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceSearchText_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceSearchText_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteTagNames_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getNoteTagNames_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteTagNames_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteTagNames_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteTagNames_result : TBase
    {
      private List<string> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public List<string> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteTagNames_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<string>();
                    TList _list210 = iprot.ReadListBegin();
                    for( int _i211 = 0; _i211 < _list210.Count; ++_i211)
                    {
                      string _elem212;
                      _elem212 = iprot.ReadString();
                      Success.Add(_elem212);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteTagNames_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.String, Success.Count));
                foreach (string _iter213 in Success)
                {
                  oprot.WriteString(_iter213);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteTagNames_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createNote_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Note _note;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Note Note
      {
        get
        {
          return _note;
        }
        set
        {
          __isset.note = true;
          this._note = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool note;
      }

      public createNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Note = new Evernote.EDAM.Type.Note();
                  Note.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Note != null && __isset.note) {
            field.Name = "note";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Note.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Note != null && __isset.note) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Note: ");
          __sb.Append(Note== null ? "<null>" : Note.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createNote_result : TBase
    {
      private Evernote.EDAM.Type.Note _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Note Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public createNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Note();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createNote_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateNote_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Note _note;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Note Note
      {
        get
        {
          return _note;
        }
        set
        {
          __isset.note = true;
          this._note = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool note;
      }

      public updateNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Note = new Evernote.EDAM.Type.Note();
                  Note.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Note != null && __isset.note) {
            field.Name = "note";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Note.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Note != null && __isset.note) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Note: ");
          __sb.Append(Note== null ? "<null>" : Note.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateNote_result : TBase
    {
      private Evernote.EDAM.Type.Note _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Note Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public updateNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Note();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateNote_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteNote_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public deleteNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class deleteNote_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public deleteNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("deleteNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("deleteNote_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeNote_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public expungeNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeNote_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public expungeNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeNote_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class copyNote_args : TBase
    {
      private string _authenticationToken;
      private string _noteGuid;
      private string _toNotebookGuid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NoteGuid
      {
        get
        {
          return _noteGuid;
        }
        set
        {
          __isset.noteGuid = true;
          this._noteGuid = value;
        }
      }

      public string ToNotebookGuid
      {
        get
        {
          return _toNotebookGuid;
        }
        set
        {
          __isset.toNotebookGuid = true;
          this._toNotebookGuid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool noteGuid;
        public bool toNotebookGuid;
      }

      public copyNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NoteGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  ToNotebookGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("copyNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NoteGuid != null && __isset.noteGuid) {
            field.Name = "noteGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NoteGuid);
            oprot.WriteFieldEnd();
          }
          if (ToNotebookGuid != null && __isset.toNotebookGuid) {
            field.Name = "toNotebookGuid";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(ToNotebookGuid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("copyNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NoteGuid != null && __isset.noteGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NoteGuid: ");
          __sb.Append(NoteGuid);
        }
        if (ToNotebookGuid != null && __isset.toNotebookGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ToNotebookGuid: ");
          __sb.Append(ToNotebookGuid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class copyNote_result : TBase
    {
      private Evernote.EDAM.Type.Note _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Note Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public copyNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Note();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("copyNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("copyNote_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listNoteVersions_args : TBase
    {
      private string _authenticationToken;
      private string _noteGuid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NoteGuid
      {
        get
        {
          return _noteGuid;
        }
        set
        {
          __isset.noteGuid = true;
          this._noteGuid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool noteGuid;
      }

      public listNoteVersions_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NoteGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listNoteVersions_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NoteGuid != null && __isset.noteGuid) {
            field.Name = "noteGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NoteGuid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listNoteVersions_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NoteGuid != null && __isset.noteGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NoteGuid: ");
          __sb.Append(NoteGuid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listNoteVersions_result : TBase
    {
      private List<NoteVersionId> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public List<NoteVersionId> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public listNoteVersions_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<NoteVersionId>();
                    TList _list214 = iprot.ReadListBegin();
                    for( int _i215 = 0; _i215 < _list214.Count; ++_i215)
                    {
                      NoteVersionId _elem216;
                      _elem216 = new NoteVersionId();
                      _elem216.Read(iprot);
                      Success.Add(_elem216);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listNoteVersions_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (NoteVersionId _iter217 in Success)
                {
                  _iter217.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listNoteVersions_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteVersion_args : TBase
    {
      private string _authenticationToken;
      private string _noteGuid;
      private int _updateSequenceNum;
      private bool _withResourcesData;
      private bool _withResourcesRecognition;
      private bool _withResourcesAlternateData;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NoteGuid
      {
        get
        {
          return _noteGuid;
        }
        set
        {
          __isset.noteGuid = true;
          this._noteGuid = value;
        }
      }

      public int UpdateSequenceNum
      {
        get
        {
          return _updateSequenceNum;
        }
        set
        {
          __isset.updateSequenceNum = true;
          this._updateSequenceNum = value;
        }
      }

      public bool WithResourcesData
      {
        get
        {
          return _withResourcesData;
        }
        set
        {
          __isset.withResourcesData = true;
          this._withResourcesData = value;
        }
      }

      public bool WithResourcesRecognition
      {
        get
        {
          return _withResourcesRecognition;
        }
        set
        {
          __isset.withResourcesRecognition = true;
          this._withResourcesRecognition = value;
        }
      }

      public bool WithResourcesAlternateData
      {
        get
        {
          return _withResourcesAlternateData;
        }
        set
        {
          __isset.withResourcesAlternateData = true;
          this._withResourcesAlternateData = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool noteGuid;
        public bool updateSequenceNum;
        public bool withResourcesData;
        public bool withResourcesRecognition;
        public bool withResourcesAlternateData;
      }

      public getNoteVersion_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NoteGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.I32) {
                  UpdateSequenceNum = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Bool) {
                  WithResourcesData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Bool) {
                  WithResourcesRecognition = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Bool) {
                  WithResourcesAlternateData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteVersion_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NoteGuid != null && __isset.noteGuid) {
            field.Name = "noteGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NoteGuid);
            oprot.WriteFieldEnd();
          }
          if (__isset.updateSequenceNum) {
            field.Name = "updateSequenceNum";
            field.Type = TType.I32;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(UpdateSequenceNum);
            oprot.WriteFieldEnd();
          }
          if (__isset.withResourcesData) {
            field.Name = "withResourcesData";
            field.Type = TType.Bool;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithResourcesData);
            oprot.WriteFieldEnd();
          }
          if (__isset.withResourcesRecognition) {
            field.Name = "withResourcesRecognition";
            field.Type = TType.Bool;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithResourcesRecognition);
            oprot.WriteFieldEnd();
          }
          if (__isset.withResourcesAlternateData) {
            field.Name = "withResourcesAlternateData";
            field.Type = TType.Bool;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithResourcesAlternateData);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteVersion_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NoteGuid != null && __isset.noteGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NoteGuid: ");
          __sb.Append(NoteGuid);
        }
        if (__isset.updateSequenceNum) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UpdateSequenceNum: ");
          __sb.Append(UpdateSequenceNum);
        }
        if (__isset.withResourcesData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithResourcesData: ");
          __sb.Append(WithResourcesData);
        }
        if (__isset.withResourcesRecognition) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithResourcesRecognition: ");
          __sb.Append(WithResourcesRecognition);
        }
        if (__isset.withResourcesAlternateData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithResourcesAlternateData: ");
          __sb.Append(WithResourcesAlternateData);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNoteVersion_result : TBase
    {
      private Evernote.EDAM.Type.Note _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Note Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getNoteVersion_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Note();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNoteVersion_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNoteVersion_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResource_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private bool _withData;
      private bool _withRecognition;
      private bool _withAttributes;
      private bool _withAlternateData;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public bool WithData
      {
        get
        {
          return _withData;
        }
        set
        {
          __isset.withData = true;
          this._withData = value;
        }
      }

      public bool WithRecognition
      {
        get
        {
          return _withRecognition;
        }
        set
        {
          __isset.withRecognition = true;
          this._withRecognition = value;
        }
      }

      public bool WithAttributes
      {
        get
        {
          return _withAttributes;
        }
        set
        {
          __isset.withAttributes = true;
          this._withAttributes = value;
        }
      }

      public bool WithAlternateData
      {
        get
        {
          return _withAlternateData;
        }
        set
        {
          __isset.withAlternateData = true;
          this._withAlternateData = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool withData;
        public bool withRecognition;
        public bool withAttributes;
        public bool withAlternateData;
      }

      public getResource_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Bool) {
                  WithData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Bool) {
                  WithRecognition = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Bool) {
                  WithAttributes = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Bool) {
                  WithAlternateData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResource_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (__isset.withData) {
            field.Name = "withData";
            field.Type = TType.Bool;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithData);
            oprot.WriteFieldEnd();
          }
          if (__isset.withRecognition) {
            field.Name = "withRecognition";
            field.Type = TType.Bool;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithRecognition);
            oprot.WriteFieldEnd();
          }
          if (__isset.withAttributes) {
            field.Name = "withAttributes";
            field.Type = TType.Bool;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithAttributes);
            oprot.WriteFieldEnd();
          }
          if (__isset.withAlternateData) {
            field.Name = "withAlternateData";
            field.Type = TType.Bool;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithAlternateData);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResource_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (__isset.withData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithData: ");
          __sb.Append(WithData);
        }
        if (__isset.withRecognition) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithRecognition: ");
          __sb.Append(WithRecognition);
        }
        if (__isset.withAttributes) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithAttributes: ");
          __sb.Append(WithAttributes);
        }
        if (__isset.withAlternateData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithAlternateData: ");
          __sb.Append(WithAlternateData);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResource_result : TBase
    {
      private Evernote.EDAM.Type.Resource _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Resource Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResource_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Resource();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResource_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResource_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceApplicationData_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getResourceApplicationData_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceApplicationData_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceApplicationData_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceApplicationData_result : TBase
    {
      private Evernote.EDAM.Type.LazyMap _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.LazyMap Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceApplicationData_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.LazyMap();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceApplicationData_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceApplicationData_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceApplicationDataEntry_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private string _key;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool key;
      }

      public getResourceApplicationDataEntry_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceApplicationDataEntry_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceApplicationDataEntry_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceApplicationDataEntry_result : TBase
    {
      private string _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceApplicationDataEntry_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceApplicationDataEntry_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceApplicationDataEntry_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class setResourceApplicationDataEntry_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private string _key;
      private string _value;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }

      public string Value
      {
        get
        {
          return _value;
        }
        set
        {
          __isset.@value = true;
          this._value = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool key;
        public bool @value;
      }

      public setResourceApplicationDataEntry_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.String) {
                  Value = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("setResourceApplicationDataEntry_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          if (Value != null && __isset.@value) {
            field.Name = "value";
            field.Type = TType.String;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Value);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("setResourceApplicationDataEntry_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        if (Value != null && __isset.@value) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Value: ");
          __sb.Append(Value);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class setResourceApplicationDataEntry_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public setResourceApplicationDataEntry_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("setResourceApplicationDataEntry_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("setResourceApplicationDataEntry_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class unsetResourceApplicationDataEntry_args : TBase
    {
      private string _authenticationToken;
      private string _guid;
      private string _key;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
        public bool key;
      }

      public unsetResourceApplicationDataEntry_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("unsetResourceApplicationDataEntry_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("unsetResourceApplicationDataEntry_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class unsetResourceApplicationDataEntry_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public unsetResourceApplicationDataEntry_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("unsetResourceApplicationDataEntry_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("unsetResourceApplicationDataEntry_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateResource_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Resource _resource;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Resource Resource
      {
        get
        {
          return _resource;
        }
        set
        {
          __isset.resource = true;
          this._resource = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool resource;
      }

      public updateResource_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Resource = new Evernote.EDAM.Type.Resource();
                  Resource.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateResource_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Resource != null && __isset.resource) {
            field.Name = "resource";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Resource.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateResource_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Resource != null && __isset.resource) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Resource: ");
          __sb.Append(Resource== null ? "<null>" : Resource.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateResource_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public updateResource_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateResource_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateResource_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceData_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getResourceData_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceData_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceData_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceData_result : TBase
    {
      private byte[] _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public byte[] Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceData_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceData_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteBinary(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceData_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceByHash_args : TBase
    {
      private string _authenticationToken;
      private string _noteGuid;
      private byte[] _contentHash;
      private bool _withData;
      private bool _withRecognition;
      private bool _withAlternateData;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NoteGuid
      {
        get
        {
          return _noteGuid;
        }
        set
        {
          __isset.noteGuid = true;
          this._noteGuid = value;
        }
      }

      public byte[] ContentHash
      {
        get
        {
          return _contentHash;
        }
        set
        {
          __isset.contentHash = true;
          this._contentHash = value;
        }
      }

      public bool WithData
      {
        get
        {
          return _withData;
        }
        set
        {
          __isset.withData = true;
          this._withData = value;
        }
      }

      public bool WithRecognition
      {
        get
        {
          return _withRecognition;
        }
        set
        {
          __isset.withRecognition = true;
          this._withRecognition = value;
        }
      }

      public bool WithAlternateData
      {
        get
        {
          return _withAlternateData;
        }
        set
        {
          __isset.withAlternateData = true;
          this._withAlternateData = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool noteGuid;
        public bool contentHash;
        public bool withData;
        public bool withRecognition;
        public bool withAlternateData;
      }

      public getResourceByHash_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NoteGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  ContentHash = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Bool) {
                  WithData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 5:
                if (field.Type == TType.Bool) {
                  WithRecognition = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 6:
                if (field.Type == TType.Bool) {
                  WithAlternateData = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceByHash_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NoteGuid != null && __isset.noteGuid) {
            field.Name = "noteGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NoteGuid);
            oprot.WriteFieldEnd();
          }
          if (ContentHash != null && __isset.contentHash) {
            field.Name = "contentHash";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBinary(ContentHash);
            oprot.WriteFieldEnd();
          }
          if (__isset.withData) {
            field.Name = "withData";
            field.Type = TType.Bool;
            field.ID = 4;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithData);
            oprot.WriteFieldEnd();
          }
          if (__isset.withRecognition) {
            field.Name = "withRecognition";
            field.Type = TType.Bool;
            field.ID = 5;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithRecognition);
            oprot.WriteFieldEnd();
          }
          if (__isset.withAlternateData) {
            field.Name = "withAlternateData";
            field.Type = TType.Bool;
            field.ID = 6;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(WithAlternateData);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceByHash_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NoteGuid != null && __isset.noteGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NoteGuid: ");
          __sb.Append(NoteGuid);
        }
        if (ContentHash != null && __isset.contentHash) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ContentHash: ");
          __sb.Append(ContentHash);
        }
        if (__isset.withData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithData: ");
          __sb.Append(WithData);
        }
        if (__isset.withRecognition) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithRecognition: ");
          __sb.Append(WithRecognition);
        }
        if (__isset.withAlternateData) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("WithAlternateData: ");
          __sb.Append(WithAlternateData);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceByHash_result : TBase
    {
      private Evernote.EDAM.Type.Resource _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Resource Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceByHash_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Resource();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceByHash_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceByHash_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceRecognition_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getResourceRecognition_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceRecognition_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceRecognition_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceRecognition_result : TBase
    {
      private byte[] _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public byte[] Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceRecognition_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceRecognition_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteBinary(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceRecognition_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceAlternateData_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getResourceAlternateData_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceAlternateData_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceAlternateData_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceAlternateData_result : TBase
    {
      private byte[] _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public byte[] Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceAlternateData_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadBinary();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceAlternateData_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteBinary(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceAlternateData_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceAttributes_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public getResourceAttributes_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceAttributes_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceAttributes_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getResourceAttributes_result : TBase
    {
      private Evernote.EDAM.Type.ResourceAttributes _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.ResourceAttributes Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public getResourceAttributes_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.ResourceAttributes();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getResourceAttributes_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getResourceAttributes_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getPublicNotebook_args : TBase
    {
      private int _userId;
      private string _publicUri;

      public int UserId
      {
        get
        {
          return _userId;
        }
        set
        {
          __isset.userId = true;
          this._userId = value;
        }
      }

      public string PublicUri
      {
        get
        {
          return _publicUri;
        }
        set
        {
          __isset.publicUri = true;
          this._publicUri = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userId;
        public bool publicUri;
      }

      public getPublicNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.I32) {
                  UserId = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  PublicUri = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getPublicNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (__isset.userId) {
            field.Name = "userId";
            field.Type = TType.I32;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(UserId);
            oprot.WriteFieldEnd();
          }
          if (PublicUri != null && __isset.publicUri) {
            field.Name = "publicUri";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(PublicUri);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getPublicNotebook_args(");
        bool __first = true;
        if (__isset.userId) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserId: ");
          __sb.Append(UserId);
        }
        if (PublicUri != null && __isset.publicUri) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("PublicUri: ");
          __sb.Append(PublicUri);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getPublicNotebook_result : TBase
    {
      private Evernote.EDAM.Type.Notebook _success;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public Evernote.EDAM.Type.Notebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool systemException;
        public bool notFoundException;
      }

      public getPublicNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Notebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getPublicNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getPublicNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class shareNotebook_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.SharedNotebook _sharedNotebook;
      private string _message;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.SharedNotebook SharedNotebook
      {
        get
        {
          return _sharedNotebook;
        }
        set
        {
          __isset.sharedNotebook = true;
          this._sharedNotebook = value;
        }
      }

      public string Message
      {
        get
        {
          return _message;
        }
        set
        {
          __isset.message = true;
          this._message = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool sharedNotebook;
        public bool message;
      }

      public shareNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SharedNotebook = new Evernote.EDAM.Type.SharedNotebook();
                  SharedNotebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Message = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("shareNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (SharedNotebook != null && __isset.sharedNotebook) {
            field.Name = "sharedNotebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            SharedNotebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (Message != null && __isset.message) {
            field.Name = "message";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Message);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("shareNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (SharedNotebook != null && __isset.sharedNotebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SharedNotebook: ");
          __sb.Append(SharedNotebook== null ? "<null>" : SharedNotebook.ToString());
        }
        if (Message != null && __isset.message) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Message: ");
          __sb.Append(Message);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class shareNotebook_result : TBase
    {
      private Evernote.EDAM.Type.SharedNotebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.SharedNotebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public shareNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.SharedNotebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("shareNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("shareNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createOrUpdateNotebookShares_args : TBase
    {
      private string _authenticationToken;
      private NotebookShareTemplate _shareTemplate;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public NotebookShareTemplate ShareTemplate
      {
        get
        {
          return _shareTemplate;
        }
        set
        {
          __isset.shareTemplate = true;
          this._shareTemplate = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool shareTemplate;
      }

      public createOrUpdateNotebookShares_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  ShareTemplate = new NotebookShareTemplate();
                  ShareTemplate.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createOrUpdateNotebookShares_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (ShareTemplate != null && __isset.shareTemplate) {
            field.Name = "shareTemplate";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            ShareTemplate.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createOrUpdateNotebookShares_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (ShareTemplate != null && __isset.shareTemplate) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ShareTemplate: ");
          __sb.Append(ShareTemplate== null ? "<null>" : ShareTemplate.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createOrUpdateNotebookShares_result : TBase
    {
      private CreateOrUpdateNotebookSharesResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMInvalidContactsException _invalidContactsException;

      public CreateOrUpdateNotebookSharesResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMInvalidContactsException InvalidContactsException
      {
        get
        {
          return _invalidContactsException;
        }
        set
        {
          __isset.invalidContactsException = true;
          this._invalidContactsException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
        public bool invalidContactsException;
      }

      public createOrUpdateNotebookShares_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new CreateOrUpdateNotebookSharesResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 4:
                if (field.Type == TType.Struct) {
                  InvalidContactsException = new Evernote.EDAM.Error.EDAMInvalidContactsException();
                  InvalidContactsException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createOrUpdateNotebookShares_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.invalidContactsException) {
            if (InvalidContactsException != null) {
              field.Name = "InvalidContactsException";
              field.Type = TType.Struct;
              field.ID = 4;
              oprot.WriteFieldBegin(field);
              InvalidContactsException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createOrUpdateNotebookShares_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (InvalidContactsException != null && __isset.invalidContactsException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("InvalidContactsException: ");
          __sb.Append(InvalidContactsException== null ? "<null>" : InvalidContactsException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateSharedNotebook_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.SharedNotebook _sharedNotebook;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.SharedNotebook SharedNotebook
      {
        get
        {
          return _sharedNotebook;
        }
        set
        {
          __isset.sharedNotebook = true;
          this._sharedNotebook = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool sharedNotebook;
      }

      public updateSharedNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SharedNotebook = new Evernote.EDAM.Type.SharedNotebook();
                  SharedNotebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateSharedNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (SharedNotebook != null && __isset.sharedNotebook) {
            field.Name = "sharedNotebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            SharedNotebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateSharedNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (SharedNotebook != null && __isset.sharedNotebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SharedNotebook: ");
          __sb.Append(SharedNotebook== null ? "<null>" : SharedNotebook.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateSharedNotebook_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public updateSharedNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateSharedNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateSharedNotebook_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class setNotebookRecipientSettings_args : TBase
    {
      private string _authenticationToken;
      private string _notebookGuid;
      private Evernote.EDAM.Type.NotebookRecipientSettings _recipientSettings;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NotebookGuid
      {
        get
        {
          return _notebookGuid;
        }
        set
        {
          __isset.notebookGuid = true;
          this._notebookGuid = value;
        }
      }

      public Evernote.EDAM.Type.NotebookRecipientSettings RecipientSettings
      {
        get
        {
          return _recipientSettings;
        }
        set
        {
          __isset.recipientSettings = true;
          this._recipientSettings = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool notebookGuid;
        public bool recipientSettings;
      }

      public setNotebookRecipientSettings_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NotebookGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  RecipientSettings = new Evernote.EDAM.Type.NotebookRecipientSettings();
                  RecipientSettings.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("setNotebookRecipientSettings_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NotebookGuid != null && __isset.notebookGuid) {
            field.Name = "notebookGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NotebookGuid);
            oprot.WriteFieldEnd();
          }
          if (RecipientSettings != null && __isset.recipientSettings) {
            field.Name = "recipientSettings";
            field.Type = TType.Struct;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            RecipientSettings.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("setNotebookRecipientSettings_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NotebookGuid != null && __isset.notebookGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotebookGuid: ");
          __sb.Append(NotebookGuid);
        }
        if (RecipientSettings != null && __isset.recipientSettings) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("RecipientSettings: ");
          __sb.Append(RecipientSettings== null ? "<null>" : RecipientSettings.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class setNotebookRecipientSettings_result : TBase
    {
      private Evernote.EDAM.Type.Notebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.Notebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public setNotebookRecipientSettings_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.Notebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("setNotebookRecipientSettings_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("setNotebookRecipientSettings_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listSharedNotebooks_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listSharedNotebooks_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listSharedNotebooks_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listSharedNotebooks_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listSharedNotebooks_result : TBase
    {
      private List<Evernote.EDAM.Type.SharedNotebook> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.SharedNotebook> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public listSharedNotebooks_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.SharedNotebook>();
                    TList _list218 = iprot.ReadListBegin();
                    for( int _i219 = 0; _i219 < _list218.Count; ++_i219)
                    {
                      Evernote.EDAM.Type.SharedNotebook _elem220;
                      _elem220 = new Evernote.EDAM.Type.SharedNotebook();
                      _elem220.Read(iprot);
                      Success.Add(_elem220);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listSharedNotebooks_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.SharedNotebook _iter221 in Success)
                {
                  _iter221.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listSharedNotebooks_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createLinkedNotebook_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.LinkedNotebook _linkedNotebook;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.LinkedNotebook LinkedNotebook
      {
        get
        {
          return _linkedNotebook;
        }
        set
        {
          __isset.linkedNotebook = true;
          this._linkedNotebook = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool linkedNotebook;
      }

      public createLinkedNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  LinkedNotebook = new Evernote.EDAM.Type.LinkedNotebook();
                  LinkedNotebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createLinkedNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (LinkedNotebook != null && __isset.linkedNotebook) {
            field.Name = "linkedNotebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            LinkedNotebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createLinkedNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (LinkedNotebook != null && __isset.linkedNotebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("LinkedNotebook: ");
          __sb.Append(LinkedNotebook== null ? "<null>" : LinkedNotebook.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class createLinkedNotebook_result : TBase
    {
      private Evernote.EDAM.Type.LinkedNotebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.LinkedNotebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public createLinkedNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.LinkedNotebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("createLinkedNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("createLinkedNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateLinkedNotebook_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.LinkedNotebook _linkedNotebook;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.LinkedNotebook LinkedNotebook
      {
        get
        {
          return _linkedNotebook;
        }
        set
        {
          __isset.linkedNotebook = true;
          this._linkedNotebook = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool linkedNotebook;
      }

      public updateLinkedNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  LinkedNotebook = new Evernote.EDAM.Type.LinkedNotebook();
                  LinkedNotebook.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateLinkedNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (LinkedNotebook != null && __isset.linkedNotebook) {
            field.Name = "linkedNotebook";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            LinkedNotebook.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateLinkedNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (LinkedNotebook != null && __isset.linkedNotebook) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("LinkedNotebook: ");
          __sb.Append(LinkedNotebook== null ? "<null>" : LinkedNotebook.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateLinkedNotebook_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public updateLinkedNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateLinkedNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateLinkedNotebook_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listLinkedNotebooks_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public listLinkedNotebooks_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listLinkedNotebooks_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listLinkedNotebooks_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class listLinkedNotebooks_result : TBase
    {
      private List<Evernote.EDAM.Type.LinkedNotebook> _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public List<Evernote.EDAM.Type.LinkedNotebook> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public listLinkedNotebooks_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.List) {
                  {
                    Success = new List<Evernote.EDAM.Type.LinkedNotebook>();
                    TList _list222 = iprot.ReadListBegin();
                    for( int _i223 = 0; _i223 < _list222.Count; ++_i223)
                    {
                      Evernote.EDAM.Type.LinkedNotebook _elem224;
                      _elem224 = new Evernote.EDAM.Type.LinkedNotebook();
                      _elem224.Read(iprot);
                      Success.Add(_elem224);
                    }
                    iprot.ReadListEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("listLinkedNotebooks_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.List;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteListBegin(new TList(TType.Struct, Success.Count));
                foreach (Evernote.EDAM.Type.LinkedNotebook _iter225 in Success)
                {
                  _iter225.Write(oprot);
                }
                oprot.WriteListEnd();
              }
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("listLinkedNotebooks_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeLinkedNotebook_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public expungeLinkedNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeLinkedNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeLinkedNotebook_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class expungeLinkedNotebook_result : TBase
    {
      private int _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public int Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public expungeLinkedNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.I32) {
                  Success = iprot.ReadI32();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("expungeLinkedNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.I32;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteI32(Success);
            oprot.WriteFieldEnd();
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("expungeLinkedNotebook_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateToSharedNotebook_args : TBase
    {
      private string _shareKeyOrGlobalId;
      private string _authenticationToken;

      public string ShareKeyOrGlobalId
      {
        get
        {
          return _shareKeyOrGlobalId;
        }
        set
        {
          __isset.shareKeyOrGlobalId = true;
          this._shareKeyOrGlobalId = value;
        }
      }

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool shareKeyOrGlobalId;
        public bool authenticationToken;
      }

      public authenticateToSharedNotebook_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  ShareKeyOrGlobalId = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateToSharedNotebook_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (ShareKeyOrGlobalId != null && __isset.shareKeyOrGlobalId) {
            field.Name = "shareKeyOrGlobalId";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(ShareKeyOrGlobalId);
            oprot.WriteFieldEnd();
          }
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateToSharedNotebook_args(");
        bool __first = true;
        if (ShareKeyOrGlobalId != null && __isset.shareKeyOrGlobalId) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ShareKeyOrGlobalId: ");
          __sb.Append(ShareKeyOrGlobalId);
        }
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateToSharedNotebook_result : TBase
    {
      private Evernote.EDAM.UserStore.AuthenticationResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.UserStore.AuthenticationResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public authenticateToSharedNotebook_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.UserStore.AuthenticationResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateToSharedNotebook_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateToSharedNotebook_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getSharedNotebookByAuth_args : TBase
    {
      private string _authenticationToken;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
      }

      public getSharedNotebookByAuth_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getSharedNotebookByAuth_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getSharedNotebookByAuth_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getSharedNotebookByAuth_result : TBase
    {
      private Evernote.EDAM.Type.SharedNotebook _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Type.SharedNotebook Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public getSharedNotebookByAuth_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.Type.SharedNotebook();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getSharedNotebookByAuth_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getSharedNotebookByAuth_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class emailNote_args : TBase
    {
      private string _authenticationToken;
      private NoteEmailParameters _parameters;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public NoteEmailParameters Parameters
      {
        get
        {
          return _parameters;
        }
        set
        {
          __isset.parameters = true;
          this._parameters = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool parameters;
      }

      public emailNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Parameters = new NoteEmailParameters();
                  Parameters.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("emailNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Parameters != null && __isset.parameters) {
            field.Name = "parameters";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Parameters.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("emailNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Parameters != null && __isset.parameters) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Parameters: ");
          __sb.Append(Parameters== null ? "<null>" : Parameters.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class emailNote_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public emailNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("emailNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("emailNote_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class shareNote_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public shareNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("shareNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("shareNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class shareNote_result : TBase
    {
      private string _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public shareNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("shareNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("shareNote_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class stopSharingNote_args : TBase
    {
      private string _authenticationToken;
      private string _guid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool guid;
      }

      public stopSharingNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("stopSharingNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("stopSharingNote_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class stopSharingNote_result : TBase
    {
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public stopSharingNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("stopSharingNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("stopSharingNote_result(");
        bool __first = true;
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateToSharedNote_args : TBase
    {
      private string _guid;
      private string _noteKey;
      private string _authenticationToken;

      public string Guid
      {
        get
        {
          return _guid;
        }
        set
        {
          __isset.guid = true;
          this._guid = value;
        }
      }

      public string NoteKey
      {
        get
        {
          return _noteKey;
        }
        set
        {
          __isset.noteKey = true;
          this._noteKey = value;
        }
      }

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool guid;
        public bool noteKey;
        public bool authenticationToken;
      }

      public authenticateToSharedNote_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Guid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NoteKey = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateToSharedNote_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Guid != null && __isset.guid) {
            field.Name = "guid";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Guid);
            oprot.WriteFieldEnd();
          }
          if (NoteKey != null && __isset.noteKey) {
            field.Name = "noteKey";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NoteKey);
            oprot.WriteFieldEnd();
          }
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateToSharedNote_args(");
        bool __first = true;
        if (Guid != null && __isset.guid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Guid: ");
          __sb.Append(Guid);
        }
        if (NoteKey != null && __isset.noteKey) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NoteKey: ");
          __sb.Append(NoteKey);
        }
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class authenticateToSharedNote_result : TBase
    {
      private Evernote.EDAM.UserStore.AuthenticationResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public Evernote.EDAM.UserStore.AuthenticationResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public authenticateToSharedNote_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new Evernote.EDAM.UserStore.AuthenticationResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("authenticateToSharedNote_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("authenticateToSharedNote_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findRelated_args : TBase
    {
      private string _authenticationToken;
      private RelatedQuery _query;
      private RelatedResultSpec _resultSpec;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public RelatedQuery Query
      {
        get
        {
          return _query;
        }
        set
        {
          __isset.query = true;
          this._query = value;
        }
      }

      public RelatedResultSpec ResultSpec
      {
        get
        {
          return _resultSpec;
        }
        set
        {
          __isset.resultSpec = true;
          this._resultSpec = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool query;
        public bool resultSpec;
      }

      public findRelated_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Query = new RelatedQuery();
                  Query.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  ResultSpec = new RelatedResultSpec();
                  ResultSpec.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findRelated_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Query != null && __isset.query) {
            field.Name = "query";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Query.Write(oprot);
            oprot.WriteFieldEnd();
          }
          if (ResultSpec != null && __isset.resultSpec) {
            field.Name = "resultSpec";
            field.Type = TType.Struct;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            ResultSpec.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findRelated_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Query != null && __isset.query) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Query: ");
          __sb.Append(Query== null ? "<null>" : Query.ToString());
        }
        if (ResultSpec != null && __isset.resultSpec) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("ResultSpec: ");
          __sb.Append(ResultSpec== null ? "<null>" : ResultSpec.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class findRelated_result : TBase
    {
      private RelatedResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;

      public RelatedResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool systemException;
        public bool notFoundException;
      }

      public findRelated_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new RelatedResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("findRelated_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("findRelated_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateNoteIfUsnMatches_args : TBase
    {
      private string _authenticationToken;
      private Evernote.EDAM.Type.Note _note;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public Evernote.EDAM.Type.Note Note
      {
        get
        {
          return _note;
        }
        set
        {
          __isset.note = true;
          this._note = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool note;
      }

      public updateNoteIfUsnMatches_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Note = new Evernote.EDAM.Type.Note();
                  Note.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateNoteIfUsnMatches_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Note != null && __isset.note) {
            field.Name = "note";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Note.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateNoteIfUsnMatches_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Note != null && __isset.note) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Note: ");
          __sb.Append(Note== null ? "<null>" : Note.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class updateNoteIfUsnMatches_result : TBase
    {
      private UpdateNoteIfUsnMatchesResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public UpdateNoteIfUsnMatchesResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public updateNoteIfUsnMatches_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new UpdateNoteIfUsnMatchesResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("updateNoteIfUsnMatches_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("updateNoteIfUsnMatches_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class manageNotebookShares_args : TBase
    {
      private string _authenticationToken;
      private ManageNotebookSharesParameters _parameters;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public ManageNotebookSharesParameters Parameters
      {
        get
        {
          return _parameters;
        }
        set
        {
          __isset.parameters = true;
          this._parameters = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool parameters;
      }

      public manageNotebookShares_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  Parameters = new ManageNotebookSharesParameters();
                  Parameters.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("manageNotebookShares_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (Parameters != null && __isset.parameters) {
            field.Name = "parameters";
            field.Type = TType.Struct;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            Parameters.Write(oprot);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("manageNotebookShares_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (Parameters != null && __isset.parameters) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Parameters: ");
          __sb.Append(Parameters== null ? "<null>" : Parameters.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class manageNotebookShares_result : TBase
    {
      private ManageNotebookSharesResult _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public ManageNotebookSharesResult Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public manageNotebookShares_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new ManageNotebookSharesResult();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("manageNotebookShares_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("manageNotebookShares_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNotebookShares_args : TBase
    {
      private string _authenticationToken;
      private string _notebookGuid;

      public string AuthenticationToken
      {
        get
        {
          return _authenticationToken;
        }
        set
        {
          __isset.authenticationToken = true;
          this._authenticationToken = value;
        }
      }

      public string NotebookGuid
      {
        get
        {
          return _notebookGuid;
        }
        set
        {
          __isset.notebookGuid = true;
          this._notebookGuid = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool authenticationToken;
        public bool notebookGuid;
      }

      public getNotebookShares_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  AuthenticationToken = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  NotebookGuid = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNotebookShares_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (AuthenticationToken != null && __isset.authenticationToken) {
            field.Name = "authenticationToken";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(AuthenticationToken);
            oprot.WriteFieldEnd();
          }
          if (NotebookGuid != null && __isset.notebookGuid) {
            field.Name = "notebookGuid";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(NotebookGuid);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNotebookShares_args(");
        bool __first = true;
        if (AuthenticationToken != null && __isset.authenticationToken) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("AuthenticationToken: ");
          __sb.Append(AuthenticationToken);
        }
        if (NotebookGuid != null && __isset.notebookGuid) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotebookGuid: ");
          __sb.Append(NotebookGuid);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class getNotebookShares_result : TBase
    {
      private ShareRelationships _success;
      private Evernote.EDAM.Error.EDAMUserException _userException;
      private Evernote.EDAM.Error.EDAMNotFoundException _notFoundException;
      private Evernote.EDAM.Error.EDAMSystemException _systemException;

      public ShareRelationships Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }

      public Evernote.EDAM.Error.EDAMUserException UserException
      {
        get
        {
          return _userException;
        }
        set
        {
          __isset.userException = true;
          this._userException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMNotFoundException NotFoundException
      {
        get
        {
          return _notFoundException;
        }
        set
        {
          __isset.notFoundException = true;
          this._notFoundException = value;
        }
      }

      public Evernote.EDAM.Error.EDAMSystemException SystemException
      {
        get
        {
          return _systemException;
        }
        set
        {
          __isset.systemException = true;
          this._systemException = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
        public bool userException;
        public bool notFoundException;
        public bool systemException;
      }

      public getNotebookShares_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Struct) {
                  Success = new ShareRelationships();
                  Success.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 1:
                if (field.Type == TType.Struct) {
                  UserException = new Evernote.EDAM.Error.EDAMUserException();
                  UserException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Struct) {
                  NotFoundException = new Evernote.EDAM.Error.EDAMNotFoundException();
                  NotFoundException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Struct) {
                  SystemException = new Evernote.EDAM.Error.EDAMSystemException();
                  SystemException.Read(iprot);
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("getNotebookShares_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Struct;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              Success.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.userException) {
            if (UserException != null) {
              field.Name = "UserException";
              field.Type = TType.Struct;
              field.ID = 1;
              oprot.WriteFieldBegin(field);
              UserException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.notFoundException) {
            if (NotFoundException != null) {
              field.Name = "NotFoundException";
              field.Type = TType.Struct;
              field.ID = 2;
              oprot.WriteFieldBegin(field);
              NotFoundException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          } else if (this.__isset.systemException) {
            if (SystemException != null) {
              field.Name = "SystemException";
              field.Type = TType.Struct;
              field.ID = 3;
              oprot.WriteFieldBegin(field);
              SystemException.Write(oprot);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("getNotebookShares_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success== null ? "<null>" : Success.ToString());
        }
        if (UserException != null && __isset.userException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("UserException: ");
          __sb.Append(UserException== null ? "<null>" : UserException.ToString());
        }
        if (NotFoundException != null && __isset.notFoundException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("NotFoundException: ");
          __sb.Append(NotFoundException== null ? "<null>" : NotFoundException.ToString());
        }
        if (SystemException != null && __isset.systemException) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("SystemException: ");
          __sb.Append(SystemException== null ? "<null>" : SystemException.ToString());
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }

  }
}
